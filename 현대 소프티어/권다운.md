##### 1. @Async와 Redis INCR 활용한 방문자 수 로직 개선에 대해 자세히 설명해 주세요
기존에는 유저의 프로필 페이지에 접근할 때마다 서버에서 방문자 수 증가 로직이 **트랜잭션 안에서 동기적으로 실행되는 구조**였습니다. 구체적인 동작 순서는 다음과 같습니다.

1. 클라이언트가 프로필 API를 호출하면
    
2. 컨트롤러에서 서비스 로직으로 진입하면서
    
3. Redis에서 기존 방문자 수를 조회한 뒤
    
4. 1 증가시킨 값을 다시 Redis에 덮어쓰는 방식이었고,
    
5. 이 모든 작업이 트랜잭션 내부에서 순차적으로 처리되었습니다.
    

이 방식은 단일 요청에는 문제가 없지만, 특정 인기 유저에게 **짧은 시간에 수백 개의 요청이 몰리는 경우**, 다음과 같은 병목이 발생했습니다:

- Redis 조회 (`GET`) → 수정 (`SET`) 방식은 동시 접근 시 **I/O 병목과 race condition 위험**이 존재했고
    
- 모든 요청이 **처리 완료될 때까지 대기하는 동기 구조**였기 때문에 TPS가 급격히 하락했습니다.
    
- 또한 이 로직이 트랜잭션 내에서 처리되다 보니, **전체 응답 속도**에도 영향을 주었습니다.
    

결과적으로, 프로필 조회 자체는 가벼운 요청이어야 함에도, **조회수 증가 로직이 전체 요청 처리 속도를 저하시킨 병목 지점**이었습니다.

1. **비동기 처리 (@Async) 도입**

기존에는 방문자 수 증가 로직이 트랜잭션 내부에서 동기적으로 실행되었기 때문에 전체 API 응답 시간이 지연됐습니다. 이를 개선하기 위해 해당 로직을 **@Async 어노테이션으로 분리**하여 별도 스레드에서 비동기로 처리했습니다.  
이로써 메인 로직은 방문자 수 처리 결과를 기다리지 않고 **즉시 응답을 반환**할 수 있게 되었습니다.

---
2. **Redis INCR 명령어 활용**

기존에는 Redis `GET → 증가 → SET` 방식이었는데, 이는 멀티 쓰레드 환경에서 race condition이나 I/O 병목을 유발할 수 있습니다.  
이를 **원자적 연산인 `INCR`로 대체**하여, Redis 내부에서 자동으로 증가 처리를 하도록 변경했습니다.  
이 덕분에 락 없이도 **동시성 문제가 없는 안전한 카운팅**이 가능해졌습니다.

---
3. **Redisson 락 범위 최소화**

일부 보호가 필요한 로직에는 여전히 Redisson 분산 락을 사용하되, 락의 **범위를 최소화**하고, INCR 같은 안전한 연산은 락 없이 처리되도록 조정했습니다.  
불필요한 락 사용을 줄이면서도, **데이터 무결성을 유지**할 수 있는 구조로 변경했습니다.

##### 2. Answer 저장 시 어떤 순서로 락이 걸리며 데드락이 발생했는지, 트랜잭션 순서와 락 종류를 설명해 주세요.
Answer가 유저 id를 fk로 갖고 있는 상황에서 answer를 저장하면서 user에 대한 무결성 확보를 위해 유저에 대한 공유락을 요청
이후 같은 트랜잭션에서 유저에 대해 수정하게 되었고 그로인해 베타락을 요청하게 되면서 데드락이 발생하게 되었음
##### 3. 왜 공유락(S lock)이 문제가 되었고, 왜 배타락(X lock) 요청과 충돌이 일어났나요? 
결국 정합성을 위한 연관관계가 문제였고 그로인해 락에 대한 충돌이 발생
##### 4. 연관 관계 제거 후에도 데이터 무결성이나 참조 문제는 없었나요? 그 위험은 어떻게 관리했나요?
연관관계 제거 후 데이터 무결성을 위해 어플리케이션 단 안에서 유저가 실제로 존재하는지 확인하는 작업을 추가하여 무결성을 확보


##### 5. 사용했던 인덱스 구조와, 왜 단일 인덱스로는 해결이 되지 않았는지 설명해 주세요.
    
##### 6. 시간순 정렬 시 발생한 성능 저하의 정확한 쿼리 예시는 무엇이며, 어떤 방식으로 개선했나요?
    
##### 7.  복합 인덱스를 만들 때 필드 순서를 어떻게 결정했나요?
    

### 🔄 N+1 문제

13. Answer → Question 조회 시 N+1 문제가 왜 발생했는지 설명해 주세요.
    
14. fetch join 외에도 고려했던 해결책이 있다면 어떤 것이 있었고, 왜 fetch join을 선택했나요?

