### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
##### 설명
JVM(Java Virtual Machine)은 **자바 프로그램이 실행되는 가상화된 실행 환경**으로, 자바뿐만 아니라 Kotlin, Scala 등 JVM 기반 언어로 작성된 프로그램이 동작할 수 있도록 설계된 **추상 컴퓨터(virtual machine)**입니다.

**JVM의 주요 역할**

1. **바이트코드 실행**
    
    - 자바 소스코드(`.java`)는 컴파일러(`javac`)를 통해 **바이트코드(`.class`)**로 변환됩니다.
        
    - JVM은 이 바이트코드를 해석(인터프리트)하거나 **JIT(Just-In-Time) 컴파일러**를 통해 네이티브 머신 코드로 변환하여 실행합니다.
        
2. **운영체제 독립성 제공**
    
    - 자바의 **“Write Once, Run Anywhere”** 철학을 가능하게 하는 핵심 요소입니다.
        
    - 한 번 컴파일된 바이트코드는 JVM이 설치된 어떤 OS나 하드웨어 환경에서도 동일하게 실행됩니다.
        
3. **메모리 관리 (Garbage Collection)**
    
    - JVM은 프로그램에서 사용되는 메모리를 **힙(Heap)**과 **스택(Stack)** 영역으로 관리합니다.
        
    - 사용이 끝난 객체를 자동으로 회수하는 **Garbage Collector(GC)**를 내장하고 있어 메모리 누수를 줄입니다.
        
4. **보안 및 예외 처리**
    
    - 바이트코드 검증(Bytecode Verifier)을 통해 악성 코드 실행을 방지합니다.
        
    - 예외(Exception) 처리 메커니즘을 제공하여 안정적인 실행을 지원합니다.
        
5. **런타임 환경 제공**
    
    - 클래스 로딩(Class Loader), 실행 엔진(Execution Engine), 네이티브 인터페이스(JNI) 등을 통해 애플리케이션 실행에 필요한 런타임 환경을 제공합니다.
        

---
**JVM의 구조**

1. **클래스 로더(Class Loader)**
    
    - `.class` 파일을 메모리로 로드하고, 링크(Linking)와 초기화를 수행합니다.
        
2. **런타임 데이터 영역(Runtime Data Areas)**
    
    - **메서드 영역(Method Area):** 클래스 메타데이터, 정적 변수, 상수 풀 저장.
        
    - **힙(Heap):** 객체가 저장되는 영역, GC의 관리 대상.
        
    - **스택(Stack):** 메서드 호출 시 생성되는 프레임을 저장.
        
    - **PC 레지스터:** 현재 실행 중인 명령어의 주소 저장.
        
    - **네이티브 메서드 스택:** JNI 호출 시 사용.
        
3. **실행 엔진(Execution Engine)**
    
    - **인터프리터:** 바이트코드를 한 줄씩 해석 실행.
        
    - **JIT 컴파일러:** 자주 실행되는 코드를 네이티브 코드로 변환해 성능 향상.
        
    - **Garbage Collector:** 메모리 관리 자동화.
        

---
**정리**

JVM은 **자바 프로그램을 하드웨어와 OS에 독립적으로 실행할 수 있게 하는 가상 컴퓨터**이자, **메모리 관리와 보안을 책임지는 런타임 환경**입니다.  
만약 JVM이 없다면, 자바 프로그램은 현재처럼 다양한 플랫폼에서 동일하게 실행될 수 없습니다.
##### 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
✅ JVM 위에서 실행 가능한 다른 언어들

|언어|특징|
|---|---|
|**Kotlin**|JetBrains에서 개발, 자바와 100% 상호운용 가능. Android 공식 언어.|
|**Scala**|함수형 + 객체지향, 고급 언어 기능. Spark의 주요 언어.|
|**Groovy**|자바 문법 기반의 동적 스크립트 언어, Gradle에 사용됨.|
|**Clojure**|함수형, Lisp 계열 언어. 불변성과 병렬처리 강조.|
|**JRuby**|Ruby를 JVM에서 실행할 수 있게 만든 구현체.|
|**Jython**|Python 2.x 문법을 JVM 위에서 실행 가능. (현재는 거의 사용 안 됨)|
|**Ceylon, Fantom, Frege, Xtend 등**|JVM 기반으로 개발된 다양한 실험적 언어들|

---

🧠 왜 다른 언어들도 JVM 위에서 실행 가능한가요?

JVM은 자바에 특화된 것이 아니라 **“바이트코드”라는 중간 표현을 실행**하는 구조입니다.  
즉, 자바가 아닌 언어도 **“JVM 바이트코드로 컴파일”만 하면** JVM에서 실행할 수 있습니다.

🧩 장점

- **운영체제 독립성**: 어떤 언어든 JVM 위에서 돌아가면 플랫폼 독립성 확보.
    
- **기존 Java 생태계 활용**: Java 라이브러리, 프레임워크 사용 가능.
    
- **성능**: JVM의 JIT 컴파일러, GC 등을 그대로 활용.
    

⚠️ 단점

- **자바 중심 최적화**: JVM은 기본적으로 자바 스타일 코드에 최적화됨.
    
- **언어 특성 제한**: 언어 고유 기능을 JVM이 지원하지 않을 수 있음.
    
- **바이트코드 제약**: 일부 언어 표현은 JVM 바이트코드로 변환하기 까다로움.
    
✅ 결론

> JVM은 **자바 전용이 아닙니다.**  
> **“JVM 바이트코드로 컴파일될 수 있는 언어라면 모두 실행 가능합니다.”**

자바 외에도 Kotlin, Scala, Groovy처럼 **JVM 생태계의 장점을 공유하며 성장한 언어들**이 존재합니다.
##### 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
JVM 계열 언어(예: Java, Kotlin, Scala)는 기본적으로 **JVM 바이트코드(`.class`)를 생성**해 JVM 위에서 실행되도록 설계되었기 때문에 **“일반적인 기계어 바이너리(네이티브 코드)”로 직접 컴파일해 실행**하는 것은 표준 방식이 아닙니다.  
그러나, **특수한 도구나 컴파일러를 사용하면 JVM 없이도 실행할 수 있는 네이티브 바이너리를 만들 수 있습니다.**

---
 **1. JVM 계열 언어를 네이티브로 컴파일할 수 있는 방법**

 **(1) GraalVM Native Image**

- **Java, Kotlin, Scala** 등의 JVM 언어를 **Ahead-Of-Time(AOT)** 컴파일하여 **JVM 없이 실행 가능한 네이티브 실행 파일**을 생성합니다.
    
- **장점:** 시작 속도가 매우 빠르고 메모리 사용량이 줄어듭니다.
    
- **단점:** 빌드 속도가 느리고 리플렉션이나 동적 로딩 지원이 제한될 수 있습니다.
    

---
 **(2) Kotlin/Native**

- Kotlin은 JVM뿐만 아니라 **LLVM 백엔드**를 통해 **iOS, Windows, Linux** 등에서 동작하는 **네이티브 코드로 변환**할 수 있습니다.
    
- 예: 안드로이드 앱에서는 JVM을 쓰지만, iOS 앱에서는 Kotlin/Native로 기계어 코드 생성.
    

 **(3) Excelsior JET (단종)**

- 자바 바이트코드를 **기계어로 직접 컴파일해 실행 파일**로 만드는 상용 솔루션이 있었으나 현재는 개발 중단.
    

---
 **2. 왜 기본적으로 JVM에서 실행되도록 설계되었나?**

1. **운영체제/하드웨어 독립성**
    
    - 한 번 컴파일된 `.class` 파일은 어떤 OS에서든 JVM만 있으면 실행 가능 (**WORA – Write Once, Run Anywhere**).
        
2. **JIT 컴파일러 최적화**
    
    - JVM은 런타임에 자주 실행되는 코드만 **Just-In-Time(동적 최적화)**으로 네이티브 코드로 변환하여 성능을 높임.
        
3. **풍부한 생태계**
    
    - Java 라이브러리, Spring, JPA 등 대부분의 프레임워크가 **JVM 환경**을 전제로 동작.
        

---
 **3. 정리**

- **JVM 언어를 네이티브 코드로 변환하는 것은 가능하지만, 일반적인 접근은 아님.**
    
- **GraalVM Native Image** 또는 **Kotlin/Native** 같은 도구를 사용해야 하며,  
    이런 방식은 **“시작 속도 최적화”나 “JVM 없는 환경(iOS, 서버리스)”에서만 주로 활용**됩니다.
    

---
##### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
**가상머신(Virtual Machine, VM)**을 사용하면 **하드웨어나 운영체제 위에 추상화된 실행 환경**을 제공하여, 프로그램을 실제 물리 하드웨어 대신 **가상의 환경에서 실행**할 수 있습니다.  
대표적으로 Java의 **JVM**이나 시스템 가상화 기술인 **VMware, VirtualBox** 등이 있습니다.

VM 사용은 **높은 이식성, 격리성**을 제공하지만, **성능 저하와 관리 복잡성** 같은 단점도 있습니다.

---
 **1. VM을 사용함으로써 얻는 장점**

 **(1) 플랫폼 독립성 (이식성)**

- 애플리케이션은 VM 위에서 실행되므로 **하드웨어나 OS에 종속되지 않음**.
    
- 예: Java는 JVM만 설치되어 있으면 Windows, Linux, macOS에서 동일한 `.class` 파일을 실행할 수 있습니다.
    
 **(2) 보안 및 격리성**

- VM은 호스트 OS와 **격리된 실행 환경**을 제공하므로, 애플리케이션 오류나 악성 코드가 호스트 시스템에 직접 영향을 주지 않습니다.
    

 **(3) 관리 용이성**

- VM 이미지를 생성하면 **환경을 그대로 복제, 배포, 백업**할 수 있습니다.
    
- 운영체제 환경을 테스트할 때 매우 유용합니다.
    

 **(4) 호환성 확보**

- 오래된 소프트웨어를 새로운 OS에서 실행하거나, 특정 OS 환경이 필요한 소프트웨어를 VM 위에서 구동할 수 있습니다.
    

 **(5) 리소스 효율적 사용**

- 하이퍼바이저 기반 VM에서는 **하나의 물리 서버 위에서 여러 VM이 동작**해 자원을 효율적으로 사용 가능.
    
- 클라우드 서비스(AWS EC2, GCP Compute Engine 등)의 기반 기술이 바로 VM.
    

---

 **2. VM을 사용할 때의 단점**

 **(1) 성능 저하**

- VM은 **하드웨어를 직접 사용하는 것이 아니라 소프트웨어 계층(가상화 계층)을 거쳐 접근**하므로, 네이티브 실행보다 느립니다.
    
- 예: JVM도 바이트코드를 JIT 컴파일로 변환해야 하므로 네이티브 언어(C/C++)보다 초기 성능이 떨어질 수 있습니다.
    
 **(2) 높은 메모리/리소스 사용량**

- VM은 **게스트 OS + 애플리케이션**을 모두 실행해야 하므로, 호스트 OS 대비 메모리와 CPU 사용량이 큽니다.
    

 **(3) 관리 복잡성**

- VM이 많아지면 OS 업데이트, 보안 패치, 이미지 관리가 복잡해집니다.
    

 **(4) 딜레이(시작 속도)**

- VM 부팅은 물리 서버나 단일 애플리케이션 실행보다 시간이 오래 걸립니다.
    
- JVM도 애플리케이션 실행 시 **클래스 로딩과 바이트코드 해석 과정** 때문에 초기 구동이 느릴 수 있습니다.
    

 **(5) 디버깅 어려움**

- VM 계층 때문에 **호스트와 VM 간의 문제 원인 분석이 어렵거나** 성능 병목을 추적하기 힘들 수 있습니다.
    

---

 **3. VM vs 네이티브 실행의 트레이드오프**

- **VM 장점:** 이식성, 보안, 격리성, 유지보수 용이성.
    
- **VM 단점:** 네이티브보다 **성능(속도, 메모리 효율)**이 떨어질 수 있음.
    

---
 **4. 정리**

> **VM은 "유연성과 이식성"을 제공하지만, "성능과 리소스 사용량"에서 네이티브 실행보다 불리합니다.**  
> 최근에는 성능 저하를 최소화하기 위해 **JIT 컴파일러, GraalVM, 컨테이너(Docker)** 등 VM의 단점을 보완하는 기술들이 함께 사용됩니다.
##### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
정확히 말하면, **JVM과 그 내부에서 실행되는 자바 프로그램은 "부모-자식 프로세스" 관계로 볼 수 없습니다.**  
그 이유는 **JVM 자체가 하나의 프로세스**이며, 자바 애플리케이션(클래스, 메서드 등)은 JVM 프로세스 안에서 **스레드로 동작**하기 때문입니다.

---
 **1. JVM은 하나의 프로세스다**

- 자바 애플리케이션을 실행하면 OS는 `java` 실행 파일을 로드하고, 이를 **하나의 독립된 프로세스**로 실행합니다.
    
- 이후 JVM 프로세스는 **클래스 로딩, 바이트코드 실행(인터프리팅/JIT 컴파일), GC, 스레드 관리** 등의 작업을 수행합니다.
    
- **자바 애플리케이션의 main 메서드 또한 JVM 프로세스 내부의 "스레드(메인 스레드)"로 동작합니다.**
    

---
 **2. 부모-자식 프로세스 관계가 아닌 이유**

- 부모-자식 프로세스 관계는 **OS 레벨에서 fork()나 exec()** 같은 시스템 콜로 새로운 프로세스를 생성할 때 형성됩니다.
    
- JVM에서 실행되는 자바 프로그램은 **별도의 OS 프로세스가 아니라, JVM 프로세스 내부의 실행 로직**에 불과합니다.
    
- 따라서 JVM과 자바 프로그램은 **하나의 프로세스 내에서 동작하는 "런타임 환경과 애플리케이션 코드"** 관계입니다.
    

---
 **3. 예외적 상황**

- 자바 애플리케이션이 `ProcessBuilder`나 `Runtime.exec()`을 통해 **외부 명령어를 실행하면**, 해당 외부 프로그램은 **JVM의 자식 프로세스**로 생성됩니다.
    
    java
    
    복사편집
    
    `Process process = Runtime.getRuntime().exec("ls -al");`
    
    이 경우 `ls` 명령은 JVM의 자식 프로세스가 맞습니다.
    

---
 **4. 올바른 표현**

- **JVM = 프로세스**
    
- **자바 애플리케이션(main, Thread 등) = JVM 프로세스 내부의 스레드**
    
- 부모-자식 프로세스 관계는 JVM과 OS 외부 프로그램 간에만 발생할 수 있습니다.
    

---
 **5. 정리**

> **JVM과 내부에서 실행되는 자바 프로그램은 프로세스-프로세스 관계가 아니라, 프로세스(JVM)-스레드(자바 애플리케이션) 관계입니다.**  
> 다만, 자바 프로그램이 외부 명령을 실행한다면 그 외부 명령은 JVM의 자식 프로세스가 됩니다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
##### 설명:
`final` 키워드는 **자바에서 불변성(immutability) 또는 변경 불가능성을 보장하는 데 사용**됩니다. 상황에 따라 클래스, 메서드, 변수에 붙을 수 있으며, 각각 다른 의미와 장점이 있습니다.

---

**1. `final`의 사용 대상과 의미**

 **(1) 변수에 사용**

- **의미:** 변수의 값을 한 번만 할당할 수 있도록 제한합니다.
    
    - **기본 타입:** 값 자체가 변경 불가.
        
    - **참조 타입:** 객체의 참조 주소가 변경 불가(하지만 객체 내부 상태는 변경될 수 있음).
**(2) 메서드에 사용**

- **의미:** 메서드를 오버라이드(override)할 수 없습니다.
    
- **예시:**
    
```java
class Parent {
    public final void show() {
        System.out.println("Can't override me");
    }
}
class Child extends Parent {
    // @Override
    // public void show() { } // 컴파일 에러

```
 **(3) 클래스에 사용**

- **의미:** 상속할 수 없는 클래스가 됩니다.
    
- **예시:**  
    `java.lang.String`, `java.lang.Math` 클래스는 `final`로 선언되어 상속 불가.
    
 **2. `final` 키워드의 장점**
 **(1) 코드 안정성 확보**

- 변수 값을 실수로 변경하거나 상속/오버라이딩으로 인한 예기치 못한 동작을 방지할 수 있습니다.
    
**(2) 불변 객체(Immutable Object) 구현**

- `final`을 멤버 변수에 적용하고 setter를 제거하면 **스레드 안전(Thread-Safety)** 한 객체를 만들 수 있습니다.
    
- 예: `String` 클래스가 `final`이기 때문에 불변성을 보장하고 멀티스레드 환경에서 안전합니다.
    
**(3) 성능 최적화 (JVM 최적화 힌트)**

- `final` 메서드는 오버라이드가 불가능하므로, **JVM JIT 컴파일러가 인라이닝(inlining)** 최적화를 쉽게 적용할 수 있습니다.
    
- 상속 관계에서 메서드 호출 시 발생하는 **동적 디스패치 비용**을 줄일 수 있습니다.
    
 **(4) 설계 의도 명확화**

- 특정 클래스나 메서드가 확장되거나 변경되지 않기를 원할 때 `final`을 명시적으로 사용하면, 코드의 의도를 분명히 할 수 있습니다.
    

---
3. `final`의 한계**

- 불필요하게 `final`을 남발하면 테스트나 확장성이 떨어질 수 있습니다.  
    (예: 모든 메서드를 `final`로 만들면 상속 기반 구조에 제약 발생)
    
- 참조 타입의 `final`은 객체 내부 상태까지 불변하게 만들지는 않기 때문에, **진정한 불변 객체를 위해서는 별도 설계(Immutable Pattern)** 가 필요합니다.
    

 **정리**

> `final`은 **“변경 불가능성”을 보장하여 안정성과 최적화를 돕는 키워드**입니다.  
> 특히 불변 객체 설계와 성능 최적화에서 중요한 역할을 하며, 코드의 의도를 명확히 전달할 수 있습니다.
##### 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
네, **`final` 키워드는 컴파일 과정에서 일반 변수나 메서드와 다르게 취급됩니다.**  
컴파일러와 JVM은 `final`이 붙은 요소가 **절대 변하지 않는다는 사실을 알고 최적화**할 수 있기 때문입니다.

---
**1. `final` 변수의 컴파일 과정**

- **`final` 상수(`static final`)는 컴파일 타임 상수로 취급**됩니다.
```java
public class Test {
    public static final int CONST = 10;
}

    
```
        
    다른 클래스에서 `Test.CONST`를 참조하면, **컴파일 시 값 `10`으로 대체(inline)** 됩니다.
        
- **`final` 지역 변수나 필드도 컴파일러가 “절대 재할당 불가”라는 사실을 알기 때문에 상수 취급**하며, 인라이닝이나 값 추론(Constant Folding) 같은 최적화가 가능합니다.
    

---
**2. `final` 메서드의 컴파일 과정**

- 메서드에 `final`이 붙으면 **JVM은 동적 디스패치(virtual method table lookup)를 거치지 않고 직접 호출**할 수 있습니다.
    
- 보통 오버라이드 가능한 메서드는 실행 시점에 **가상 메서드 테이블(V-Table)** 을 통해 어떤 구현을 호출할지 결정합니다.
        
 - 하지만 `final` 메서드는 **오버라이드가 불가능하므로 호출 대상이 컴파일 시점에 확정**, 호출 비용을 줄일 수 있습니다.
        
  - JIT 컴파일러가 `final` 메서드를 인라인으로 변환하기가 훨씬 수월합니다.
        

---
**3. `final` 클래스의 컴파일 과정**

- 클래스가 `final`이면 상속이 불가능하기 때문에, **JVM이 메서드 호출 시 “다형성 검사”를 생략**할 수 있습니다.
    
- 예를 들어, `String`은 `final`이기 때문에 `"abc".substring(1)` 호출 시 **항상 `String`의 `substring()` 메서드를 직접 실행**하도록 최적화할 수 있습니다.
    

---
 **4. JIT 컴파일러 관점에서의 최적화**

- 런타임 시 JIT(Just-In-Time) 컴파일러는 `final` 키워드를 확인하고:
    
    - **상수 값 인라이닝** (예: `final int x = 10;` → 직접 10으로 대체)
        
    - **메서드 인라이닝** (함수 호출을 제거하고 코드 삽입)
        
    - **Dead Code 제거** (변하지 않는 값 기반의 코드 최적화)  
        를 적용할 수 있습니다.
        

---
 **정리**

- 컴파일러는 `final` 키워드를 통해 **“변하지 않음”을 보장받아 더 강력한 최적화를 수행**합니다.
    
- 특히 `static final` 상수는 **컴파일 타임에 값이 확정**되어 다른 클래스에서 **직접 값이 삽입(inline)**됩니다.
    
- `final` 메서드는 **가상 메서드 호출 비용을 제거하고 인라이닝 최적화를 가능**하게 합니다.

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
##### 설명
**1. 공통점**

- **인스턴스화 불가:** 둘 다 직접 객체를 생성할 수 없습니다.
- **추상 메서드 포함 가능:** 구현을 강제할 수 있습니다.
- **다형성 제공:** 부모 타입(인터페이스/추상 클래스)으로 자식 객체를 참조할 수 있습니다.
    

---
 **2. 차이점 비교**

|구분|인터페이스 (Interface)|추상 클래스 (Abstract Class)|
|---|---|---|
|**목적**|**기능(행동)의 약속**: “이런 기능을 제공하겠다”는 규격 제공|**공통된 속성과 동작의 공유**: 상속받는 클래스에 **기본 구현** 제공|
|**메서드**|기본적으로 **추상 메서드만 선언 가능** (Java 8 이후 `default`, `static` 메서드 허용)|**추상 메서드 + 일반 메서드(구현 포함)** 모두 가능|
|**필드**|**`public static final` (상수)만 선언 가능**|**인스턴스 변수(상태) 선언 가능**|
|**상속**|**다중 구현 허용** (클래스는 여러 인터페이스를 구현 가능)|**단일 상속만 허용**|
|**접근 제어자**|메서드는 암묵적으로 `public abstract` (default/static 제외)|`public`, `protected`, `private` 자유롭게 사용 가능|
|**생성자**|없음|생성자 가질 수 있음|
|**상속 키워드**|`implements` 사용|`extends` 사용|

---
 **3. 사용 예시**

 **인터페이스 예시**

```java
interface Flyable {
    void fly();  // 추상 메서드
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

```

- **의미:** “날 수 있다”라는 기능을 약속.
    
- `Flyable`을 구현하는 모든 클래스는 반드시 `fly()`를 구현해야 합니다.
    

추상 클래스 예시**
```java
abstract class Animal {
    String name;

    abstract void makeSound();  // 추상 메서드

    void eat() {                // 일반 메서드
        System.out.println(name + " is eating");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

```
- **의미:** `Animal`은 공통 속성(`name`)과 공통 동작(`eat()`)을 제공하고, `makeSound()`는 서브클래스가 구현하도록 강제합니다.
    

---
**4. 언제 사용해야 할까?**

- **인터페이스**:
    
    - **“~할 수 있다”**(Can do) 같은 **기능의 명세**를 정의할 때.
        
    - 서로 다른 클래스들이 동일한 행동을 보장해야 할 때 (예: `Comparable`, `Runnable`).
        
    - 다중 상속(여러 동작 인터페이스 구현)이 필요할 때.
        
- **추상 클래스**:
    
    - **공통된 속성(필드)과 기본 동작(메서드)을 공유**해야 할 때.
        
    - 클래스 계층구조에서 **코드 재사용**이 필요한 경우.
        

---

**5. Java 8 이후의 변화**

- 인터페이스에서도 `default` 메서드를 정의하여 **기본 구현을 제공**할 수 있게 되었고,  
    추상 클래스와의 차이가 줄어들었지만 **“상태(필드)”를 가질 수 없다는 점**에서 여전히 차이가 존재합니다.
    

---
 **정리**

> **인터페이스**는 **“무엇을 할 수 있는가(기능의 약속)”**,  
> **추상 클래스**는 **“무엇을 가지고 있고, 기본적으로 어떻게 동작하는가(공통 구현)”**를 제공하는 데 초점을 둡니다.
##### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
그 이유는 **언어 설계 철학과 다중 상속의 문제점**에서 비롯됩니다.

 **1. 클래스 다중 상속의 문제점**

클래스는 **상태(필드)**와 **행동(메서드 구현)**을 모두 포함할 수 있기 때문에, 다중 상속 시 **모호성(Ambiguity)** 문제가 발생합니다.

 **대표적인 다이아몬드 문제 (Diamond Problem)**
```java
class A {
    void hello() { System.out.println("Hello from A"); }
}

class B extends A {
    void hello() { System.out.println("Hello from B"); }
}

class C extends A {
    void hello() { System.out.println("Hello from C"); }
}

// 다중 상속이 가능하다고 가정
class D extends B, C {
    // D.hello() 호출 시, B와 C 중 어느 hello()를 써야 할까?
}

```

- `D`가 `B`와 `C`를 동시에 상속하면 **같은 메서드 시그니처를 가진 `hello()`가 2개 생기므로 호출 우선순위가 모호**해집니다.
    
- 이 모호성을 해결하려면 언어 차원에서 복잡한 규칙(예: C++의 가상 상속)을 도입해야 하는데, **자바는 단순성과 명확성을 위해 클래스 다중 상속을 금지**했습니다.
    

---
**2. 인터페이스는 상태를 가지지 않기 때문**

- 인터페이스는 **필드를 가질 수 없고(상수 `public static final`만 가능)**, 기본적으로 **메서드의 구현을 포함하지 않습니다**(Java 8 이전).
    
- 즉, **상태 충돌 문제**가 발생하지 않습니다.
    
- 다중 구현을 하더라도 **충돌하는 데이터 필드나 상속 체계 모호성**이 없기 때문에 안전하게 허용됩니다.
    

---

**3. Java 8 이후 default 메서드가 생겼는데 왜 여전히 다중 구현이 가능할까?**

- Java 8부터 인터페이스에 `default` 메서드가 생기면서 메서드 구현이 가능해졌지만,  
    **메서드 충돌이 발생하면 반드시 구현 클래스에서 오버라이딩(재정의)하여 해결해야 한다는 규칙**이 추가되었습니다.
    
```java
interface A { default void hello() { System.out.println("A"); } }
interface B { default void hello() { System.out.println("B"); } }

class C implements A, B {
    @Override
    public void hello() {  // 충돌 해결
        A.super.hello();   // 명시적으로 A의 hello 호출
    }
}

    
```
    
    이렇게 **명시적으로 어느 인터페이스의 메서드를 사용할지 지정**할 수 있어 충돌 문제가 해결됩니다.
    

---
 **4. 결론**

- **클래스:** 상태와 구현을 포함하므로 다중 상속 시 모호성과 충돌 문제가 발생 → **단일 상속만 허용.**
    
- **인터페이스:** 상태를 가지지 않고 **행동(계약)만 정의**하기 때문에 충돌 위험이 없음 → **다중 구현 가능.**
    
- **Java 8 이후에도 다중 구현 충돌은 `super` 키워드로 명시적으로 해결하도록 규칙화** → 안전하게 다중 인터페이스 구현 유지 가능.

### 4. 리플렉션에 대해 설명해 주세요.
##### 설명
**리플렉션(Reflection)**은 **런타임(runtime)에 클래스나 객체의 메타데이터(클래스 정보, 메서드, 필드 등)를 동적으로 조사하고 조작할 수 있는 기능**을 말합니다.  
즉, **코드가 실행 중에 자기 자신을 들여다보고 수정할 수 있게 해주는 메커니즘**입니다.

---
**1. 리플렉션의 특징**

- **컴파일 타임이 아닌 런타임에 클래스 정보를 다룸.**
    
- 객체의 **클래스 이름, 메서드 목록, 필드, 생성자** 등에 접근 가능.
    
- 접근 제어자(`private`, `protected`)를 무시하고 필드/메서드에 접근할 수 있음 (`setAccessible(true)`).
    
- 동적으로 객체를 생성하거나 메서드를 호출할 수 있음.
    

---
 **2. 리플렉션의 주요 사용 예**
```java
Class<?> clazz = Class.forName("com.example.MyClass");  // 클래스 로드

// 객체 생성
Object obj = clazz.getDeclaredConstructor().newInstance();

// 메서드 호출
Method method = clazz.getDeclaredMethod("sayHello");
method.invoke(obj);

// 필드 접근
Field field = clazz.getDeclaredField("name");
field.setAccessible(true);
field.set(obj, "Reflection Test");

```

---
3. 리플렉션의 장점**
	1. **유연한 동적 처리**
	    
	    - 실행 시점에 클래스 이름만 알고 있어도 동작 가능.
	        
	    - 예: JDBC 드라이버 로딩(`Class.forName("com.mysql.jdbc.Driver")`).
	        
	2. **프레임워크와 라이브러리 구현에 필수적**
	    
	    - 스프링(Spring)의 DI(의존성 주입), JPA 엔티티 매핑, Jackson JSON 직렬화 등 대부분의 자바 프레임워크는 리플렉션을 사용.
	        
	3. **일반 코드로는 접근 불가능한 정보 활용 가능**
	    
	    - `private` 필드나 메서드를 런타임에 강제로 접근 가능.
        

---
**4. 리플렉션의 단점**

1. **성능 저하**
    
    - 메서드 호출 시 직접 호출보다 **약 20배 이상 느릴 수 있음**(런타임 검사 및 메타데이터 탐색 비용).
        
2. **컴파일 타임 타입 체크 불가**
    
    - 리플렉션을 잘못 사용하면 런타임에 `NoSuchMethodException`, `IllegalAccessException` 등 에러가 발생할 수 있음.
        
3. **캡슐화 위반**
    
    - `private` 멤버에 강제 접근할 수 있어 객체지향 설계를 깨뜨릴 수 있음.
        

---
5. 리플렉션이 많이 쓰이는 곳**

- **프레임워크/라이브러리 내부**  
    (Spring, Hibernate, Jackson, JUnit)  
    → 컴파일 시점에 타입을 몰라도 객체 생성, 메서드 실행, 의존성 주입 등을 해야 하므로 필수적.
    
- **어노테이션 처리**  
    예: `@Autowired`, `@Entity` 같은 어노테이션의 메타데이터를 리플렉션으로 읽어 동작.
    
- **런타임 플러그인/모듈 로딩**  
    → 특정 클래스나 메서드를 동적으로 로딩하고 실행할 때 사용.
    

---
**6. 결론**

> **리플렉션은 런타임에 프로그램 구조를 조작할 수 있는 강력한 도구이지만, 성능 저하와 캡슐화 파괴 가능성이 있으므로 필요한 경우에만 신중히 사용하는 것이 권장됩니다.**
##### 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
맞습니다. **리플렉션은 보안적인 문제를 일으킬 가능성이 있습니다.**  
리플렉션은 `private` 필드나 메서드에도 접근할 수 있기 때문에, 원래 의도한 **캡슐화(encapsulation)**를 깨뜨리고, 잘못 사용되면 **보안 취약점**으로 이어질 수 있습니다.

---
1. 리플렉션의 보안 문제 사례**

2. **`private` 필드 접근**
```java
Field field = SomeClass.class.getDeclaredField("password");
field.setAccessible(true);  // 접근 제한 해제
String pwd = (String) field.get(obj);

    
```
    원래 외부에서 접근할 수 없는 비밀번호 필드에 접근할 수 있습니다.
    
3. **불법적인 메서드 호출**
    
    - 접근 불가한 메서드(예: 관리자 전용 메서드)를 `invoke()`로 호출 가능.
        
4. **클래스 로딩 시 악성 코드 주입**
    
    - `Class.forName("com.hacker.MaliciousClass")` 로 동적 로딩 가능.  
        만약 외부 입력을 그대로 클래스명으로 사용할 경우, 공격자가 의도한 클래스가 실행될 수 있습니다.
        
5. **시스템 클래스 변조**
    
    - `java.lang.reflect` 패키지를 이용하면 JDK 내부 클래스나 필드를 조작할 수 있어 예기치 못한 동작을 유발할 수 있습니다.
        

---
2. 보안 문제를 방지하는 방법**
(1) SecurityManager (자바 17 이전)**
하지만 자바 17부터 `SecurityManager`는 **Deprecated** 되었으므로 대체 수단이 필요합니다.
    

**(2) 모듈 시스템 (Java 9+)**

- Java 9부터 도입된 **모듈 시스템(Jigsaw)** 을 사용하면 **모듈 간 리플렉션 접근을 제한**할 수 있습니다.
```java
module my.module {
    exports com.myapp;
    opens com.myapp.internal to specific.module; // 제한적 리플렉션 허용
}

```
**(3) 클래스 로딩 시 화이트리스트 검증**

- `Class.forName()` 등을 사용할 때 **외부 입력값을 그대로 사용하지 않고**, 허용된 클래스 목록(화이트리스트)을 확인해야 합니다.
    
(4) `setAccessible(true)` 최소화**

- 꼭 필요한 경우에만 사용하고, 라이브러리에서 남용하지 않도록 주의해야 합니다.
    
- Java 9 이상에서는 `setAccessible(true)` 호출 시 **권한 제한 경고**가 발생하며, `--illegal-access=deny` 옵션으로 차단할 수 있습니다.
    
 **(5) 보안 정책 파일 (policy file) 설정**

- 권한이 필요한 코드 영역에 대해 `ReflectPermission`을 제한하는 보안 정책을 설정할 수 있습니다.
    
 **3. 실제 보안적 관점에서의 판단**

- **일반 애플리케이션 코드에서 리플렉션을 남용하는 것은 권장되지 않습니다.**
    
- 하지만 **프레임워크나 라이브러리 수준에서는 필수적**입니다. (예: 스프링 DI, Hibernate 엔티티 매핑)
    
- **보안적으로 민감한 객체(암호키, 인증정보 등)는 리플렉션 접근 방지를 위한 설계(예: SecurityManager 대체 수단, final 클래스, 모듈화)와 정책이 필요**합니다.
    
 **4. 결론**

> 리플렉션은 **강력하지만 위험할 수 있는 도구**입니다.  
> 보안적으로 민감한 시스템에서는 **모듈화, 접근 제어, 화이트리스트 검증, 권한 정책** 등을 조합하여 사용을 제한해야 합니다.
##### 리플렉션을 언제 활용할 수 있을까요?
리플렉션(Reflection)은 **일반적인 애플리케이션 코드에서 매번 사용하는 도구는 아니지만**, **동적인 동작**이나 **프레임워크/라이브러리 개발** 시 매우 유용하게 활용됩니다.

다음은 **리플렉션을 사용하기 적합한 주요 상황**입니다.

---
**1. 컴파일 시점에 타입을 알 수 없는 경우**

- 런타임에 클래스나 메서드 이름이 결정되는 경우 유용합니다.
    
```java
// 클래스 이름을 문자열로만 알고 있는 상황
Class<?> clazz = Class.forName("com.example.MyClass");
Object obj = clazz.getDeclaredConstructor().newInstance();
 
```
- **활용 예:**
    - 플러그인 시스템 (외부에서 로딩되는 모듈 실행)
    - 런타임에 입력받은 클래스명/메서드명을 기반으로 동적 호출
        

---
 **2. 프레임워크 및 라이브러리 내부**

- **Spring**, **Hibernate**, **JUnit**, **Jackson** 등 수많은 자바 프레임워크는 리플렉션을 핵심적으로 활용합니다.
    
    - **Spring DI (의존성 주입)**:  
        `@Autowired` 필드를 리플렉션으로 찾아서 객체를 주입.
        
    - **Hibernate/JPA**:  
        엔티티 클래스의 필드 정보를 리플렉션으로 읽어 DB 컬럼과 매핑.
        
    - **JUnit**:  
        테스트 메서드(`@Test`)를 런타임에 찾아 자동 실행.
        
    - **Jackson/Gson**:  
        클래스 필드/Getter를 리플렉션으로 찾아 JSON 직렬화/역직렬화.
        

---
 **3. 어노테이션(Annotation) 기반 처리**

- 어노테이션 정보를 런타임에 읽어 동작을 제어할 때 사용됩니다.
    
```java
Method method = clazz.getDeclaredMethod("myMethod");
if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
    // 어노테이션이 붙은 메서드만 실행
    method.invoke(obj);
}

```

---
4. 직렬화/역직렬화 및 매핑**

- **객체 → JSON** 또는 **JSON → 객체** 변환 시 리플렉션으로 필드를 탐색하고 값 할당.
    
- **ORM(Object Relational Mapping)** 프레임워크가 DB 테이블과 클래스 필드를 매핑할 때 사용.
    

---
**5. 디버깅, 로깅, 테스트**

- 테스트 코드에서 **비공개 필드(`private`)에 접근**해 상태를 확인할 때.
    
- 런타임에 객체의 구조를 확인하여 **자동 로깅**이나 **디버깅 도구**를 만들 때.
    

---
**6. 유연한 API 설계**

- 클래스 구조가 변경되더라도, 리플렉션을 통해 **필드명/메서드명을 문자열로 참조**하면 코드 수정 없이 동작할 수 있습니다.
    
    - 예: **스프링 BeanFactory**가 Bean을 문자열 이름으로 찾아 인스턴스화.
        

 **정리**

리플렉션은 **정적 타입 시스템으로는 불가능한 동적 동작**을 가능하게 해주는 도구입니다.  
특히 **프레임워크, ORM, 어노테이션 기반 라이브러리**에서 핵심 역할을 하며, **런타임에 타입을 모르는 상황에서 객체를 생성하거나 메서드를 호출할 때** 유용합니다.
### 5. static class와 static method를 비교해 주세요.
##### 설명
`static class`와 `static method`는 **static 키워드를 클래스와 메서드에 적용한 것**이지만, 의미와 용도가 완전히 다릅니다.

---
1. static method (정적 메서드)**
**특징**

- **클래스 레벨에서 동작**하며, 인스턴스 생성 없이 호출 가능.
    
- `this` 키워드를 사용할 수 없음 (인스턴스 변수 접근 불가).
    
- 클래스 로딩 시 메모리에 올라가며, 공유 자원 역할을 함.
    
- **객체 상태와 관계없는 기능(유틸리티 메서드)**에 적합.
    
**예시**

```java
class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }
}

int sum = MathUtil.add(5, 10);  // 객체 생성 없이 호출

```
 **2. static class (정적 클래스)**

자바에서 **클래스 자체에 `static`을 붙일 수는 없습니다.**  
다만, **“static 중첩 클래스(Static Nested Class)”**를 만들 수 있습니다.

 **특징**

- 외부 클래스의 인스턴스에 **종속되지 않는 중첩 클래스**를 의미.
    
- 외부 클래스의 `static` 멤버만 접근 가능 (`non-static` 멤버 접근 불가).
    
- **독립적인 클래스처럼 사용 가능**하여, 외부 클래스 객체 없이 인스턴스화할 수 있습니다.
    
 **예시**

```java
class Outer {
    static class Inner {  // Static Nested Class
        void print() {
            System.out.println("Static nested class");
        }
    }
}

Outer.Inner inner = new Outer.Inner();  // Outer 객체 없이 생성 가능

```

---
**3. 비교 요약**

|구분|**static method**|**static class (중첩 클래스)**|
|---|---|---|
|**적용 대상**|메서드|중첩 클래스(Inner Class)|
|**호출/생성**|클래스 이름으로 직접 호출 가능 (`ClassName.method()`)|외부 클래스 객체 없이 `new Outer.Inner()` 로 생성 가능|
|**목적**|객체 상태와 무관한 **공통 동작 제공**|외부 클래스와 **논리적으로 묶인 클래스**를 독립적으로 사용|
|**this 사용**|불가능|자기 자신에 대한 `this`는 가능|
|**메모리 관리**|클래스 로딩 시 메서드가 메모리에 올라감|외부 클래스 인스턴스와 관계없이 별도로 로딩|

---
 **4. 결론**

- **`static method`는 클래스에 귀속된 함수**이며, 주로 **유틸리티성 메서드**에서 사용됩니다.
    
- **`static class`는 독립적으로 사용할 수 있는 중첩 클래스**로, 외부 클래스의 인스턴스와 무관하게 사용하고자 할 때 유용합니다.

##### static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
`static` 키워드는 **클래스 레벨의 멤버(변수, 메서드, 내부 클래스)를 정의**할 때 사용됩니다.  
이는 **인스턴스와 독립적으로 동작**하게 만들며, **메모리 관리나 호출 방식에서 장점**을 제공합니다. 하지만 동시에 몇 가지 **제약**도 따릅니다.

---
1. static의 주요 이점**
**(1) 인스턴스 생성 없이 접근 가능**

- `static` 멤버는 클래스 로딩 시 메모리에 올라가므로 **객체를 생성하지 않아도 바로 접근**할 수 있습니다.
    
 **(2) 공용 데이터(Shared Data) 관리**

- 모든 인스턴스가 **같은 static 변수**를 공유하므로 **공용 상태를 유지**할 수 있습니다.
    
    `class Counter {     static int count = 0;     Counter() { count++; } } // 모든 Counter 객체가 count를 공유`
    

**(3) 유틸리티 클래스 구현에 유용**

- 상태가 필요 없는 메서드를 묶어서 제공할 때 적합합니다.
    
- 예: `Math`, `Collections`, `Arrays` 클래스.
    
 **(4) 메모리 절약**

- **인스턴스마다 복제되지 않고, 클래스당 하나만 로딩**되므로 메모리 사용량을 줄일 수 있습니다.
    

---
 **2. static의 주요 제약**
 **(1) 인스턴스 변수나 메서드에 접근 불가**

- `static` 메서드는 **객체(인스턴스)의 상태를 알 수 없으므로** `this` 키워드를 사용할 수 없습니다.
    
 **(2) 오버라이딩(Overriding) 불가**

- `static` 메서드는 클래스 레벨에 속하므로 **상속 시 재정의(Overriding)가 불가능**합니다.
    
    - 단, **"메서드 숨김(Method Hiding)"** 형태로 같은 시그니처의 static 메서드를 선언할 수는 있습니다.
        
 **(3) 다형성(Polymorphism) 활용 불가**

- 인스턴스 메서드는 런타임에 동적 바인딩되지만, `static` 메서드는 **컴파일 시점에 정적으로 바인딩**됩니다.
    
 **(4) 가비지 컬렉션(GC) 대상 아님**

- 클래스가 언로드될 때까지 메모리에 상주하므로, 메모리 누수가 발생할 가능성이 있습니다(특히 큰 객체를 static 변수로 유지할 때).
    
 **(5) 동시성 문제**

- `static` 변수는 모든 스레드가 공유하므로, **멀티스레드 환경에서 동기화 이슈**가 발생할 수 있습니다. (e.g., `static` 변수를 갱신하는 경우 `synchronized` 필요)
    

---
 **3. static을 사용하면 좋은 경우**

- **상태를 공유해야 하는 경우:** 예를 들어, 모든 객체가 공유하는 카운터 변수.
    
- **유틸리티성 메서드:** 객체 상태와 무관한 단순 기능 제공 (e.g., `Math`, `Arrays`).
    
- **싱글톤 패턴:** `private static` 인스턴스를 사용하여 전역 접근을 제공.
    

---
 **4. static을 남용하면 생길 문제**

- 객체지향적인 설계가 깨질 수 있음 (모든 상태가 전역화).
    
- 테스트 및 확장성에 불리.
    
- 멀티스레드 환경에서 예기치 못한 동기화 문제 발생 가능.
    

---
 **정리**

> **static의 장점:** 객체 생성 없이 접근 가능, 메모리 절약, 공용 상태 관리, 유틸리티성 메서드 구현.  
> **static의 제약:** 인스턴스 접근 불가, 오버라이딩 불가, 다형성 제한, GC 대상 아님, 동시성 문제.
##### 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
`static` 키워드는 **컴파일러와 JVM이 멤버를 클래스 단위로 관리**하도록 지시합니다.  
즉, **객체(인스턴스)와 분리된 메모리 공간에 로드되고 공유**되며, 호출 및 접근 방식에서도 **컴파일 시점부터 정적으로 처리(static binding)** 됩니다.

---
 **1. 컴파일 시 static 처리 방식**

 **(1) static 변수**

- 컴파일러는 `static` 변수를 **클래스 소속 변수(전역 변수와 유사)**로 인식합니다.
    
- `.class` 파일의 **메서드 영역(Method Area)**에 로딩되며, **클래스가 처음 로드될 때 1회만 메모리에 할당**됩니다.
    
- 각 인스턴스는 `static` 변수를 **공유**하며, `this.variable` 대신 **`ClassName.variable` 형태로 접근하도록 컴파일됩니다.**
    
- **바이트코드 예시 (javap -c)**
    
```java
class Test {
    static int count = 0;
    void inc() { count++; }
}

```
    
    디컴파일 시 `Test.count`로 직접 접근하는 코드가 생성됩니다.
    

---
 **(2) static 메서드**

- 컴파일러는 `static` 메서드를 **클래스 소속 함수로 처리**하고, **인스턴스 메서드와 달리 `this` 참조를 인자로 전달하지 않습니다.**
    
- 호출 시 **정적 바인딩(static binding)** 을 적용합니다.
    
    - 인스턴스 메서드는 **가상 메서드 테이블(v-table)**을 통해 런타임에 호출 대상을 결정하지만, `static` 메서드는 **컴파일 시점에 호출 메서드가 확정**됩니다.
        
- 예시:
    
    java
    
    복사편집
    
    `Test.print(); // 컴파일 시점에 직접 호출로 치환`
    

---
 **(3) static 초기화 블록**

- `static { ... }` 블록은 **클래스 로딩 시점(클래스가 처음 참조될 때)**에 단 한 번 실행됩니다.
    
- 컴파일 시 `.class` 파일의 `<clinit>` (Class Initializer) 메서드로 변환됩니다.
    
- 예시:
    
    java
    
    복사편집
    
    `class InitExample {     static int x;     static { x = 100; } }`
    
    디컴파일 시 `<clinit>` 메서드가 생성되어 `x` 값이 설정됩니다.
    

---

 **2. JVM 실행 시 static 처리**

1. **클래스 로더(ClassLoader)가 클래스 로딩**
    
    - `Test.class`가 처음 참조되면 JVM은 클래스 메타데이터와 static 멤버를 **메서드 영역(Method Area)**에 적재.
        
2. **static 변수 초기화 및 static 블록 실행**
    
    - 클래스가 로드될 때 **단 한 번** 수행됩니다.
        
3. **호출 시 클래스 이름으로 직접 접근**
    
    - 객체 인스턴스와 무관하게 `Test.print()`로 바로 실행.
        

---
 **3. static이 컴파일 시 주는 이점**

- **호출 최적화:**  
    `static` 메서드는 **다형성(virtual dispatch)** 검사를 거치지 않으므로 호출 비용이 적습니다.
    
- **메모리 절약:**  
    인스턴스마다 변수를 복사하지 않고, 하나의 static 메모리를 공유.
    
- **상수 처리:**  
    `static final` 상수는 **컴파일 타임 상수로 인라인 처리**되어 실행 속도가 빨라집니다.
    

---
 **4. 제약점 (컴파일 시 관점)**

- `static` 메서드는 **객체의 인스턴스 변수와 this 참조에 접근 불가** → 컴파일러가 이를 엄격히 체크.
    
- 오버라이딩 불가 → **컴파일 시점부터 메서드 바인딩 확정**.
    

---
 **정리**

> **컴파일러는 `static` 멤버를 객체와 독립된 “클래스 레벨 리소스”로 취급하고, 호출도 컴파일 타임에 정적으로 결정합니다.**  
> 실행 시 JVM은 해당 멤버를 **메서드 영역에 적재**하여 모든 인스턴스가 공유하도록 처리합니다.

### 6. Java의 Exception에 대해 설명해 주세요.
##### 설명
Java에서 **Exception(예외)**은 프로그램 실행 중 발생할 수 있는 **비정상적 상황이나 오류를 객체로 표현한 것**입니다.  
자바는 예외를 체계적으로 다루기 위해 **예외 처리(Exception Handling) 메커니즘**을 제공합니다.

---
1. Exception의 개념**

- 예외는 `Throwable` 클래스의 하위 클래스 객체로 표현됩니다.
    
- 예외가 발생하면 **JVM은 해당 예외를 던지고(`throw`)**, 이를 처리할 수 있는 **`catch` 블록을 찾습니다.**
    
- 예외가 처리되지 않으면 프로그램은 비정상 종료됩니다.
    

---
 **2. Exception 계층 구조**
```java
java.lang.Object
  └─ java.lang.Throwable
       ├─ java.lang.Error        // 시스템 레벨 오류
       └─ java.lang.Exception    // 애플리케이션 레벨 예외
            └─ java.lang.RuntimeException

```
 **(1) Error**

- JVM이나 시스템 레벨에서 발생하는 심각한 오류.
    
- 예: `OutOfMemoryError`, `StackOverflowError`.
    
- **애플리케이션에서 복구 불가능**하므로 일반적으로 `catch`하지 않습니다.
    

 **(2) Exception**

- 애플리케이션 실행 중 발생할 수 있는 예외 상황.
    
- 개발자가 적절히 처리할 수 있습니다.
    
    **Checked Exception**
    
    - **컴파일 시점**에 반드시 처리(try-catch 또는 throws)해야 하는 예외.
        
    - 예: `IOException`, `SQLException`, `ClassNotFoundException`.
        
    
    #### **Unchecked Exception (RuntimeException)**
    
    - **런타임 시점**에 발생하며, 명시적인 예외 처리를 강제하지 않음.
    - 예: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`.
        

 **3. Exception 처리 방법**

 **(1) try-catch-finally**

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
} finally {
    System.out.println("항상 실행되는 블록");
}

```

- `try`: 예외 발생 가능 코드.
    
- `catch`: 특정 예외를 잡아서 처리.
    
- `finally`: 예외 발생 여부와 관계없이 항상 실행 (자원 해제 등).
    
 **(2) throws**

- 메서드에서 예외를 직접 처리하지 않고 **호출한 쪽으로 던짐**.
    
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
}

```
 **(3) throw**

- 명시적으로 예외 객체를 생성하여 던짐.
    
```java
	if (value < 0) {
    throw new IllegalArgumentException("음수는 허용되지 않습니다.");
}

```

---
 **4. 사용자 정의 예외**

개발자는 `Exception` 또는 `RuntimeException`을 상속받아 사용자 정의 예외를 만들 수 있습니다.

```java
class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}

```
---
 **5. Exception 처리의 장점**

- 예외를 **객체화**하여 **에러 정보(메시지, 스택 트레이스 등)를 구조적으로 제공**.
    
- 프로그램의 **안정성과 가독성**을 높이고, 비정상 종료를 방지.
    
- **예외 전파(throws)**를 통해 책임을 호출자에 위임 가능.
    

---
 **6. 주의할 점**

- 불필요하게 광범위한 예외(`catch Exception`)를 잡는 것은 디버깅을 어렵게 할 수 있음.
    
- Checked Exception은 코드 가독성을 떨어뜨릴 수 있어, 최근에는 **RuntimeException을 활용**하는 경우가 많음 (Spring, JPA도 이 접근 방식을 채택).
    
 **정리**

> **Exception은 프로그램 실행 중 발생하는 오류를 처리하기 위한 객체화된 메커니즘**으로,  
> Checked/Unchecked로 나뉘며, `try-catch-finally`와 `throws`를 통해 유연하게 처리할 수 있습니다.
##### 예외처리를 하는 세 방법에 대해 설명해 주세요.
**1. `try-catch-finally`로 처리 (직접 처리)**
 **개념**

- 예외가 발생할 수 있는 코드를 `try` 블록에 넣고, 예외 발생 시 `catch` 블록에서 해당 예외를 처리합니다.
    
- `finally` 블록은 예외 발생 여부와 관계없이 **항상 실행**됩니다. (주로 자원 해제에 사용)
 **특징**

- 예외를 **직접 잡아서 처리**할 수 있어 프로그램이 비정상 종료되지 않음.
    
- `finally` 블록은 자원 해제, 연결 종료, 로그 기록 등에 사용됩니다.
    

---
 **2. `throws`로 던지기 (호출자에게 예외 전파)**
 **개념**

- 메서드에서 발생한 예외를 **직접 처리하지 않고, 호출한 메서드에 예외를 던짐**.
    
- 메서드 선언부에 `throws 예외클래스명`을 명시해야 합니다.
    
 **예시**
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");  // IOException 가능
}

public static void main(String[] args) {
    try {
        readFile();  // 호출한 쪽에서 처리
    } catch (IOException e) {
        e.printStackTrace();
    }
}

```
 **특징**

- **예외 처리를 상위 호출자에게 위임**할 수 있어 메서드 자체가 더 단순해짐.
    
- Checked Exception은 `throws`로 반드시 명시하거나 `try-catch`로 처리해야 컴파일이 가능.
    

 **3. `throw`로 명시적 예외 발생시키기**

 **개념**

- 코드에서 직접 예외 객체를 생성해 **강제로 예외를 발생시킴**.
    
- 주로 **입력값 검증**이나 **비정상 상태**를 알릴 때 사용.
    
 **예시**

```java
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");
    }
    this.age = age;
}

```
**특징**

- 원하는 시점에서 예외를 발생시켜 **명확하게 에러 상황을 제어**할 수 있습니다.
    
- `throw`로 던진 예외는 **try-catch** 또는 **throws**로 반드시 처리해야 합니다.
    

---
 **정리**

1. **`try-catch-finally`**: 예외를 **직접 처리**한다.
    
2. **`throws`**: 예외를 **호출자에게 전달**한다.
    
3. **`throw`**: **명시적으로 예외를 발생**시킨다.
##### CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
Java의 예외(Exception)는 크게 **Checked Exception**과 **Unchecked Exception**으로 나뉘며, 이 둘의 차이는 **컴파일 시점에 예외 처리를 강제하는지 여부**와 **발생하는 상황**에 있습니다.

---
 **1. Checked Exception**

- **컴파일 타임에서 예외 처리(`try-catch` 또는 `throws`)가 강제되는 예외.**
    
- 발생 가능성이 있는 예외를 **개발자가 명시적으로 처리해야 한다**는 것이 특징.
    
- 주로 **외부 자원(I/O, 네트워크, DB 등)**과 관련된 상황에서 발생.
    
- `Exception` 클래스를 상속하지만 `RuntimeException`을 상속하지 않는 예외들이 이에 해당.
    
 **예시**

```java
public void readFile() throws IOException {
    FileReader reader = new FileReader("file.txt"); // IOException 가능
}

```
 **대표 예외**

- `IOException`
    
- `SQLException`
    
- `ClassNotFoundException`
    
- `FileNotFoundException`
    

---
 **2. Unchecked Exception**

- **컴파일 시점에 예외 처리를 강제하지 않는 예외.**
    
- 주로 **프로그래밍 오류(로직 에러)**로 인해 발생하는 경우가 많습니다.
    
- `RuntimeException`을 상속하는 예외들이 이에 해당.
    
- 개발자가 원하면 `try-catch`로 처리할 수 있지만, **필수는 아님**.
    
 **예시**

java

복사편집

`int[] arr = {1, 2, 3}; System.out.println(arr[5]);  // ArrayIndexOutOfBoundsException (Unchecked)`

- 이 예외는 **개발자가 코드 로직을 잘못 작성했기 때문에** 미리 처리하도록 강제하지 않습니다.
    
 **대표 예외**

- `NullPointerException`
    
- `ArrayIndexOutOfBoundsException`
    
- `IllegalArgumentException`
    
- `ArithmeticException`
    

---
 **3. 주요 차이점 정리**

|구분|**Checked Exception**|**Unchecked Exception**|
|---|---|---|
|**상속 관계**|`Exception` (단, `RuntimeException` 제외)|`RuntimeException` 및 하위 클래스|
|**컴파일 시점 처리**|반드시 처리 필요 (`try-catch` 또는 `throws`)|강제되지 않음|
|**발생 원인**|외부 환경 요인 (파일, 네트워크 등)|코드 로직 오류|
|**예시**|`IOException`, `SQLException`|`NullPointerException`, `ArithmeticException`|

---
 **4. 실무적 관점**

- **Checked Exception**: 외부 환경에 의존하는 부분(파일 읽기/쓰기, DB 연결 등)에 주로 사용.  
    _예:_ `Spring`의 `DataAccessException`은 RuntimeException으로 래핑하여 예외 처리를 단순화.
    
- **Unchecked Exception**: 프로그래머 실수로 발생하는 예외에 주로 사용. 보통 **코드 수정으로 해결**.
    

---
 **5. 정리**

> **Checked Exception**은 *"발생 가능성을 미리 대비하라"*는 의미로 컴파일러가 강제합니다.  
> **Unchecked Exception**은 *"로직 버그이므로 코드로 해결하라"*는 의미로, 강제하지 않습니다.
##### 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외 처리는 **정상적인 흐름의 코드보다 성능에 더 많은 비용이 발생**합니다.  
하지만 **예외 발생 자체보다, 예외가 실제로 던져지고(Stack Trace 생성) 처리되는 과정이 느린 것**이 주요 원인입니다.

---
 **1. 예외 처리가 성능에 영향을 미치는 이유**

1. **스택 트레이스 생성 비용**
    
    - 예외가 발생하면 JVM은 현재 스레드의 호출 스택을 추적하여 `Throwable.fillInStackTrace()`를 호출합니다.
        
    - 이 과정에서 스택 프레임 정보를 캡처해야 하므로 **상당한 오버헤드**가 발생합니다.
        
2. **정상 흐름에서 예외를 남용할 경우**
    
    - 예외를 **제어 흐름(Control Flow)으로 사용하면 성능 저하가 큽니다.**  
        (예: 조건문으로 체크할 수 있는 상황을 `try-catch`로 해결하려는 경우)
        
3. **캐치 후 다시 던지는 예외**
    
    - `catch` 블록에서 처리하지 않고 다시 `throw`하면 추가적인 스택 트레이스 생성이 이루어집니다.
        

---
 **2. 어느 정도 느린가?**

- **일반 조건문 검사(`if`)**와 비교하면 **예외 발생은 수십~수백 배 느릴 수 있습니다.**
    
- 예를 들어, 예외를 1만 번 던지면 **수 밀리초에서 수십 밀리초 단위의 지연**이 발생할 수 있습니다.
    
- 하지만 **예외가 발생하지 않는 `try-catch` 자체는 거의 성능 영향을 주지 않습니다.**  
    (즉, "예외가 발생하는 순간"에만 성능 비용이 큼)
    

---
 **3. 성능 부하를 줄이는 방법**

 **(1) 예외를 로직 제어에 사용하지 않는다**

- **잘못된 방식:**
    
    java
    
    복사편집
    
    `try {     int value = Integer.parseInt("abc");  // NumberFormatException 발생 } catch (NumberFormatException e) {     // 예외로 흐름 제어 (비효율적) }`
    
- **개선된 방식:**
    
    java
    
    복사편집
    
    `if (isNumeric(str)) {  // 조건 체크     int value = Integer.parseInt(str); }`
    
 **(2) 예외는 “예외적인 상황”에서만 사용**

- 정상적인 흐름에서는 조건문, Optional, Validation 등으로 사전 체크.
    

 **(3) 스택 트레이스 생성을 줄이기**

- 커스텀 예외 클래스에서 `fillInStackTrace()`를 오버라이딩해 **스택 트레이스 생성 비용을 줄일 수 있습니다.**
    
    java
    
    복사편집
    
    `@Override public synchronized Throwable fillInStackTrace() {     return this;  // 스택 트레이스 생략 }`
    
 **(4) Checked Exception을 과도하게 사용하지 않기**

- Checked Exception은 `throws` 선언과 `try-catch`로 인한 불필요한 오버헤드가 생길 수 있습니다.  
    실무에서 Spring, JPA 등이 **Unchecked(Runtime) Exception** 중심으로 설계된 이유 중 하나입니다.
    

 **(5) Hot Path(빈번히 호출되는 코드)에서는 예외 최소화**

- 성능이 중요한 루프, API 엔드포인트 등에서는 **예외가 발생하지 않도록 사전 방어 로직을 작성**.
    

---

 **4. 결론**

- **예외 발생 자체는 일반 로직보다 훨씬 느립니다.**
    
- 하지만 **예외가 발생하지 않는 한, `try-catch` 문 자체는 거의 오버헤드가 없습니다.**
    
- 따라서 **예외는 진짜 “예외적 상황”에서만 사용하고, 사전 조건 검사로 방어 코드를 작성하는 것이 성능 최적화의 핵심**입니다.
### 7. Synchronized 키워드에 대해 설명해 주세요.
##### 설명
`synchronized` 키워드는 Java에서 **멀티스레드 환경에서의 동기화(synchronization)** 를 위해 사용됩니다. 하나의 자원(변수, 메서드 등)을 여러 스레드가 동시에 접근할 때, **경쟁 조건(race condition)** 을 방지하기 위해 사용됩니다.

---
🔹 1. 핵심 개념

- `synchronized`는 **임계 영역(Critical Section)** 에 **하나의 스레드만 접근하도록 락(lock)을 거는 기능**입니다.
    
- 자바에서 **객체마다 하나의 모니터 락(Monitor Lock)** 을 가지고 있으며, synchronized는 이 락을 기반으로 작동합니다.
    

---
🔹 2. 사용 방법

✅ 1. 메서드 전체 동기화

```java
public synchronized void increment() {
    count++;
}

```
- 인스턴스 메서드의 경우: **해당 객체(this)** 를 락으로 사용
    
- 동시에 여러 스레드가 `increment()`를 호출해도 **한 스레드만 락을 얻고 실행**됨
    

---
✅ 2. 블록 단위 동기화

```java
public void increment() {
    synchronized(this) {
        count++;
    }
}

```
- `this`는 락의 대상입니다. 더 정밀한 제어가 가능하며, 일부 코드만 동기화할 때 사용합니다.
    

---
✅ 3. static 메서드 동기화

```java
public static synchronized void printLog() {
    // ...
}

```
- `static` 메서드는 **클래스 수준의 락 (`ClassName.class`)** 을 사용합니다.
    
🔹 3. 작동 원리

`synchronized` 블록에 진입하면:

1. 대상 객체의 **모니터 락을 획득**합니다.
    
2. 락을 획득한 스레드만 블록을 실행할 수 있습니다.
    
3. 실행이 끝나면 락을 **반환(해제)** 합니다.
    
4. 다른 스레드는 락이 반환될 때까지 **대기 상태(BLOCKED)** 가 됩니다. 

---
🔹 4. 장점과 단점

|항목|설명|
|---|---|
|✅ 장점|Race condition 방지, 스레드 안전성 보장|
|⚠ 단점|성능 저하, 데드락 가능성 있음, 락 경쟁으로 병렬성 감소|

---
🔹 5. 관련 개념

- `ReentrantLock`: `synchronized`보다 정교한 락 제어가 가능 (timeout, tryLock, interruptible 등)
    
- `volatile`: 메모리 가시성을 보장하지만 동기화는 아님
    
- `wait()`, `notify()`: `synchronized` 블록 내에서만 사용 가능 (Object의 모니터를 이용)
    
##### Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
✅ 1. 인스턴스 메서드에 붙을 때

```java
`public synchronized void instanceMethod() {     // ... }`
```


✔ 의미

- **this 객체의 모니터(lock)** 를 사용합니다.
    
- 즉, 같은 객체에 대해 여러 스레드가 `instanceMethod()`를 호출하면 **동시에 접근할 수 없습니다.**
    
❗하지만 서로 다른 인스턴스라면 동시 접근 가능합니다.

---
✅ 2. static 메서드에 붙을 때
```java
public static synchronized void staticMethod() {
    // ...
}

```
 의미

- **해당 클래스의 Class 객체 (`ClassName.class`)의 모니터(lock)** 를 사용합니다.
    
- 모든 인스턴스가 공유하는 클래스 수준의 락입니다.
    
➕ 실전 예

- 싱글턴에서 전역 설정 변경 같은 작업을 synchronized static으로 제어할 수 있음.
    

---
✅ 3. 블록에 붙을 때
```java
public void method() {
    synchronized(this) {
        // ...
    }
}

```
 ✔ 의미

- **명시한 객체의 모니터(lock)** 를 사용합니다.
- `synchronized(obj)` → obj가 락의 대상입니다.
    
➕ 실전 예

- 블록 단위로 최소한의 영역만 동기화하고 싶을 때, 또는
- 객체에 따라 락을 분리하고 싶을 때 (예: `userId`마다 락 다르게 하기)
    

---
✅ 4. 예시 비교

```java
class Example {
    public synchronized void methodA() { }      // this 객체에 락
    public static synchronized void methodB() { } // Class 객체에 락
    public void methodC() {
        synchronized(this) { }                  // this 객체에 락
    }
    public void methodD() {
        synchronized(Example.class) { }         // Class 객체에 락
    }
}

```

|메서드 이름|락 대상|
|---|---|
|methodA|this (인스턴스)|
|methodB|Example.class (클래스)|
|methodC|this (인스턴스)|
|methodD|Example.class (클래스)|

---
✅ 요약 정리

|위치|락 대상|설명|
|---|---|---|
|`synchronized` 인스턴스 메서드|`this`|해당 객체 단위의 동기화|
|`synchronized` static 메서드|`ClassName.class`|클래스 단위의 동기화|
|`synchronized(this)`|`this`|블록 단위로 인스턴스 락 사용|
|`synchronized(obj)`|`obj`|원하는 객체로 락 분리 가능|
##### 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
`synchronized`는 **멀티스레드 환경에서 안전성을 보장하는 데 필수적인 도구**이지만, **효율적인 코드 작성을 위한 도구는 아닙니다**. 오히려 잘못 사용하면 성능 저하나 병목을 유발할 수 있습니다.

따라서 효율적인 코드 작성을 목표로 할 때는 `synchronized`의 **장점과 단점**을 명확히 이해하고 **필요한 최소한의 범위에서 신중하게 사용하는 것**이 중요합니다.

---
 ✅ synchronized의 장점

| 장점                | 설명                                                        |
| ----------------- | --------------------------------------------------------- |
| **간단한 문법**        | 락/언락을 명시적으로 하지 않아도 됨 (`try-finally` 불필요)                  |
| **스레드 안전성 보장**    | 공유 자원에 대한 동시에 접근할 경우, 레이스 컨디션 방지                          |
| **JVM 최적화 적용 대상** | JDK 1.6 이상에서는 biased lock, lightweight lock 등 최적화 기법이 적용됨 |

---
 ❌ synchronized의 단점 (비효율적일 수 있는 이유)

| 단점            | 설명                                               |
| ------------- | ------------------------------------------------ |
| **성능 저하**     | 스레드 간 lock 경쟁 발생 시, context switching 비용 증가      |
| **병목 발생 가능성** | 락 범위를 넓게 설정하면 하나의 스레드 때문에 전체가 대기할 수 있음           |
| **데드락 위험**    | 여러 락을 중첩해서 사용할 경우 발생 가능                          |
| **유연성 부족**    | 락의 조건, 시간 제한, 중단 제어 등을 못 함 (`ReentrantLock`은 가능) |

---
💡 효율적인 대안 또는 개선 방법

| 방법                      | 설명                                                                 |
| ----------------------- | ------------------------------------------------------------------ |
| **락 범위를 줄이기**           | 전체 메서드 대신 필요한 코드 블록만 synchronized 처리                               |
| **`ReentrantLock` 사용**  | 명시적 락 제어, 타임아웃, 락 중단, 공정성 설정 등 가능                                  |
| **`Concurrent` 컬렉션 사용** | `ConcurrentHashMap`, `CopyOnWriteArrayList` 등은 내부적으로 적절히 락을 나눠서 처리 |
| **비동기 처리/락 분리**         | 독립적인 리소스는 서로 다른 락을 사용해서 병렬성 향상 가능                                  |
| **원자 클래스 사용**           | `AtomicInteger`, `AtomicLong` 등은 락 없이도 thread-safe 연산 가능           |

---
 📌 결론

> **“안전성 확보에는 유용하지만, 효율적인 코드 작성만을 고려하면 신중하게 사용해야 할 키워드입니다.”**

- 성능이 중요한 영역에서는 `synchronized` 보다는 더 정밀한 제어가 가능한 도구를 사용하는 것이 좋습니다.
    
- 단, 초기 개발이나 구조가 단순할 때는 빠르게 스레드 안전성을 확보하는 데 좋은 선택이 될 수 있습니다.
##### Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
✅ 1. `ReentrantLock` (java.util.concurrent.locks)

✔ 특징

- `synchronized`보다 유연하고 기능이 풍부한 락
    
- 명시적으로 lock()/unlock() 호출 필요
    

✔ 주요 기능

|기능|설명|
|---|---|
|`tryLock()`|락이 사용 중이면 대기하지 않고 바로 실패|
|`tryLock(timeout)`|일정 시간만 기다렸다가 실패|
|`lockInterruptibly()`|대기 중인 스레드를 interrupt로 중단 가능|
|`isHeldByCurrentThread()`|락 보유 여부 확인|
|`getHoldCount()`|재진입 횟수 확인|
✔ 예시
```java
ReentrantLock lock = new ReentrantLock();

void update() {
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock(); // 반드시 해제
    }
}

```
---
 ✅ 2. `ReadWriteLock` (`ReentrantReadWriteLock`)

✔ 특징

- 읽기 작업은 동시에 허용, 쓰기 작업은 단독 실행
    
- 읽기 많은 시스템에서 성능 향상 가능
    

✔ 예시
```java
ReentrantLock lock = new ReentrantLock();

void update() {
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock(); // 반드시 해제
    }
}

```
---
✅ 3. `StampedLock` (Java 8+)
✔ 특징

- `ReadWriteLock`의 개선 버전
    
- 낙관적 읽기(optimistic read)를 제공하여 **락 없는 읽기** 가능
    
- 더 복잡하지만 **고성능 읽기 시나리오**에 적합
    

---
✅ 4. `Atomic` 클래스 (java.util.concurrent.atomic)
✔ 특징

- 락 없이 CAS(Compare-And-Swap) 기반 원자 연산 제공
    
- 단일 변수 동기화에 매우 효과적
    
✔ 대표 클래스

- `AtomicInteger`, `AtomicLong`
    
- `AtomicReference`, `AtomicBoolean`
    
- `AtomicIntegerArray`, `AtomicReferenceArray`
    
✔ 예시
```java
AtomicInteger count = new AtomicInteger(0);

void increment() {
    count.incrementAndGet(); // thread-safe
}

```
✅ 5. `volatile` 키워드

✔ 특징

- **변수의 변경 내용을 모든 스레드에 즉시 반영** (메모리 가시성 보장)
    
- 락을 사용하지 않으므로 성능은 뛰어나지만 **복잡한 연산에는 불안정**
    
✔ 한계

- 원자성(atomicity)은 보장하지 않음
    
- 단독 사용보다는 다른 구조와 함께 써야 안전함
    

---
✅ 6. `synchronized`와의 비교 요약

|기법|장점|단점|
|---|---|---|
|`synchronized`|간편하고 안정적|성능 저하, 데드락 위험|
|`ReentrantLock`|고급 제어 가능|락 해제 실수 위험|
|`ReadWriteLock`|읽기 병렬성|쓰기 많으면 오히려 성능 저하|
|`StampedLock`|낙관적 락으로 고성능|사용 복잡|
|`Atomic` 클래스|빠르고 가볍다|복잡한 연산에는 부적합|
|`volatile`|가시성 확보|원자성 미보장|

---
🧠 결론

- `synchronized`는 단순한 동기화에는 충분하지만, **성능/유연성/복잡성** 요구에 따라 다른 대체 수단을 선택하는 것이 바람직합니다.
    
- **간단한 락** → `synchronized`
    
- **정밀 제어** → `ReentrantLock`, `ReadWriteLock`
    
- **낮은 지연, 높은 성능** → `StampedLock`, `Atomic`
    
- **값 교체만 필요한 경우** → `volatile`, `AtomicReference`
##### Thread Local에 대해 설명해 주세요.
`ThreadLocal`은 **스레드마다 독립적인 변수를 가질 수 있게 해주는 클래스**입니다. 멀티스레드 환경에서 **공유 자원을 피하고**, 각 스레드가 **자기만의 데이터를 보관**하고 사용할 수 있도록 도와줍니다.

---
✅ 1. ThreadLocal의 정의

> `ThreadLocal<T>`은 **각 스레드마다 고유한 변수 값을 저장**할 수 있도록 해주는 Java 클래스입니다.

즉, 하나의 `ThreadLocal` 인스턴스를 여러 스레드가 공유하더라도, **스레드마다 각각의 값**을 따로 저장하고 사용합니다.

---
✅ 2. 기본 사용법

```java
ThreadLocal<Integer> threadLocal = new ThreadLocal<>();

// 값 설정
threadLocal.set(100);

// 값 가져오기
int value = threadLocal.get();

// 값 제거 (메모리 누수 방지)
threadLocal.remove();

```
- `set(value)` → 현재 스레드에 값을 저장
    
- `get()` → 현재 스레드의 값을 조회
    
- `remove()` → 현재 스레드의 값 제거 (메모리 누수 방지)
    

---
✅ 3. ThreadLocal 동작 방식

- 내부적으로 `ThreadLocalMap`이라는 자료구조를 사용하여  
    **`Thread` 객체마다 고유한 Map이 존재**합니다.
    
- 이 Map의 key는 `ThreadLocal` 객체, value는 저장한 데이터입니다.
    
```
Thread A
 └─ ThreadLocalMap
      └─ [ThreadLocal@1a2b3c] -> 100

Thread B
 └─ ThreadLocalMap
      └─ [ThreadLocal@1a2b3c] -> 200

```
→ 같은 ThreadLocal 객체여도, 스레드마다 독립적인 값을 저장합니다.

---
✅ 4. 활용 예시

💡 예: 날짜 포맷 객체 공유 문제 해결

```java
ThreadLocal<DateFormat> dateFormat = ThreadLocal.withInitial(() ->
    new SimpleDateFormat("yyyy-MM-dd")
);

// 스레드마다 안전하게 사용 가능
String today = dateFormat.get().format(new Date());

```
- `SimpleDateFormat`은 **스레드에 안전하지 않음**.
    
- `ThreadLocal`을 이용하면 각 스레드마다 별도의 객체를 사용하므로 동기화 없이도 안전하게 사용 가능.
    

---
✅ 5. 장점과 단점

|장점|단점|
|---|---|
|락 없이 스레드별 독립 데이터 제공|**메모리 누수 위험** (remove 누락 시)|
|코드 복잡도 감소 (공유 없이도 데이터 유지 가능)|스레드 수 많을 경우 메모리 사용 증가|
|특정 스레드에서만 유효한 값 저장 가능|논리적 흐름 따라가기 어려움 (숨겨진 상태 발생 가능)|

---
✅ 6. 실전 활용 사례

|분야|활용 예|
|---|---|
|Spring Security|현재 로그인한 사용자 정보 저장 (`SecurityContextHolder`)|
|DB Connection Pool|트랜잭션 단위로 같은 커넥션 유지 (`DataSourceTransactionManager`)|
|로그 트레이싱|요청 ID를 스레드에 저장해 로그에 일관되게 출력 (e.g. MDC)|

---
🧠 결론

- `ThreadLocal`은 **스레드별로 독립된 변수**가 필요한 경우 유용합니다.
    
- 다만, `remove()`를 반드시 호출하지 않으면 **메모리 누수**가 발생할 수 있으므로 **ThreadPool 사용 시 특히 주의**해야 합니다.
### 8. Java Stream에 대해 설명해 주세요.
##### 설명
Java Stream은 Java 8에서 도입된 기능으로, **데이터를 선언형(Declarative) 방식으로 처리**할 수 있게 해주는 API입니다. **컬렉션 또는 배열의 요소들을 필터링, 변환, 정렬, 집계** 등의 작업을 간결하고 효율적으로 수행할 수 있도록 설계되었습니다.

---
 ✅ Stream의 주요 특징

1. **선언형 처리 방식**
    
    - 반복문 없이 `filter`, `map`, `reduce` 등의 메서드로 데이터를 처리합니다.
        
    - 코드가 간결하고 가독성이 좋습니다.
        
2. **중간 연산과 최종 연산**
    
    - **중간 연산**: `filter`, `map`, `sorted` 등 → Stream을 반환
        
    - **최종 연산**: `collect`, `forEach`, `count`, `reduce` 등 → 결과를 반환하거나 처리 종료
        
3. **지연(Lazy) 연산**
    
    - 중간 연산은 실제로 결과를 필요로 할 때(최종 연산 시점) 실행됩니다.
        
4. **병렬 처리 지원**
    
    - `.parallelStream()`을 사용하면 멀티코어 CPU에서 병렬로 처리할 수 있습니다.
        

---
✅ 예제

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(result); // [ALICE, CHARLIE]

```
 ✅ 주요 메서드 설명

| 메서드                    | 설명                |
| ---------------------- | ----------------- |
| `filter(Predicate)`    | 조건에 맞는 요소만 남김     |
| `map(Function)`        | 요소를 다른 형태로 변환     |
| `sorted()`             | 정렬                |
| `distinct()`           | 중복 제거             |
| `limit(n)` / `skip(n)` | 앞에서 n개 가져오거나 건너뜀  |
| `collect()`            | 결과를 리스트, 셋 등으로 수집 |
| `reduce()`             | 모든 요소를 하나의 값으로 축약 |
 ✅ 주의점

- **Stream은 일회용**이며, 한 번 소비하면 다시 사용할 수 없습니다.
    
- 내부 반복 방식이므로 **디버깅이 어렵거나 성능 튜닝이 필요한 경우 주의**가 필요합니다.
    
- **null을 포함한 컬렉션 처리 시 NPE 주의**가 필요합니다.
    

 

##### Stream과 for ~ loop의 성능 차이를 비교해 주세요,
`Java Stream`과 `for-loop`의 성능 차이는 **상황에 따라 달라지며**, 다음과 같은 측면을 기준으로 비교할 수 있습니다.

---
✅ 1. **기본 성능 비교**

| 항목         | for-loop                   | Stream                      |
| ---------- | -------------------------- | --------------------------- |
| **처리 방식**  | 외부 반복 (External Iteration) | 내부 반복 (Internal Iteration)  |
| **오버헤드**   | 없음 또는 적음                   | 상대적으로 있음                    |
| **속도**     | 일반적으로 더 빠름                 | 약간 느릴 수 있음 (특히 작은 데이터)      |
| **코드 가독성** | 명령형(Imperative) 스타일        | 선언형(Declarative) 스타일 (더 깔끔) |
```java
List<Integer> list = IntStream.range(0, 1_000_000).boxed().collect(Collectors.toList());

// for-loop
long sum1 = 0;
for (int n : list) {
    sum1 += n;
}

// Stream
long sum2 = list.stream().mapToLong(i -> i).sum();

```

- 위 경우 일반적으로 **for-loop가 더 빠릅니다**.
    
- Stream은 람다 표현식, 내부 반복 등으로 **약간의 오버헤드**가 발생합니다.
    
 ✅ 2. **병렬 처리 측면**

|항목|for-loop|Stream (parallel)|
|---|---|---|
|**멀티코어 활용**|수동으로 스레드 작성 필요|`.parallelStream()`으로 간단히 가능|
|**대용량 데이터**|직접 병렬 처리 코드 작성|자동 병렬화로 성능 향상 가능|
|**병렬 안전성**|직접 제어 가능|상태 공유 없이 사용해야 안정적|

`long parallelSum = list.parallelStream()     .mapToLong(i -> i)     .sum();`

- 데이터가 **충분히 크고**, **연산이 독립적**이라면 `parallelStream()`이 **for-loop보다 빠를 수 있습니다**.
    

---
✅ 3. **성능 비교 정리**

|조건|더 적합한 방식|
|---|---|
|작은 데이터셋 / 성능 중요|`for-loop` (낮은 오버헤드)|
|복잡한 변환 / 필터링 / 가독성|`Stream` (선언적이고 간결)|
|병렬 처리 필요|`parallelStream` (멀티코어 활용)|
|디버깅이나 세밀한 제어 필요|`for-loop` (유연한 흐름 제어)|

---
✅ 결론

- **Stream은 가독성과 유지보수에 강점**이 있으나, **성능 면에서는 for-loop보다 느릴 수 있습니다.**
    
- 단, **데이터가 크고 병렬성이 높은 작업**에서는 `parallelStream`이 **for-loop보다 빠를 수 있습니다**.
    
- **성능이 중요한 핵심 로직에서는 반드시 성능 테스트 후 선택**하는 것이 좋습니다. (`JMH` 추천)
##### Stream은 병렬처리 할 수 있나요?
네, **Java Stream은 병렬 처리(parallel processing)를 지원합니다.**  
바로 `.parallelStream()` 또는 `.parallel()` 메서드를 사용하면 여러 CPU 코어를 활용한 병렬 연산을 수행할 수 있습니다.

---
✅ 병렬 스트림 사용법
```java
List<Integer> list = IntStream.rangeClosed(1, 1_000_000).boxed().toList();

// 병렬 처리: sum
long sum = list.parallelStream()
    .mapToLong(i -> i)
    .sum();

```

- 위 코드는 리스트를 여러 스레드로 나눠 병렬로 `sum()` 연산을 수행합니다.
    
- 내부적으로는 **Fork/Join 프레임워크**를 사용합니다.
    

---
✅ 병렬 스트림의 특징

| 항목              | 설명                                              |
| --------------- | ----------------------------------------------- |
| **자동 스레드 분할**   | Stream이 알아서 적절한 스레드 수와 작업 분할 수행                 |
| **멀티코어 CPU 활용** | 작업을 여러 코어에 분산 실행                                |
| **비결정적 순서**     | 연산 순서가 보장되지 않음 (단 `forEachOrdered()`는 순서 보장)    |
| **상태 공유 금지**    | 상태 변경이 있는 연산은 병렬 스트림에서 안전하지 않음 (side-effect 지양) |

---
✅ 주의사항

- **작은 데이터**나 **단순한 연산**에서는 오히려 `.parallelStream()`이 느릴 수 있습니다.  
    → 스레드 분할/병합 비용이 더 클 수 있음
    
- **상태 공유(stateful)** 연산은 주의 필요  
    → 예: `forEach()` 내에서 외부 리스트에 `add()`하면 race condition 발생 가능
    
- `Collectors.toList()` 등 수집 작업도 병렬 안전하게 설계되어 있어야 함
    

---
✅ 병렬 Stream 예시
```java
List<String> names = List.of("Alice", "Bob", "Charlie", "Dave");

names.parallelStream()
     .map(String::toUpperCase)
     .forEach(System.out::println); // 순서 보장 안됨

names.parallelStream()
     .map(String::toUpperCase)
     .forEachOrdered(System.out::println); // 순서 보장

```
 ✅ 요약

|질문|답변|
|---|---|
|**Stream에서 병렬 처리 가능?**|✅ 예, `.parallelStream()` 또는 `.parallel()` 사용|
|**성능 이점?**|✅ 데이터가 크고 독립적 연산이면 성능 향상|
|**주의할 점?**|⚠️ 상태 공유 금지, 순서 비결정성, 작은 데이터는 오히려 느릴 수 있음|
##### Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
Java Stream API는 **함수형 인터페이스(Functional Interface)**를 기반으로 동작합니다. 이 인터페이스들은 **람다 표현식**이나 **메서드 참조**와 함께 사용되며, `Stream`에서 각 요소를 처리하는 역할을 합니다.

다음은 **Stream에서 자주 사용되는 함수형 인터페이스 4가지**입니다:

---
✅ 1. `Predicate<T>`

- **역할**: `boolean` 값을 반환하는 **조건 검사 함수**
    
- **사용처**: `filter()`, `allMatch()`, `anyMatch()` 등에서 사용
    
- **함수형 메서드**: `boolean test(T t)`
    
 예시
```java
Stream.of("apple", "banana", "carrot")
    .filter(s -> s.startsWith("a")) // Predicate<String>
    .forEach(System.out::println);  // 출력: apple

```
✅ 2. `Function<T, R>`

- **역할**: `T` 타입을 받아서 `R` 타입으로 **변환하는 함수**
    
- **사용처**: `map()`, `flatMap()` 등에서 사용
    
- **함수형 메서드**: `R apply(T t)`
    

예시
```java
Stream.of("apple", "banana")
    .map(s -> s.length()) // Function<String, Integer>
    .forEach(System.out::println); // 출력: 5, 6

```
✅ 3. `Consumer<T>`

- **역할**: 입력 값을 받아서 **소비만 하고 반환값이 없는 함수**
    
- **사용처**: `forEach()`, `peek()` 등에서 사용
    
- **함수형 메서드**: `void accept(T t)`
    
예시

```java
Stream.of(1, 2, 3)
    .forEach(n -> System.out.println(n)); // Consumer<Integer>

```
✅ 4. `Supplier<T>`

- **역할**: 입력 없이 **값을 제공하는 함수**
    
- **사용처**: `Stream.generate()`, lazy 초기화 등에서 사용
    
- **함수형 메서드**: `T get()`
    

예시
```java
Stream.of(1, 2, 3)
    .forEach(n -> System.out.println(n)); // Consumer<Integer>

```
✅ 그 외 자주 쓰이는 확장 인터페이스

|인터페이스|설명|
|---|---|
|`UnaryOperator<T>`|`Function<T, T>`의 특수한 형태 (입출력 타입 동일)|
|`BinaryOperator<T>`|`BiFunction<T, T, T>`의 특수한 형태 (두 입력 → 하나의 같은 타입 결과)|
|`BiFunction<T, U, R>`|두 개의 입력을 받아 하나의 결과 생성|
|`BiPredicate<T, U>`|두 개의 입력을 받아 `boolean` 반환|
|`ToIntFunction<T>` 등|`int`, `long`, `double` 특화 함수 (기본형 지원)|

---
✅ 요약

|인터페이스|설명|사용 메서드 예|
|---|---|---|
|`Predicate<T>`|조건 검사|`filter()`, `allMatch()`|
|`Function<T, R>`|변환|`map()`, `flatMap()`|
|`Consumer<T>`|소비 (출력, 저장 등)|`forEach()`, `peek()`|
|`Supplier<T>`|값 공급|`generate()`|

---

Stream API의 핵심은 **함수형 인터페이스를 조합해 선언적으로 데이터를 처리하는 것**입니다.
##### 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
좋은 질문입니다. Java에서 람다식이나 익명 클래스 내부에서 외부 변수를 사용할 때 `final` 또는 **사실상 final (effectively final)**이어야 하는 이유는 다음과 같습니다.

---
✅ 왜 `final` 또는 effectively final이어야 할까?

🔸 이유: **스레드 안전성과 일관성 확보를 위해서**

람다식은 내부적으로 **익명 클래스 또는 내부 클래스로 변환**되며, 외부 변수에 접근할 때 **그 값의 복사본을 캡처**합니다.  
이때, 변수의 값이 **변하지 않아야 예측 가능한 결과를 보장**할 수 있으므로 `final` 또는 변경되지 않는 값만 허용합니다.

 ✅ 예시로 살펴보기

```java
int x = 10;

Runnable r = () -> {
    System.out.println(x); // OK: x는 effectively final
};

x = 20; // ❌ 컴파일 에러: x는 더 이상 final이 아님

```
위 코드에서 `x`를 변경하려 하면 컴파일 오류가 발생합니다. 이유는:

- 람다는 `x`의 값을 복사해서 내부에 저장
    
- 그런데 외부에서 `x`를 변경하면 **복사본과 실제 값이 달라질 위험**이 있음
    
- 이를 방지하기 위해 Java는 **변경 가능한 외부 변수는 캡처하지 못하게 막음**
    
✅ 꼭 `final`이어야 하나요?

- **아니요.** Java 8부터는 꼭 `final` 키워드를 명시하지 않아도 됩니다.
    
- 단, 그 변수는 **사실상 final (변경되지 않아야 함)**이어야 합니다.
    
```java
`String name = "Alice"; list.forEach(s -> System.out.println(name)); // OK: name은 변경되지 않음`

```

---
✅ 그럼 값을 바꾸고 싶을 때는?

값을 바꾸고 싶다면, **배열, 리스트, AtomicInteger** 같은 **참조형을 사용**해 내부 값을 변경해야 합니다.

```java
`int[] sum = {0}; list.forEach(n -> sum[0] += n); // 배열은 final이지만 내부 값은 변경 가능`

```
```java
`AtomicInteger sum = new AtomicInteger(0); list.forEach(n -> sum.addAndGet(n));`
```

---
✅ 요약

| 질문                      | 답변                                                         |
| ----------------------- | ---------------------------------------------------------- |
| 외부 변수에 왜 `final`이 필요할까? | 람다/익명 클래스가 **복사본을 캡처**하기 때문에, 값 변경 시 **혼란이나 오류**가 생길 수 있음  |
| 꼭 `final` 붙여야 하나요?      | ❌ Java 8부터는 안 붙여도 되지만, **변경은 금지되어야 함** (effectively final) |
| 변경하려면 어떻게 하나요?          | 배열, 리스트, `AtomicInteger` 등 **참조형 객체 사용**                   |

### 9. Java의 GC에 대해 설명해 주세요.
##### 설명
Java의 **GC(Garbage Collector)**는 **더 이상 사용되지 않는 메모리(객체)를 자동으로 해제**해주는 JVM의 기능입니다. 개발자가 메모리를 직접 해제하지 않아도 되도록 하여 **메모리 누수 방지**와 **안정성 향상**을 돕습니다.

---
✅ 1. GC란 무엇인가?

- **Garbage Collection**: 더 이상 참조되지 않는 객체를 **자동으로 탐지하고 제거**하는 과정
    
- GC의 목적:
    
    - 사용하지 않는 객체 제거
        
    - 메모리 회수 (heap 공간 확보)
        
    - OutOfMemoryError 방지
        

---
✅ 2. 객체는 어디에 저장되나?

Java 객체는 대부분 **힙(Heap)** 메모리에 저장되며, GC는 이 **힙 메모리 영역**을 관리합니다.  
JVM의 힙 영역은 다음과 같이 나뉩니다:

```java
Heap
├── Young Generation (Eden + Survivor)
└── Old Generation (Tenured)


```

---
✅ 3. 주요 개념

| 개념                   | 설명                                      |
| -------------------- | --------------------------------------- |
| **Young Generation** | 새로 생성된 객체가 저장됨. 대부분 금방 사라지므로 빠르게 수집     |
| **Old Generation**   | 오래 살아남은 객체가 저장됨. 크고 무거운 GC가 수행됨         |
| **Eden**             | 새 객체가 처음 할당되는 공간                        |
| **Survivor**         | Eden에서 살아남은 객체가 옮겨가는 공간 (S0, S1 두 개 존재) |
| **Tenuring**         | Survivor 영역에서 일정 횟수 이상 살아남으면 Old로 이동    |

---
✅ 4. GC의 종류 (JVM별 정책)

|GC 종류|특징|적합한 환경|
|---|---|---|
|**Serial GC**|단일 스레드, 정지 시간이 김|단일 CPU, 작은 앱|
|**Parallel GC**|멀티 스레드, Throughput 중심|병렬 처리 가능, 일반적인 서버|
|**CMS (Concurrent Mark & Sweep)**|짧은 정지 시간, 일부 병행 처리|사용자 응답 중요|
|**G1 GC**|영역을 나눠 병렬 처리 + 예측 가능한 정지 시간|대형 서비스, JVM 9+ 기본|
|**ZGC / Shenandoah**|초저지연 GC, 대부분 병렬/비동기 수행|실시간 응답이 중요한 시스템 (JDK 11+)|

---
✅ 5. GC 동작 과정 (Mark-Sweep-Compact)

1. **Mark**: 참조 가능한 객체를 모두 표시
    
2. **Sweep**: 표시되지 않은 객체 제거
    
3. **Compact**: 메모리 조각화를 줄이기 위해 객체들을 한쪽으로 압축
    

---
✅ 6. GC 튜닝의 핵심 지표

|지표|의미|
|---|---|
|**GC Pause Time**|GC로 인한 정지 시간|
|**Throughput**|GC 외 작업 수행 비율|
|**Heap Usage**|GC 빈도와 메모리 효율|
|**Object Allocation Rate**|객체 생성 속도|

→ GC 로그, `jstat`, VisualVM, GCViewer 등을 통해 분석 가능

---
✅ 요약

|항목|내용|
|---|---|
|**GC의 목적**|불필요한 객체 제거로 메모리 누수 방지|
|**관리 대상**|주로 힙 메모리 (Young/Old Generation)|
|**GC 종류**|Serial, Parallel, CMS, G1, ZGC 등|
|**기본 방식**|Mark → Sweep → Compact|
|**튜닝 요소**|Pause time, Heap size, GC 로그 분석 등|
##### finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
✅ 1. `finalize()`의 원래 목적

- `Object` 클래스에 정의된 메서드로, 객체가 **GC 대상이 되기 직전**에 호출되어 **정리(clean-up) 작업**을 할 수 있게 합니다.
    
- 보통 **자원 해제**, 예: 파일 닫기, 소켓 정리 등의 목적
    
```java
@Override
protected void finalize() throws Throwable {
    try {
        // 자원 해제 코드
    } finally {
        super.finalize();
    }
}

```


> ✅ 하지만, **GC가 객체를 수거할 때만** JVM이 자동으로 호출해야 합니다.

---
❌ 수동 호출이 문제가 되는 이유

1. **객체가 GC되지 않았는데 finalize()가 호출됨**

- `finalize()`는 **객체가 더 이상 사용되지 않을 때** 호출되어야 의미가 있음.
    
- 수동 호출하면 아직 살아있는 객체를 **잘못된 상태로 만듦** (예: 자원을 닫았는데 여전히 사용 중일 수 있음).
    
2. **중복 호출 가능성**

- `finalize()`는 JVM에 의해 한 번만 호출됩니다.
    
- 수동으로 호출하면 **예상치 못한 시점에 두 번 실행**될 수 있어 예측 불가능한 동작 발생.
    
3. **자원 관리에 혼란**

- 수동 호출로 인해, 자원이 **정상적으로 해제된 것인지**, **GC에 의해 해제될 것인지** 구분이 안됨.
    
- 결과적으로 **메모리 누수** 또는 **자원 충돌**이 발생할 수 있음.
    
4. **finalize()는 deprecated**

- Java 9부터 **Deprecated**
    
- Java 18부터는 **기본적으로 제거됨**
    
- 더 안전한 방식인 `try-with-resources`나 `AutoCloseable` 인터페이스 사용 권장
    

---
✅ 권장되는 자원 정리 방법
```java
try (FileInputStream fis = new FileInputStream("test.txt")) {
    // 파일 처리
} catch (IOException e) {
    // 예외 처리
}
// 자원 자동 해제 (close 호출됨)

```

> → `Closeable` 또는 `AutoCloseable` 구현 클래스는 `try-with-resources`로 안전하게 자원을 해제할 수 있습니다.

---
✅ 요약

|항목|설명|
|---|---|
|`finalize()`는 언제 호출됨?|GC 직전에 JVM이 자동 호출|
|수동 호출의 문제점|생명주기 혼란, 중복 호출, 자원 충돌 위험|
|Java에서의 권장 방법|`AutoCloseable` + `try-with-resources` 사용|
|현재 상태|Java 9부터 deprecated, Java 18에서 제거됨|
##### 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
네, **그 변수의 값이 `null`이 되었다면**, 해당 객체는 **GC(가비지 컬렉션)의 대상이 될 가능성이 있습니다.**

단, 그 객체가 **다른 어떤 곳에서도 참조되지 않고 있어야만** 실제로 GC의 대상이 됩니다.

---
✅ 왜 `null` 할당이 GC와 관련이 있을까?

Java의 GC는 **더 이상 "참조되지 않는" 객체**를 찾아서 메모리에서 제거합니다.  
즉, 어떤 객체를 가리키던 변수가 `null`이 되면, **그 객체에 대한 참조가 하나 줄어드는 것**이고,  
그 객체를 참조하는 **모든 참조가 사라지면** GC는 이를 **쓸모없는 객체로 판단하고 수거**할 수 있습니다.

---
✅ 예시로 이해하기

```java
public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass(); // obj가 MyClass 객체를 참조
        obj = null; // 참조 해제 → GC 대상이 될 수 있음
    }
}

```
- 위 코드에서 `obj = null`로 설정한 순간,
    
- `MyClass` 객체는 **다른 참조가 없다면** → **GC 대상**이 됩니다.
    

---
✅ 주의: null로 만들어도 GC되지 않을 수 있는 경우

1. **다른 곳에서 여전히 참조 중인 경우**
    
```java
MyClass obj1 = new MyClass();
MyClass obj2 = obj1;
obj1 = null; // obj2가 여전히 참조 중 → GC 불가

```
2. **static 변수에 저장된 경우**
    
```java
static MyClass global = new MyClass(); // 프로그램 끝까지 참조됨

```

3. **ThreadLocal, WeakReference 등으로 우회 참조되는 경우**
    

---
✅ 요약

|조건|GC 대상 여부|
|---|---|
|참조가 모두 사라짐 (`null` 포함)|✅ 가능함 (GC 대상)|
|다른 참조가 남아 있음|❌ 대상 아님|
|`null`을 명시적으로 할당하면?|✅ GC 대상이 될 가능성은 높아짐, 단 반드시 그런 건 아님|

---
 🔍 참고

Java에서 `null`을 명시적으로 할당하는 것은 **GC 대상이 될 수 있도록 힌트를 주는 것**이지,  
**즉시 GC가 발생하거나 보장되는 것은 아닙니다.**  
GC는 JVM이 **적절한 시점**에 실행합니다.

### 10. equals()와 hashcode()에 대해 설명해 주세요.
##### 설명
`equals()`와 `hashCode()`는 Java의 모든 객체가 상속받는 `Object` 클래스에 정의된 **핵심 메서드**로,  
**객체 비교**와 **해시 기반 컬렉션(HashMap, HashSet 등)**의 동작에 **직접적인 영향을 미칩니다.**

---
✅ 1. `equals()` 메서드

📌 역할:

- 두 객체가 **논리적으로 동일한지 비교**
    
- 기본 구현은 `==` (즉, **주소 비교**)와 동일
    

📌 보통은 오버라이딩해서 사용

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return age == person.age && name.equals(person.name);
}

```

---
✅ 2. `hashCode()` 메서드

📌 역할:

- 객체의 **해시 값을 반환** (정수값)
    
- **HashMap, HashSet, Hashtable** 등에서 **객체를 저장하거나 조회할 때 사용하는 키 값 계산**
    
```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}

```
✅ 3. `equals()`와 `hashCode()`의 관계

> **"equals()가 true면, hashCode()는 반드시 같아야 한다."**

📌 규칙

- `x.equals(y) == true` → `x.hashCode() == y.hashCode()` ✅ 반드시 만족해야 함
    
- 하지만 `x.hashCode() == y.hashCode()` → `x.equals(y)`는 ❌ 반드시 true일 필요는 없음 (충돌 가능)
    

---
✅ 4. 왜 중요할까?

해시 기반 컬렉션(`HashMap`, `HashSet`)에서 **정확한 동작을 위해 반드시 함께 오버라이드**해야 함.

예시:
```java
Set<User> users = new HashSet<>();
users.add(new User("Alice", 20));
System.out.println(users.contains(new User("Alice", 20))); // equals, hashCode 오버라이드 안 하면 false!

```
---
 ✅ 5. 오버라이드 시 주의사항

- `equals()`에서는 `null`과 `instanceof` 체크 반드시 포함
    
- `hashCode()`는 `equals()`에서 비교하는 필드를 기준으로 생성해야 함
    
- `hashCode()`는 가능한 한 **충돌이 적도록 설계**
    

---
✅ 요약

|항목|설명|
|---|---|
|`equals()`|객체의 **논리적 동등성** 비교|
|`hashCode()`|해시 기반 자료구조를 위한 **정수값 식별자**|
|함께 오버라이딩 이유|`HashSet`, `HashMap`의 일관성 보장|
|규칙|`equals() == true → hashCode() == 같음` 반드시 만족|

##### 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
좋은 질문입니다. `hashCode()`를 직접 정의해야 한다면, 다음과 같은 **원칙과 실용적 고려사항**을 반드시 염두에 두고 구현할 것입니다.

---
✅ 1. **equals()와 일관성 유지 (가장 중요)**

> "두 객체가 `equals()`로 같다면, `hashCode()`도 같아야 한다."

- 비교 대상이 되는 필드(예: `id`, `name`, `email` 등)를 기준으로 `hashCode()`도 계산해야 합니다.
    
- 그렇지 않으면 `HashMap`, `HashSet` 등의 컬렉션에서 의도대로 동작하지 않습니다.
    

---
 ✅ 2. **불변성 보장**

- 객체가 컬렉션에 저장된 후 `hashCode()` 값이 바뀌면, 해당 객체를 **찾을 수 없게 됩니다.**
    
- 따라서, `hashCode()` 계산에 사용하는 필드는 **불변(immutable)** 필드로 선택합니다.
    
예: `ID`, 생성 시 설정되는 `UUID`, 혹은 `final` 필드 등

---
 ✅ 3. **충돌 최소화 (균등한 분포)**

- 다른 객체끼리는 **가능하면 서로 다른 hashCode 값을** 갖도록 설계해야 합니다.
    
- 충돌이 많아지면 해시 테이블의 성능이 **선형 탐색 수준으로 저하**될 수 있습니다.
    

✅ 4. **적절한 해시 조합 공식 사용**

- 자주 사용하는 방식: `Objects.hash(...)`, 또는 `31 * result + field.hashCode()` 패턴
    
```java
@Override
public int hashCode() {
    return Objects.hash(name, age); // Java 7+
}
@Override
public int hashCode() {
    int result = name != null ? name.hashCode() : 0;
    result = 31 * result + age;
    return result;
}

```

> `31`은 소수이고 곱셈 연산에서 좋은 분산을 만들어내는 상수로 널리 사용됩니다.

---
✅ 5. null 안전성 고려

- `null` 필드는 `0` 또는 별도의 처리 필요

 ✅ 요약: 내가 `hashCode()`를 정의할 때 고려할 점

| 고려 항목           | 설명                              |
| --------------- | ------------------------------- |
| `equals()`와 일관성 | 같다고 판단되는 객체는 같은 해시값             |
| 불변 필드 사용        | 해시값이 바뀌지 않도록                    |
| 충돌 최소화          | 다른 객체는 다른 해시값                   |
| null 처리         | NPE 방지                          |
| 성능과 가독성         | `Objects.hash()` 또는 31 곱셈 패턴 사용 |
##### 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
좋은 질문입니다. `equals()` 메서드를 재정의해야 할 때는, 단순히 두 객체가 "같다"는 의미를 넘어 **일관성 있고 신뢰할 수 있는 동작을 보장**해야 합니다. 아래는 재정의 시 반드시 염두에 두어야 할 핵심 사항들입니다.

---
 ✅ 1. **`equals()` 메서드의 기본 규약 (Contract)**

Java의 `Object` 클래스가 요구하는 5가지 규칙은 다음과 같습니다:

| 규칙                   | 설명                                                  |
| -------------------- | --------------------------------------------------- |
| **반사성 (Reflexive)**  | `x.equals(x)`는 항상 true                              |
| **대칭성 (Symmetric)**  | `x.equals(y)`이면 `y.equals(x)`도 true                 |
| **추이성 (Transitive)** | `x.equals(y)`이고 `y.equals(z)`이면 `x.equals(z)`도 true |
| **일관성 (Consistent)** | 여러 번 호출해도 결과가 항상 같아야 함 (값이 변하지 않는 한)                |
| **null에 대한 비대칭성**    | `x.equals(null)`은 항상 false                          |

> 이 규약을 지키지 않으면, `HashMap`, `HashSet`, `List.contains()` 등의 동작이 예측 불가능해집니다.

---
✅ 2. **비교 기준이 되는 필드 일관성 유지**

- `equals()`는 **논리적으로 객체가 같은지 비교하는 메서드**이므로, 비교에 사용할 필드를 신중하게 선택해야 합니다.
    
- 보통 **식별자(id)**, **불변 필드**, **주요 속성** 등을 기준으로 합니다.
    

✅ 3. **`hashCode()`와 항상 함께 재정의**

> `equals()`를 재정의하면 반드시 `hashCode()`도 재정의해야 합니다.

그렇지 않으면 `equals()`는 true인데 `hashCode()`가 다르게 되어,  
`HashSet`, `HashMap` 등에선 **정상적으로 동작하지 않습니다.**

---
✅ 4. **클래스 타입 비교 방법**

- 안전한 방식: `getClass()` 사용 (같은 클래스일 때만 equal)
    
- 유연한 방식: `instanceof` 사용 (상속 관계 포함 가능)
    
```java
// getClass 방식: 대칭성 보장에 안전
if (getClass() != o.getClass()) return false;

```
✅ 5. **성능과 null 안전성 고려**

- `Objects.equals(a, b)`를 사용하면 `null` 비교도 안전하게 처리됩니다.
    


`Objects.equals(this.name, other.name);`

---
✅ 요약: equals() 재정의 시 체크리스트

|항목|설명|
|---|---|
|✅ 반사성/대칭성/추이성 등 규약 준수|Java가 보장하는 동작의 전제|
|✅ 주요 필드를 기준으로 비교|주로 식별자, 불변 필드|
|✅ `hashCode()`도 함께 재정의|컬렉션에서 일관된 동작 보장|
|✅ 클래스 타입 비교 명확히|`getClass()` 또는 `instanceof` 선택|
|✅ null 안전성 고려|`Objects.equals()` 활용 권장|

### 11. IoC와 DI에 대해 설명해 주세요.
##### 설명
IoC와 DI는 객체 지향 프로그래밍과 스프링(Spring) 같은 프레임워크에서 매우 중요한 개념입니다. 두 개념은 밀접하게 관련되어 있으나 의미는 다릅니다. 아래에서 개념과 차이, 예시를 통해 명확히 설명하겠습니다.

---
✅ 1. IoC (Inversion of Control, 제어의 역전)

📌 개념:

- **객체 생성과 의존성 관리의 주도권(제어권)을 개발자 → 프레임워크로 넘기는 것**
    
- 즉, **누가 무엇을 제어하느냐가 바뀌는 것**입니다.
    

📌 예전 방식 (제어권: 개발자)

`UserService service = new UserService(new UserRepository());`

📌 IoC 적용 (제어권: 프레임워크)

> 프레임워크가 객체를 생성하고 필요한 의존성을 주입하며, 객체 간의 관계를 설정함

---
 ✅ 2. DI (Dependency Injection, 의존성 주입)
 📌 개념:

- IoC의 **구현 방법 중 하나**
    
- 어떤 객체가 필요로 하는 **의존 객체를 외부에서 주입**받는 방식
    
 📌 DI 종류

| 방법         | 설명                              |
| ---------- | ------------------------------- |
| **생성자 주입** | 생성자를 통해 의존성 전달 (불변성 보장, 테스트 용이) |
| **세터 주입**  | 세터 메서드로 주입 (선택적 의존성)            |
| **필드 주입**  | 필드에 직접 주입 (`@Autowired`, 권장 X)  |

---
 ✅ 3. IoC vs DI

|구분|IoC|DI|
|---|---|---|
|**의미**|제어권을 프레임워크로 넘기는 개념|의존성을 외부에서 주입하는 방식|
|**범위**|포괄적인 설계 철학|IoC를 구현하는 구체적 수단|
|**예시**|객체 생성/초기화를 Spring이 담당|`@Autowired`, 생성자, 세터 등으로 주입|

---
 ✅ 4. 예시 (Spring 기반)

 📌 일반적인 DI 코드
```java
@Component
public class UserService {

    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

```
- `UserService`는 `UserRepository`에 의존
    
- 프레임워크(Spring)가 `UserRepository`를 생성해서 `UserService`에 **주입**해줌
    
- 이 전체 과정은 **IoC 컨테이너가 제어권을 가지며**, DI는 **구체적인 주입 행위**
    

---
✅ 요약

|개념|설명|
|---|---|
|**IoC**|객체 생성 및 제어권을 프레임워크가 갖는 구조|
|**DI**|외부에서 필요한 의존 객체를 주입하는 방법|
|**관계**|DI는 IoC의 구현 방식 중 하나|
|**Spring에서의 구현**|`@Component`, `@Autowired`, `@Bean`, 생성자 주입 등|

##### 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
그럼에도 불구하고 **Spring에서 Bean으로 등록해서 사용하는 이유**는 단순히 “대체 가능성” 때문만이 아니라, **아키텍처적 유연성과 핵심 기능 활용** 때문입니다. 아래에서 차근차근 설명드리겠습니다.

---
 ✅ 1. 지금은 하나지만, 나중엔 바뀔 수 있기 때문

- 현재는 구현체가 하나뿐이지만, 시간이 지나면서 요구사항이 늘어나고 다양한 구현이 필요해질 수 있습니다.
    
    - 예: `EmailNotificationService` → 나중엔 `SmsNotificationService`, `PushNotificationService` 추가될 수 있음
        
- 이때 **DI로 설계되어 있다면 구조 변경이 최소화**됩니다.
    

 ✅ 2. Spring의 핵심 기능을 쓰기 위해서 (프레임워크 통합)

Bean으로 등록하면 다음과 같은 **Spring의 기능**들을 사용할 수 있습니다:

| 기능               | 설명                        |
| ---------------- | ------------------------- |
| `@Transactional` | 트랜잭션 자동 관리                |
| `@Async`         | 비동기 실행                    |
| `@Scheduled`     | 스케줄링                      |
| AOP              | 로깅, 보안, 성능 측정 등 횡단 관심사 처리 |
| 프록시 기반 확장        | 실제 구현체를 감싸서 기능 추가 가능      |

→ 일반 클래스 직접 사용하면 이 기능들을 **적용할 수 없습니다.**

---
 ✅ 3. 테스트 용이성

- DI 구조에서는 **Mock 또는 Stub을 쉽게 주입할 수 있습니다.**
    
- 반면 직접 생성하면 테스트가 어렵고, **결합도가 높아집니다.**
    
```java
// 나중에 쉽게 바꿀 수 있음
@Autowired
NotificationService notificationService;

```
 ✅ 4. 생명주기 및 리소스 관리

- Spring은 Bean의 **생성, 초기화, 소멸까지 생명주기를 관리**합니다.
    
- 예: DB 커넥션 풀, 쓰레드풀, 캐시 초기화 등 → 일반 객체로 만들면 수동 관리해야 함
    

---
 ✅ 5. 의존성 자동 주입 및 설정 분리

- Bean을 사용하면 설정을 외부로 분리하고, 구성요소를 동적으로 바꿀 수 있습니다.
    
- `@Profile`, `@Conditional`, `@Value` 등을 이용해 **환경에 따라 유연한 설정** 가능
    

---
 ✅ 요약: 왜 Spring에서는 Bean으로 관리할까?

| 이유                  | 설명                     |
| ------------------- | ---------------------- |
| 확장성                 | 나중에 구현체가 늘어나도 쉽게 대체 가능 |
| AOP/트랜잭션 등 핵심 기능 사용 | Spring이 내부적으로 프록시로 감쌈  |
| 테스트 용이성             | Mock 주입 가능 (DI)        |
| 생명주기 관리             | 객체의 생성~소멸까지 통제         |
| 환경 유연성              | 설정 기반으로 동적으로 선택 가능     |

---
 🔎 결론

> **“지금 하나니까 그냥 쓰자”는 단기적 판단이고, Bean으로 관리하면 ‘유연한 설계’와 ‘Spring의 기능’을 제대로 활용할 수 있는 구조가 됩니다.**

즉, Bean 등록은 단순한 기술적인 선택이 아니라, **좋은 아키텍처를 위한 기반 설계**라고 볼 수 있습니다.
##### Spring의 Bean 생성 주기에 대해 설명해 주세요.
Spring의 Bean 생성 주기(생명주기, Bean Lifecycle)는 **Bean이 컨테이너에 등록되고 소멸되기까지 거치는 단계들**을 의미합니다. 이 과정은 Spring이 **의존성 주입과 초기화, 정리 작업을 자동으로 관리**할 수 있게 해줍니다.

---
 ✅ Spring Bean 생성 주기 (Lifecycle)

1. **Bean 정의 확인 (BeanDefinition 생성)**
    
    - `@Component`, `@Bean`, XML 설정 등에서 Bean 정의를 읽어들임
        
2. **Bean 인스턴스 생성** (`new`)
    
    - 객체 생성 (리플렉션으로 생성자 호출)
        
3. **의존성 주입 (Dependency Injection)**
    
    - `@Autowired`, 생성자, 세터 등을 통해 필요한 의존 객체 주입
        
4. **Aware 인터페이스 호출 (선택적)**
    
    - `BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware` 등
        
    - 자신이 컨테이너 안에서 어떤 Bean인지, 어떤 환경인지 알 수 있음
        
5. **초기화 콜백 호출 (초기화 작업)**
    
    - `@PostConstruct`
        
    - `InitializingBean.afterPropertiesSet()`
        
    - `@Bean(initMethod="...")` 지정 등
        
6. **Bean 사용 (애플리케이션에서 동작)**
    
    - 컨테이너에서 getBean하거나 주입되어 실제 사용됨
        
7. **소멸 콜백 호출 (컨테이너 종료 시)**
    
    - `@PreDestroy`
        
    - `DisposableBean.destroy()`
        
    - `@Bean(destroyMethod="...")` 지정 등
        

---
 ✅ 시각화

`[정의 → 생성 → 주입 → 초기화 → 사용 → 소멸]`

---
 ✅ Bean 초기화 & 소멸 방법 요약

|방식|초기화|소멸|
|---|---|---|
|애노테이션|`@PostConstruct`|`@PreDestroy`|
|인터페이스|`InitializingBean`|`DisposableBean`|
|XML/Java 설정|`initMethod`|`destroyMethod`|

---
 ✅ 예시 코드

```java
@Component
public class MyService implements InitializingBean, DisposableBean {

    @PostConstruct
    public void postConstruct() {
        System.out.println("PostConstruct 초기화");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("InitializingBean 초기화");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("PreDestroy 정리");
    }

    @Override
    public void destroy() {
        System.out.println("DisposableBean 정리");
    }
}

```
✅ 요약

|단계|설명|
|---|---|
|정의|어떤 클래스를 Bean으로 쓸지 인식 (`@Component`, `@Bean`)|
|생성|객체를 인스턴스화|
|의존성 주입|필요한 다른 Bean 주입|
|초기화|`@PostConstruct`, `afterPropertiesSet()`|
|사용|애플리케이션이 사용|
|소멸|`@PreDestroy`, `destroy()`|

---

##### 프로토타입 빈은 무엇인가요?
Spring에서 **프로토타입(Prototype) 빈**은 **요청할 때마다 새로운 인스턴스를 생성하는 Bean 범위(scope)**입니다.  
기본적으로 Spring Bean은 **싱글톤(Singleton)**으로 관리되지만, 필요에 따라 프로토타입 스코프로 설정할 수 있습니다.

---
 ✅ 1. 프로토타입(Prototype) 빈이란?

- **싱글톤 빈**: 컨테이너 시작 시 1개만 생성, 모든 요청에 동일 객체 반환
    
- **프로토타입 빈**: **`getBean()` 호출 시마다 새 객체 생성**
    
```java
@Component
@Scope("prototype")  // 또는 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyPrototypeBean {
    ...
}

```
 ✅ 2. 특징

| 항목         | 설명                                      |
| ---------- | --------------------------------------- |
| **생성 시점**  | `getBean()` 호출할 때마다 새 인스턴스 생성           |
| **관리 범위**  | 생성 및 의존성 주입까지만 Spring이 관리 (소멸은 직접 해야 함) |
| **재사용 여부** | ❌ 항상 새로 생성됨                             |
| **대표 예시**  | 상태가 독립적인 객체, 임시 계산기, 사용자 세션 단위 객체 등     |

---
✅ 3. 사용 예시

```java
@Component
@Scope("prototype")
public class SessionData {
    private final UUID id = UUID.randomUUID();

    public UUID getId() {
        return id;
    }
}

ApplicationContext context = ...
SessionData s1 = context.getBean(SessionData.class);
SessionData s2 = context.getBean(SessionData.class);
System.out.println(s1 == s2); // false (다른 인스턴스)

```
 ✅ 4. 주의사항

❗ 의존성 주입 시 주의 (싱글톤 → 프로토타입)

- 프로토타입 빈을 싱글톤 빈에서 주입받으면 **초기 1회만 생성됨** (즉, 계속 같은 객체)
    
🔧 해결 방법

1. **`ObjectProvider<T>` 또는 `Provider<T>` 사용**
    
```java
@Component
public class SingletonBean {
    @Autowired
    private ObjectProvider<MyPrototypeBean> provider;

    public void logic() {
        MyPrototypeBean prototype = provider.getObject();
    }
}

```
1. **`@Lookup` 애노테이션**
```java
@Component
public class SingletonBean {
    @Lookup
    public MyPrototypeBean getPrototypeBean() {
        return null; // 런타임에 오버라이딩됨
    }
}

```
✅ 5. 프로토타입 빈의 소멸 처리 주의

- Spring은 **생성까지만 관리**하고 `@PreDestroy` 같은 **소멸 콜백을 호출하지 않습니다.**
    
- 필요한 경우 **직접 종료 처리**해야 함.
    

---
 ✅ 요약

|항목|설명|
|---|---|
|스코프 이름|`"prototype"`|
|생성 시점|매번 요청 시 새 인스턴스|
|용도|상태를 가지는 독립적인 객체 필요할 때|
|단점|소멸 관리 책임이 사용자에게 있음|
|싱글톤과 함께 사용할 때|`ObjectProvider`, `@Lookup` 등으로 해결|

### 12. AOP에 대해 설명해 주세요.
##### 설명
AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)는  
**공통 관심사(Cross-Cutting Concerns)**를 **핵심 로직과 분리하여 모듈화하는 프로그래밍 패러다임**입니다.  
주로 **로깅, 보안, 트랜잭션, 성능 측정, 예외 처리** 같은 기능을 핵심 비즈니스 코드와 분리하기 위해 사용됩니다.

---
 ✅ 왜 AOP가 필요한가요?

**기존 OOP만으로는 공통 기능을 여러 클래스에 반복적으로 작성해야 함**

 ❌ OOP만 사용하는 경우 (중복 발생)

```java
public void placeOrder() {
    log.info("주문 시작"); // 공통 관심사
    ... // 주문 처리 로직
    log.info("주문 완료");
}

```

 ✅ AOP를 사용하는 경우

```java
@Around("execution(* com.myapp.service.*.*(..))")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    log.info("메서드 시작");
    Object result = joinPoint.proceed();
    log.info("메서드 끝");
    return result;
}

```
→ 핵심 로직은 그대로 유지되며, **공통 기능은 분리된 AOP 모듈로 관리**

---
 ✅ 핵심 개념

| 용어             | 설명                                           |
| -------------- | -------------------------------------------- |
| **Aspect**     | 공통 관심사를 모듈화한 클래스 (`@Aspect`)                 |
| **Join Point** | Aspect가 적용 가능한 지점 (ex. 메서드 호출 시점)            |
| **Advice**     | Join Point에서 수행될 코드 (실제 실행 로직)               |
| **Pointcut**   | Advice를 적용할 Join Point를 선정하는 표현식             |
| **Weaving**    | Aspect를 실제 코드에 적용하는 과정 (컴파일/런타임/클래스 로딩 시점 등) |

---
 ✅ Advice 종류

|타입|설명|
|---|---|
|`@Before`|메서드 실행 **전** 실행|
|`@After`|메서드 실행 **후(무조건)** 실행|
|`@AfterReturning`|메서드가 **정상 종료**되었을 때 실행|
|`@AfterThrowing`|**예외 발생** 시 실행|
|`@Around`|메서드 **전후** 모두 처리 가능 (`joinPoint.proceed()`로 핵심 로직 호출)|

---
 ✅ Spring AOP vs AspectJ

|구분|설명|
|---|---|
|**Spring AOP**|프록시 기반, 메서드 단위만 지원, DI 환경에 통합|
|**AspectJ**|바이트코드 조작 기반, 더 정밀한 weaving 가능, 독립 사용 가능|

 ✅ 요약

|항목|설명|
|---|---|
|정의|공통 관심사를 모듈화하여 핵심 로직과 분리하는 기법|
|장점|코드 중복 제거, 관심사 분리, 유지보수 용이|
|사용 사례|트랜잭션, 로깅, 보안, 캐싱, 예외 처리|
|핵심 개념|Aspect, JoinPoint, Advice, Pointcut, Weaving|
|Spring AOP|프록시 기반, 런타임에 적용됨|
##### @Aspect는 어떻게 동작하나요?
좋은 질문입니다.  
`@Aspect`는 **Spring AOP에서 공통 관심사를 구현하는 핵심 어노테이션**입니다.  
이 어노테이션이 어떻게 동작하는지 이해하려면, **프록시 기반의 AOP 처리 방식**과 **스프링 컨테이너 내부 처리 흐름**을 함께 살펴봐야 합니다.

---
✅ 핵심 요약:

`@Aspect`가 붙은 클래스는 **Spring이 자동으로 프록시 객체를 만들어**,  
**지정한 Pointcut에 Advice를 삽입**하는 방식으로 동작합니다.

---
 ✅ 동작 흐름 요약 (Spring AOP)

1. **`@Aspect` 클래스 스캔**
    
    - `@EnableAspectJAutoProxy` 또는 Spring Boot의 자동 설정에 의해,
        
    - `@Aspect`가 붙은 클래스를 **빈으로 등록**하고 AOP 대상으로 인식함
        
2. **Pointcut 분석**
    
    - `execution(...)`, `within(...)`, `@annotation(...)` 등의 표현식을 분석해,
        
    - 어떤 **JoinPoint(=대상 메서드)**에 Advice를 적용할지 결정
        
3. **프록시 생성**
    
    - 대상 객체(Bean)에 대한 **프록시(Proxy) 객체**를 생성
        
        - **인터페이스 기반**이면 → JDK 동적 프록시
            
        - **클래스 기반**이면 → CGLIB 프록시
            
4. **Advice 연결**
    
    - 프록시 객체의 메서드가 호출되면,
        
    - 설정한 Pointcut 조건에 맞는 Advice(`@Before`, `@After`, `@Around` 등)가 **실행 순서에 따라 호출**됨
        
    - 이후 **원래 메서드 호출** (`joinPoint.proceed()`)
        

---
 ✅ 그림으로 이해 (예시: `@Around`)
```
[Client Code] 
    ↓
[프록시 객체]
    ↓  (1) @Before
    ↓  (2) @Around (joinPoint.proceed())
    ↓  (3) 원래 Bean의 메서드 실행
    ↑  (4) @AfterReturning 또는 @AfterThrowing
    ↑  (5) @After

```
 ✅ 예제 코드
```java
@Aspect
@Component
public class LoggingAspect {

    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Before: " + joinPoint.getSignature());
        Object result = joinPoint.proceed(); // 실제 메서드 호출
        System.out.println("After: " + joinPoint.getSignature());
        return result;
    }
}

```
 ✅ 주의할 점

|항목|주의 내용|
|---|---|
|**private 메서드에는 적용 안 됨**|프록시 기반이므로 public 메서드만 가능|
|**자기 자신 내부 호출에는 적용 안 됨**|this 내부 호출은 프록시 우회 → AOP 안 먹힘|
|**final 클래스/메서드는 제한 있음**|CGLIB은 final 메서드 오버라이딩 불가|
|**빈으로 등록되어야 동작**|`@Component` 또는 `@Bean`으로 등록 필요|

---
 ✅ 요약

|항목|설명|
|---|---|
|`@Aspect`란?|공통 관심사를 모듈화한 클래스 정의용 어노테이션|
|동작 방식|Spring이 프록시 객체를 만들어 Advice를 삽입|
|핵심 기술|JDK Proxy 또는 CGLIB, `@EnableAspectJAutoProxy`|
|트리거 시점|Pointcut으로 지정한 JoinPoint가 호출될 때|
|주의사항|프록시 기반 특성: 자기 호출, private, final 등 제한|


### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview

### 12. AOP에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#12-aop%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)
### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview