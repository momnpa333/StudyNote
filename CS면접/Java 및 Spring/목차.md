### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
##### 설명
JVM(Java Virtual Machine)은 **자바 프로그램이 실행되는 가상화된 실행 환경**으로, 자바뿐만 아니라 Kotlin, Scala 등 JVM 기반 언어로 작성된 프로그램이 동작할 수 있도록 설계된 **추상 컴퓨터(virtual machine)**입니다.

**JVM의 주요 역할**

1. **바이트코드 실행**
    
    - 자바 소스코드(`.java`)는 컴파일러(`javac`)를 통해 **바이트코드(`.class`)**로 변환됩니다.
        
    - JVM은 이 바이트코드를 해석(인터프리트)하거나 **JIT(Just-In-Time) 컴파일러**를 통해 네이티브 머신 코드로 변환하여 실행합니다.
        
2. **운영체제 독립성 제공**
    
    - 자바의 **“Write Once, Run Anywhere”** 철학을 가능하게 하는 핵심 요소입니다.
        
    - 한 번 컴파일된 바이트코드는 JVM이 설치된 어떤 OS나 하드웨어 환경에서도 동일하게 실행됩니다.
        
3. **메모리 관리 (Garbage Collection)**
    
    - JVM은 프로그램에서 사용되는 메모리를 **힙(Heap)**과 **스택(Stack)** 영역으로 관리합니다.
        
    - 사용이 끝난 객체를 자동으로 회수하는 **Garbage Collector(GC)**를 내장하고 있어 메모리 누수를 줄입니다.
        
4. **보안 및 예외 처리**
    
    - 바이트코드 검증(Bytecode Verifier)을 통해 악성 코드 실행을 방지합니다.
        
    - 예외(Exception) 처리 메커니즘을 제공하여 안정적인 실행을 지원합니다.
        
5. **런타임 환경 제공**
    
    - 클래스 로딩(Class Loader), 실행 엔진(Execution Engine), 네이티브 인터페이스(JNI) 등을 통해 애플리케이션 실행에 필요한 런타임 환경을 제공합니다.
        

---
**JVM의 구조**

1. **클래스 로더(Class Loader)**
    
    - `.class` 파일을 메모리로 로드하고, 링크(Linking)와 초기화를 수행합니다.
        
2. **런타임 데이터 영역(Runtime Data Areas)**
    
    - **메서드 영역(Method Area):** 클래스 메타데이터, 정적 변수, 상수 풀 저장.
        
    - **힙(Heap):** 객체가 저장되는 영역, GC의 관리 대상.
        
    - **스택(Stack):** 메서드 호출 시 생성되는 프레임을 저장.
        
    - **PC 레지스터:** 현재 실행 중인 명령어의 주소 저장.
        
    - **네이티브 메서드 스택:** JNI 호출 시 사용.
        
3. **실행 엔진(Execution Engine)**
    
    - **인터프리터:** 바이트코드를 한 줄씩 해석 실행.
        
    - **JIT 컴파일러:** 자주 실행되는 코드를 네이티브 코드로 변환해 성능 향상.
        
    - **Garbage Collector:** 메모리 관리 자동화.
        

---
**정리**

JVM은 **자바 프로그램을 하드웨어와 OS에 독립적으로 실행할 수 있게 하는 가상 컴퓨터**이자, **메모리 관리와 보안을 책임지는 런타임 환경**입니다.  
만약 JVM이 없다면, 자바 프로그램은 현재처럼 다양한 플랫폼에서 동일하게 실행될 수 없습니다.
##### 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
✅ JVM 위에서 실행 가능한 다른 언어들

|언어|특징|
|---|---|
|**Kotlin**|JetBrains에서 개발, 자바와 100% 상호운용 가능. Android 공식 언어.|
|**Scala**|함수형 + 객체지향, 고급 언어 기능. Spark의 주요 언어.|
|**Groovy**|자바 문법 기반의 동적 스크립트 언어, Gradle에 사용됨.|
|**Clojure**|함수형, Lisp 계열 언어. 불변성과 병렬처리 강조.|
|**JRuby**|Ruby를 JVM에서 실행할 수 있게 만든 구현체.|
|**Jython**|Python 2.x 문법을 JVM 위에서 실행 가능. (현재는 거의 사용 안 됨)|
|**Ceylon, Fantom, Frege, Xtend 등**|JVM 기반으로 개발된 다양한 실험적 언어들|

---

🧠 왜 다른 언어들도 JVM 위에서 실행 가능한가요?

JVM은 자바에 특화된 것이 아니라 **“바이트코드”라는 중간 표현을 실행**하는 구조입니다.  
즉, 자바가 아닌 언어도 **“JVM 바이트코드로 컴파일”만 하면** JVM에서 실행할 수 있습니다.

🧩 장점

- **운영체제 독립성**: 어떤 언어든 JVM 위에서 돌아가면 플랫폼 독립성 확보.
    
- **기존 Java 생태계 활용**: Java 라이브러리, 프레임워크 사용 가능.
    
- **성능**: JVM의 JIT 컴파일러, GC 등을 그대로 활용.
    

⚠️ 단점

- **자바 중심 최적화**: JVM은 기본적으로 자바 스타일 코드에 최적화됨.
    
- **언어 특성 제한**: 언어 고유 기능을 JVM이 지원하지 않을 수 있음.
    
- **바이트코드 제약**: 일부 언어 표현은 JVM 바이트코드로 변환하기 까다로움.
    
✅ 결론

> JVM은 **자바 전용이 아닙니다.**  
> **“JVM 바이트코드로 컴파일될 수 있는 언어라면 모두 실행 가능합니다.”**

자바 외에도 Kotlin, Scala, Groovy처럼 **JVM 생태계의 장점을 공유하며 성장한 언어들**이 존재합니다.
##### 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
##### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
##### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
##### 설명:
`final` 키워드는 **자바에서 불변성(immutability) 또는 변경 불가능성을 보장하는 데 사용**됩니다. 상황에 따라 클래스, 메서드, 변수에 붙을 수 있으며, 각각 다른 의미와 장점이 있습니다.

---

**1. `final`의 사용 대상과 의미**

 **(1) 변수에 사용**

- **의미:** 변수의 값을 한 번만 할당할 수 있도록 제한합니다.
    
    - **기본 타입:** 값 자체가 변경 불가.
        
    - **참조 타입:** 객체의 참조 주소가 변경 불가(하지만 객체 내부 상태는 변경될 수 있음).
**(2) 메서드에 사용**

- **의미:** 메서드를 오버라이드(override)할 수 없습니다.
    
- **예시:**
    
```java
class Parent {
    public final void show() {
        System.out.println("Can't override me");
    }
}
class Child extends Parent {
    // @Override
    // public void show() { } // 컴파일 에러

```
 **(3) 클래스에 사용**

- **의미:** 상속할 수 없는 클래스가 됩니다.
    
- **예시:**  
    `java.lang.String`, `java.lang.Math` 클래스는 `final`로 선언되어 상속 불가.
    
 **2. `final` 키워드의 장점**
 **(1) 코드 안정성 확보**

- 변수 값을 실수로 변경하거나 상속/오버라이딩으로 인한 예기치 못한 동작을 방지할 수 있습니다.
    
**(2) 불변 객체(Immutable Object) 구현**

- `final`을 멤버 변수에 적용하고 setter를 제거하면 **스레드 안전(Thread-Safety)** 한 객체를 만들 수 있습니다.
    
- 예: `String` 클래스가 `final`이기 때문에 불변성을 보장하고 멀티스레드 환경에서 안전합니다.
    
**(3) 성능 최적화 (JVM 최적화 힌트)**

- `final` 메서드는 오버라이드가 불가능하므로, **JVM JIT 컴파일러가 인라이닝(inlining)** 최적화를 쉽게 적용할 수 있습니다.
    
- 상속 관계에서 메서드 호출 시 발생하는 **동적 디스패치 비용**을 줄일 수 있습니다.
    
 **(4) 설계 의도 명확화**

- 특정 클래스나 메서드가 확장되거나 변경되지 않기를 원할 때 `final`을 명시적으로 사용하면, 코드의 의도를 분명히 할 수 있습니다.
    

---
3. `final`의 한계**

- 불필요하게 `final`을 남발하면 테스트나 확장성이 떨어질 수 있습니다.  
    (예: 모든 메서드를 `final`로 만들면 상속 기반 구조에 제약 발생)
    
- 참조 타입의 `final`은 객체 내부 상태까지 불변하게 만들지는 않기 때문에, **진정한 불변 객체를 위해서는 별도 설계(Immutable Pattern)** 가 필요합니다.
    

 **정리**

> `final`은 **“변경 불가능성”을 보장하여 안정성과 최적화를 돕는 키워드**입니다.  
> 특히 불변 객체 설계와 성능 최적화에서 중요한 역할을 하며, 코드의 의도를 명확히 전달할 수 있습니다.
##### 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
네, **`final` 키워드는 컴파일 과정에서 일반 변수나 메서드와 다르게 취급됩니다.**  
컴파일러와 JVM은 `final`이 붙은 요소가 **절대 변하지 않는다는 사실을 알고 최적화**할 수 있기 때문입니다.

---
**1. `final` 변수의 컴파일 과정**

- **`final` 상수(`static final`)는 컴파일 타임 상수로 취급**됩니다.
```java
public class Test {
    public static final int CONST = 10;
}

    
```
        
    다른 클래스에서 `Test.CONST`를 참조하면, **컴파일 시 값 `10`으로 대체(inline)** 됩니다.
        
- **`final` 지역 변수나 필드도 컴파일러가 “절대 재할당 불가”라는 사실을 알기 때문에 상수 취급**하며, 인라이닝이나 값 추론(Constant Folding) 같은 최적화가 가능합니다.
    

---
**2. `final` 메서드의 컴파일 과정**

- 메서드에 `final`이 붙으면 **JVM은 동적 디스패치(virtual method table lookup)를 거치지 않고 직접 호출**할 수 있습니다.
    
- 보통 오버라이드 가능한 메서드는 실행 시점에 **가상 메서드 테이블(V-Table)** 을 통해 어떤 구현을 호출할지 결정합니다.
        
 - 하지만 `final` 메서드는 **오버라이드가 불가능하므로 호출 대상이 컴파일 시점에 확정**, 호출 비용을 줄일 수 있습니다.
        
  - JIT 컴파일러가 `final` 메서드를 인라인으로 변환하기가 훨씬 수월합니다.
        

---
**3. `final` 클래스의 컴파일 과정**

- 클래스가 `final`이면 상속이 불가능하기 때문에, **JVM이 메서드 호출 시 “다형성 검사”를 생략**할 수 있습니다.
    
- 예를 들어, `String`은 `final`이기 때문에 `"abc".substring(1)` 호출 시 **항상 `String`의 `substring()` 메서드를 직접 실행**하도록 최적화할 수 있습니다.
    

---
 **4. JIT 컴파일러 관점에서의 최적화**

- 런타임 시 JIT(Just-In-Time) 컴파일러는 `final` 키워드를 확인하고:
    
    - **상수 값 인라이닝** (예: `final int x = 10;` → 직접 10으로 대체)
        
    - **메서드 인라이닝** (함수 호출을 제거하고 코드 삽입)
        
    - **Dead Code 제거** (변하지 않는 값 기반의 코드 최적화)  
        를 적용할 수 있습니다.
        

---
 **정리**

- 컴파일러는 `final` 키워드를 통해 **“변하지 않음”을 보장받아 더 강력한 최적화를 수행**합니다.
    
- 특히 `static final` 상수는 **컴파일 타임에 값이 확정**되어 다른 클래스에서 **직접 값이 삽입(inline)**됩니다.
    
- `final` 메서드는 **가상 메서드 호출 비용을 제거하고 인라이닝 최적화를 가능**하게 합니다.

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
##### 설명
**1. 공통점**

- **인스턴스화 불가:** 둘 다 직접 객체를 생성할 수 없습니다.
- **추상 메서드 포함 가능:** 구현을 강제할 수 있습니다.
- **다형성 제공:** 부모 타입(인터페이스/추상 클래스)으로 자식 객체를 참조할 수 있습니다.
    

---
 **2. 차이점 비교**

|구분|인터페이스 (Interface)|추상 클래스 (Abstract Class)|
|---|---|---|
|**목적**|**기능(행동)의 약속**: “이런 기능을 제공하겠다”는 규격 제공|**공통된 속성과 동작의 공유**: 상속받는 클래스에 **기본 구현** 제공|
|**메서드**|기본적으로 **추상 메서드만 선언 가능** (Java 8 이후 `default`, `static` 메서드 허용)|**추상 메서드 + 일반 메서드(구현 포함)** 모두 가능|
|**필드**|**`public static final` (상수)만 선언 가능**|**인스턴스 변수(상태) 선언 가능**|
|**상속**|**다중 구현 허용** (클래스는 여러 인터페이스를 구현 가능)|**단일 상속만 허용**|
|**접근 제어자**|메서드는 암묵적으로 `public abstract` (default/static 제외)|`public`, `protected`, `private` 자유롭게 사용 가능|
|**생성자**|없음|생성자 가질 수 있음|
|**상속 키워드**|`implements` 사용|`extends` 사용|

---
 **3. 사용 예시**

### **인터페이스 예시**

```java
interface Flyable {
    void fly();  // 추상 메서드
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

```

- **의미:** “날 수 있다”라는 기능을 약속.
    
- `Flyable`을 구현하는 모든 클래스는 반드시 `fly()`를 구현해야 합니다.
    

추상 클래스 예시**
```java
abstract class Animal {
    String name;

    abstract void makeSound();  // 추상 메서드

    void eat() {                // 일반 메서드
        System.out.println(name + " is eating");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

```
- **의미:** `Animal`은 공통 속성(`name`)과 공통 동작(`eat()`)을 제공하고, `makeSound()`는 서브클래스가 구현하도록 강제합니다.
    

---
**4. 언제 사용해야 할까?**

- **인터페이스**:
    
    - **“~할 수 있다”**(Can do) 같은 **기능의 명세**를 정의할 때.
        
    - 서로 다른 클래스들이 동일한 행동을 보장해야 할 때 (예: `Comparable`, `Runnable`).
        
    - 다중 상속(여러 동작 인터페이스 구현)이 필요할 때.
        
- **추상 클래스**:
    
    - **공통된 속성(필드)과 기본 동작(메서드)을 공유**해야 할 때.
        
    - 클래스 계층구조에서 **코드 재사용**이 필요한 경우.
        

---

**5. Java 8 이후의 변화**

- 인터페이스에서도 `default` 메서드를 정의하여 **기본 구현을 제공**할 수 있게 되었고,  
    추상 클래스와의 차이가 줄어들었지만 **“상태(필드)”를 가질 수 없다는 점**에서 여전히 차이가 존재합니다.
    

---
 **정리**

> **인터페이스**는 **“무엇을 할 수 있는가(기능의 약속)”**,  
> **추상 클래스**는 **“무엇을 가지고 있고, 기본적으로 어떻게 동작하는가(공통 구현)”**를 제공하는 데 초점을 둡니다.
##### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
그 이유는 **언어 설계 철학과 다중 상속의 문제점**에서 비롯됩니다.

 **1. 클래스 다중 상속의 문제점**

클래스는 **상태(필드)**와 **행동(메서드 구현)**을 모두 포함할 수 있기 때문에, 다중 상속 시 **모호성(Ambiguity)** 문제가 발생합니다.

 **대표적인 다이아몬드 문제 (Diamond Problem)**
```java
class A {
    void hello() { System.out.println("Hello from A"); }
}

class B extends A {
    void hello() { System.out.println("Hello from B"); }
}

class C extends A {
    void hello() { System.out.println("Hello from C"); }
}

// 다중 상속이 가능하다고 가정
class D extends B, C {
    // D.hello() 호출 시, B와 C 중 어느 hello()를 써야 할까?
}

```

- `D`가 `B`와 `C`를 동시에 상속하면 **같은 메서드 시그니처를 가진 `hello()`가 2개 생기므로 호출 우선순위가 모호**해집니다.
    
- 이 모호성을 해결하려면 언어 차원에서 복잡한 규칙(예: C++의 가상 상속)을 도입해야 하는데, **자바는 단순성과 명확성을 위해 클래스 다중 상속을 금지**했습니다.
    

---
**2. 인터페이스는 상태를 가지지 않기 때문**

- 인터페이스는 **필드를 가질 수 없고(상수 `public static final`만 가능)**, 기본적으로 **메서드의 구현을 포함하지 않습니다**(Java 8 이전).
    
- 즉, **상태 충돌 문제**가 발생하지 않습니다.
    
- 다중 구현을 하더라도 **충돌하는 데이터 필드나 상속 체계 모호성**이 없기 때문에 안전하게 허용됩니다.
    

---

**3. Java 8 이후 default 메서드가 생겼는데 왜 여전히 다중 구현이 가능할까?**

- Java 8부터 인터페이스에 `default` 메서드가 생기면서 메서드 구현이 가능해졌지만,  
    **메서드 충돌이 발생하면 반드시 구현 클래스에서 오버라이딩(재정의)하여 해결해야 한다는 규칙**이 추가되었습니다.
    
```java
interface A { default void hello() { System.out.println("A"); } }
interface B { default void hello() { System.out.println("B"); } }

class C implements A, B {
    @Override
    public void hello() {  // 충돌 해결
        A.super.hello();   // 명시적으로 A의 hello 호출
    }
}

    
```
    
    이렇게 **명시적으로 어느 인터페이스의 메서드를 사용할지 지정**할 수 있어 충돌 문제가 해결됩니다.
    

---
 **4. 결론**

- **클래스:** 상태와 구현을 포함하므로 다중 상속 시 모호성과 충돌 문제가 발생 → **단일 상속만 허용.**
    
- **인터페이스:** 상태를 가지지 않고 **행동(계약)만 정의**하기 때문에 충돌 위험이 없음 → **다중 구현 가능.**
    
- **Java 8 이후에도 다중 구현 충돌은 `super` 키워드로 명시적으로 해결하도록 규칙화** → 안전하게 다중 인터페이스 구현 유지 가능.

### 4. 리플렉션에 대해 설명해 주세요.
##### 설명
**리플렉션(Reflection)**은 **런타임(runtime)에 클래스나 객체의 메타데이터(클래스 정보, 메서드, 필드 등)를 동적으로 조사하고 조작할 수 있는 기능**을 말합니다.  
즉, **코드가 실행 중에 자기 자신을 들여다보고 수정할 수 있게 해주는 메커니즘**입니다.

---
**1. 리플렉션의 특징**

- **컴파일 타임이 아닌 런타임에 클래스 정보를 다룸.**
    
- 객체의 **클래스 이름, 메서드 목록, 필드, 생성자** 등에 접근 가능.
    
- 접근 제어자(`private`, `protected`)를 무시하고 필드/메서드에 접근할 수 있음 (`setAccessible(true)`).
    
- 동적으로 객체를 생성하거나 메서드를 호출할 수 있음.
    

---
 **2. 리플렉션의 주요 사용 예**
```java
Class<?> clazz = Class.forName("com.example.MyClass");  // 클래스 로드

// 객체 생성
Object obj = clazz.getDeclaredConstructor().newInstance();

// 메서드 호출
Method method = clazz.getDeclaredMethod("sayHello");
method.invoke(obj);

// 필드 접근
Field field = clazz.getDeclaredField("name");
field.setAccessible(true);
field.set(obj, "Reflection Test");

```

---
3. 리플렉션의 장점**
	1. **유연한 동적 처리**
	    
	    - 실행 시점에 클래스 이름만 알고 있어도 동작 가능.
	        
	    - 예: JDBC 드라이버 로딩(`Class.forName("com.mysql.jdbc.Driver")`).
	        
	2. **프레임워크와 라이브러리 구현에 필수적**
	    
	    - 스프링(Spring)의 DI(의존성 주입), JPA 엔티티 매핑, Jackson JSON 직렬화 등 대부분의 자바 프레임워크는 리플렉션을 사용.
	        
	3. **일반 코드로는 접근 불가능한 정보 활용 가능**
	    
	    - `private` 필드나 메서드를 런타임에 강제로 접근 가능.
        

---
**4. 리플렉션의 단점**

1. **성능 저하**
    
    - 메서드 호출 시 직접 호출보다 **약 20배 이상 느릴 수 있음**(런타임 검사 및 메타데이터 탐색 비용).
        
2. **컴파일 타임 타입 체크 불가**
    
    - 리플렉션을 잘못 사용하면 런타임에 `NoSuchMethodException`, `IllegalAccessException` 등 에러가 발생할 수 있음.
        
3. **캡슐화 위반**
    
    - `private` 멤버에 강제 접근할 수 있어 객체지향 설계를 깨뜨릴 수 있음.
        

---
5. 리플렉션이 많이 쓰이는 곳**

- **프레임워크/라이브러리 내부**  
    (Spring, Hibernate, Jackson, JUnit)  
    → 컴파일 시점에 타입을 몰라도 객체 생성, 메서드 실행, 의존성 주입 등을 해야 하므로 필수적.
    
- **어노테이션 처리**  
    예: `@Autowired`, `@Entity` 같은 어노테이션의 메타데이터를 리플렉션으로 읽어 동작.
    
- **런타임 플러그인/모듈 로딩**  
    → 특정 클래스나 메서드를 동적으로 로딩하고 실행할 때 사용.
    

---
**6. 결론**

> **리플렉션은 런타임에 프로그램 구조를 조작할 수 있는 강력한 도구이지만, 성능 저하와 캡슐화 파괴 가능성이 있으므로 필요한 경우에만 신중히 사용하는 것이 권장됩니다.**
##### 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
맞습니다. **리플렉션은 보안적인 문제를 일으킬 가능성이 있습니다.**  
리플렉션은 `private` 필드나 메서드에도 접근할 수 있기 때문에, 원래 의도한 **캡슐화(encapsulation)**를 깨뜨리고, 잘못 사용되면 **보안 취약점**으로 이어질 수 있습니다.

---
1. 리플렉션의 보안 문제 사례**

2. **`private` 필드 접근**
```java
Field field = SomeClass.class.getDeclaredField("password");
field.setAccessible(true);  // 접근 제한 해제
String pwd = (String) field.get(obj);

    
```
    원래 외부에서 접근할 수 없는 비밀번호 필드에 접근할 수 있습니다.
    
3. **불법적인 메서드 호출**
    
    - 접근 불가한 메서드(예: 관리자 전용 메서드)를 `invoke()`로 호출 가능.
        
4. **클래스 로딩 시 악성 코드 주입**
    
    - `Class.forName("com.hacker.MaliciousClass")` 로 동적 로딩 가능.  
        만약 외부 입력을 그대로 클래스명으로 사용할 경우, 공격자가 의도한 클래스가 실행될 수 있습니다.
        
5. **시스템 클래스 변조**
    
    - `java.lang.reflect` 패키지를 이용하면 JDK 내부 클래스나 필드를 조작할 수 있어 예기치 못한 동작을 유발할 수 있습니다.
        

---
2. 보안 문제를 방지하는 방법**
(1) SecurityManager (자바 17 이전)**
하지만 자바 17부터 `SecurityManager`는 **Deprecated** 되었으므로 대체 수단이 필요합니다.
    

**(2) 모듈 시스템 (Java 9+)**

- Java 9부터 도입된 **모듈 시스템(Jigsaw)** 을 사용하면 **모듈 간 리플렉션 접근을 제한**할 수 있습니다.
```java
module my.module {
    exports com.myapp;
    opens com.myapp.internal to specific.module; // 제한적 리플렉션 허용
}

```
**(3) 클래스 로딩 시 화이트리스트 검증**

- `Class.forName()` 등을 사용할 때 **외부 입력값을 그대로 사용하지 않고**, 허용된 클래스 목록(화이트리스트)을 확인해야 합니다.
    
(4) `setAccessible(true)` 최소화**

- 꼭 필요한 경우에만 사용하고, 라이브러리에서 남용하지 않도록 주의해야 합니다.
    
- Java 9 이상에서는 `setAccessible(true)` 호출 시 **권한 제한 경고**가 발생하며, `--illegal-access=deny` 옵션으로 차단할 수 있습니다.
    
 **(5) 보안 정책 파일 (policy file) 설정**

- 권한이 필요한 코드 영역에 대해 `ReflectPermission`을 제한하는 보안 정책을 설정할 수 있습니다.
    
 **3. 실제 보안적 관점에서의 판단**

- **일반 애플리케이션 코드에서 리플렉션을 남용하는 것은 권장되지 않습니다.**
    
- 하지만 **프레임워크나 라이브러리 수준에서는 필수적**입니다. (예: 스프링 DI, Hibernate 엔티티 매핑)
    
- **보안적으로 민감한 객체(암호키, 인증정보 등)는 리플렉션 접근 방지를 위한 설계(예: SecurityManager 대체 수단, final 클래스, 모듈화)와 정책이 필요**합니다.
    
 **4. 결론**

> 리플렉션은 **강력하지만 위험할 수 있는 도구**입니다.  
> 보안적으로 민감한 시스템에서는 **모듈화, 접근 제어, 화이트리스트 검증, 권한 정책** 등을 조합하여 사용을 제한해야 합니다.
##### 리플렉션을 언제 활용할 수 있을까요?
리플렉션(Reflection)은 **일반적인 애플리케이션 코드에서 매번 사용하는 도구는 아니지만**, **동적인 동작**이나 **프레임워크/라이브러리 개발** 시 매우 유용하게 활용됩니다.

다음은 **리플렉션을 사용하기 적합한 주요 상황**입니다.

---
**1. 컴파일 시점에 타입을 알 수 없는 경우**

- 런타임에 클래스나 메서드 이름이 결정되는 경우 유용합니다.
    
```java
// 클래스 이름을 문자열로만 알고 있는 상황
Class<?> clazz = Class.forName("com.example.MyClass");
Object obj = clazz.getDeclaredConstructor().newInstance();
 
```
- **활용 예:**
    - 플러그인 시스템 (외부에서 로딩되는 모듈 실행)
    - 런타임에 입력받은 클래스명/메서드명을 기반으로 동적 호출
        

---
 **2. 프레임워크 및 라이브러리 내부**

- **Spring**, **Hibernate**, **JUnit**, **Jackson** 등 수많은 자바 프레임워크는 리플렉션을 핵심적으로 활용합니다.
    
    - **Spring DI (의존성 주입)**:  
        `@Autowired` 필드를 리플렉션으로 찾아서 객체를 주입.
        
    - **Hibernate/JPA**:  
        엔티티 클래스의 필드 정보를 리플렉션으로 읽어 DB 컬럼과 매핑.
        
    - **JUnit**:  
        테스트 메서드(`@Test`)를 런타임에 찾아 자동 실행.
        
    - **Jackson/Gson**:  
        클래스 필드/Getter를 리플렉션으로 찾아 JSON 직렬화/역직렬화.
        

---
 **3. 어노테이션(Annotation) 기반 처리**

- 어노테이션 정보를 런타임에 읽어 동작을 제어할 때 사용됩니다.
    
```java
Method method = clazz.getDeclaredMethod("myMethod");
if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
    // 어노테이션이 붙은 메서드만 실행
    method.invoke(obj);
}

```

---
4. 직렬화/역직렬화 및 매핑**

- **객체 → JSON** 또는 **JSON → 객체** 변환 시 리플렉션으로 필드를 탐색하고 값 할당.
    
- **ORM(Object Relational Mapping)** 프레임워크가 DB 테이블과 클래스 필드를 매핑할 때 사용.
    

---
**5. 디버깅, 로깅, 테스트**

- 테스트 코드에서 **비공개 필드(`private`)에 접근**해 상태를 확인할 때.
    
- 런타임에 객체의 구조를 확인하여 **자동 로깅**이나 **디버깅 도구**를 만들 때.
    

---
**6. 유연한 API 설계**

- 클래스 구조가 변경되더라도, 리플렉션을 통해 **필드명/메서드명을 문자열로 참조**하면 코드 수정 없이 동작할 수 있습니다.
    
    - 예: **스프링 BeanFactory**가 Bean을 문자열 이름으로 찾아 인스턴스화.
        

 **정리**

리플렉션은 **정적 타입 시스템으로는 불가능한 동적 동작**을 가능하게 해주는 도구입니다.  
특히 **프레임워크, ORM, 어노테이션 기반 라이브러리**에서 핵심 역할을 하며, **런타임에 타입을 모르는 상황에서 객체를 생성하거나 메서드를 호출할 때** 유용합니다.
### 5. static class와 static method를 비교해 주세요.
##### 설명
`static class`와 `static method`는 **static 키워드를 클래스와 메서드에 적용한 것**이지만, 의미와 용도가 완전히 다릅니다.

---
1. static method (정적 메서드)**
**특징**

- **클래스 레벨에서 동작**하며, 인스턴스 생성 없이 호출 가능.
    
- `this` 키워드를 사용할 수 없음 (인스턴스 변수 접근 불가).
    
- 클래스 로딩 시 메모리에 올라가며, 공유 자원 역할을 함.
    
- **객체 상태와 관계없는 기능(유틸리티 메서드)**에 적합.
    
**예시**

```java
class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }
}

int sum = MathUtil.add(5, 10);  // 객체 생성 없이 호출

```
 **2. static class (정적 클래스)**

자바에서 **클래스 자체에 `static`을 붙일 수는 없습니다.**  
다만, **“static 중첩 클래스(Static Nested Class)”**를 만들 수 있습니다.

 **특징**

- 외부 클래스의 인스턴스에 **종속되지 않는 중첩 클래스**를 의미.
    
- 외부 클래스의 `static` 멤버만 접근 가능 (`non-static` 멤버 접근 불가).
    
- **독립적인 클래스처럼 사용 가능**하여, 외부 클래스 객체 없이 인스턴스화할 수 있습니다.
    
 **예시**

```java
class Outer {
    static class Inner {  // Static Nested Class
        void print() {
            System.out.println("Static nested class");
        }
    }
}

Outer.Inner inner = new Outer.Inner();  // Outer 객체 없이 생성 가능

```

---
**3. 비교 요약**

|구분|**static method**|**static class (중첩 클래스)**|
|---|---|---|
|**적용 대상**|메서드|중첩 클래스(Inner Class)|
|**호출/생성**|클래스 이름으로 직접 호출 가능 (`ClassName.method()`)|외부 클래스 객체 없이 `new Outer.Inner()` 로 생성 가능|
|**목적**|객체 상태와 무관한 **공통 동작 제공**|외부 클래스와 **논리적으로 묶인 클래스**를 독립적으로 사용|
|**this 사용**|불가능|자기 자신에 대한 `this`는 가능|
|**메모리 관리**|클래스 로딩 시 메서드가 메모리에 올라감|외부 클래스 인스턴스와 관계없이 별도로 로딩|

---
 **4. 결론**

- **`static method`는 클래스에 귀속된 함수**이며, 주로 **유틸리티성 메서드**에서 사용됩니다.
    
- **`static class`는 독립적으로 사용할 수 있는 중첩 클래스**로, 외부 클래스의 인스턴스와 무관하게 사용하고자 할 때 유용합니다.

##### static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
`static` 키워드는 **클래스 레벨의 멤버(변수, 메서드, 내부 클래스)를 정의**할 때 사용됩니다.  
이는 **인스턴스와 독립적으로 동작**하게 만들며, **메모리 관리나 호출 방식에서 장점**을 제공합니다. 하지만 동시에 몇 가지 **제약**도 따릅니다.

---
1. static의 주요 이점**
**(1) 인스턴스 생성 없이 접근 가능**

- `static` 멤버는 클래스 로딩 시 메모리에 올라가므로 **객체를 생성하지 않아도 바로 접근**할 수 있습니다.
    
 **(2) 공용 데이터(Shared Data) 관리**

- 모든 인스턴스가 **같은 static 변수**를 공유하므로 **공용 상태를 유지**할 수 있습니다.
    
    `class Counter {     static int count = 0;     Counter() { count++; } } // 모든 Counter 객체가 count를 공유`
    

**(3) 유틸리티 클래스 구현에 유용**

- 상태가 필요 없는 메서드를 묶어서 제공할 때 적합합니다.
    
- 예: `Math`, `Collections`, `Arrays` 클래스.
    
 **(4) 메모리 절약**

- **인스턴스마다 복제되지 않고, 클래스당 하나만 로딩**되므로 메모리 사용량을 줄일 수 있습니다.
    

---
 **2. static의 주요 제약**
 **(1) 인스턴스 변수나 메서드에 접근 불가**

- `static` 메서드는 **객체(인스턴스)의 상태를 알 수 없으므로** `this` 키워드를 사용할 수 없습니다.
    
 **(2) 오버라이딩(Overriding) 불가**

- `static` 메서드는 클래스 레벨에 속하므로 **상속 시 재정의(Overriding)가 불가능**합니다.
    
    - 단, **"메서드 숨김(Method Hiding)"** 형태로 같은 시그니처의 static 메서드를 선언할 수는 있습니다.
        
 **(3) 다형성(Polymorphism) 활용 불가**

- 인스턴스 메서드는 런타임에 동적 바인딩되지만, `static` 메서드는 **컴파일 시점에 정적으로 바인딩**됩니다.
    
 **(4) 가비지 컬렉션(GC) 대상 아님**

- 클래스가 언로드될 때까지 메모리에 상주하므로, 메모리 누수가 발생할 가능성이 있습니다(특히 큰 객체를 static 변수로 유지할 때).
    
 **(5) 동시성 문제**

- `static` 변수는 모든 스레드가 공유하므로, **멀티스레드 환경에서 동기화 이슈**가 발생할 수 있습니다. (e.g., `static` 변수를 갱신하는 경우 `synchronized` 필요)
    

---
 **3. static을 사용하면 좋은 경우**

- **상태를 공유해야 하는 경우:** 예를 들어, 모든 객체가 공유하는 카운터 변수.
    
- **유틸리티성 메서드:** 객체 상태와 무관한 단순 기능 제공 (e.g., `Math`, `Arrays`).
    
- **싱글톤 패턴:** `private static` 인스턴스를 사용하여 전역 접근을 제공.
    

---
 **4. static을 남용하면 생길 문제**

- 객체지향적인 설계가 깨질 수 있음 (모든 상태가 전역화).
    
- 테스트 및 확장성에 불리.
    
- 멀티스레드 환경에서 예기치 못한 동기화 문제 발생 가능.
    

---
 **정리**

> **static의 장점:** 객체 생성 없이 접근 가능, 메모리 절약, 공용 상태 관리, 유틸리티성 메서드 구현.  
> **static의 제약:** 인스턴스 접근 불가, 오버라이딩 불가, 다형성 제한, GC 대상 아님, 동시성 문제.
##### 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
`static` 키워드는 **컴파일러와 JVM이 멤버를 클래스 단위로 관리**하도록 지시합니다.  
즉, **객체(인스턴스)와 분리된 메모리 공간에 로드되고 공유**되며, 호출 및 접근 방식에서도 **컴파일 시점부터 정적으로 처리(static binding)** 됩니다.

---
 **1. 컴파일 시 static 처리 방식**

 **(1) static 변수**

- 컴파일러는 `static` 변수를 **클래스 소속 변수(전역 변수와 유사)**로 인식합니다.
    
- `.class` 파일의 **메서드 영역(Method Area)**에 로딩되며, **클래스가 처음 로드될 때 1회만 메모리에 할당**됩니다.
    
- 각 인스턴스는 `static` 변수를 **공유**하며, `this.variable` 대신 **`ClassName.variable` 형태로 접근하도록 컴파일됩니다.**
    
- **바이트코드 예시 (javap -c)**
    
```java
class Test {
    static int count = 0;
    void inc() { count++; }
}

```
    
    디컴파일 시 `Test.count`로 직접 접근하는 코드가 생성됩니다.
    

---
 **(2) static 메서드**

- 컴파일러는 `static` 메서드를 **클래스 소속 함수로 처리**하고, **인스턴스 메서드와 달리 `this` 참조를 인자로 전달하지 않습니다.**
    
- 호출 시 **정적 바인딩(static binding)** 을 적용합니다.
    
    - 인스턴스 메서드는 **가상 메서드 테이블(v-table)**을 통해 런타임에 호출 대상을 결정하지만, `static` 메서드는 **컴파일 시점에 호출 메서드가 확정**됩니다.
        
- 예시:
    
    java
    
    복사편집
    
    `Test.print(); // 컴파일 시점에 직접 호출로 치환`
    

---
 **(3) static 초기화 블록**

- `static { ... }` 블록은 **클래스 로딩 시점(클래스가 처음 참조될 때)**에 단 한 번 실행됩니다.
    
- 컴파일 시 `.class` 파일의 `<clinit>` (Class Initializer) 메서드로 변환됩니다.
    
- 예시:
    
    java
    
    복사편집
    
    `class InitExample {     static int x;     static { x = 100; } }`
    
    디컴파일 시 `<clinit>` 메서드가 생성되어 `x` 값이 설정됩니다.
    

---

 **2. JVM 실행 시 static 처리**

1. **클래스 로더(ClassLoader)가 클래스 로딩**
    
    - `Test.class`가 처음 참조되면 JVM은 클래스 메타데이터와 static 멤버를 **메서드 영역(Method Area)**에 적재.
        
2. **static 변수 초기화 및 static 블록 실행**
    
    - 클래스가 로드될 때 **단 한 번** 수행됩니다.
        
3. **호출 시 클래스 이름으로 직접 접근**
    
    - 객체 인스턴스와 무관하게 `Test.print()`로 바로 실행.
        

---
 **3. static이 컴파일 시 주는 이점**

- **호출 최적화:**  
    `static` 메서드는 **다형성(virtual dispatch)** 검사를 거치지 않으므로 호출 비용이 적습니다.
    
- **메모리 절약:**  
    인스턴스마다 변수를 복사하지 않고, 하나의 static 메모리를 공유.
    
- **상수 처리:**  
    `static final` 상수는 **컴파일 타임 상수로 인라인 처리**되어 실행 속도가 빨라집니다.
    

---
 **4. 제약점 (컴파일 시 관점)**

- `static` 메서드는 **객체의 인스턴스 변수와 this 참조에 접근 불가** → 컴파일러가 이를 엄격히 체크.
    
- 오버라이딩 불가 → **컴파일 시점부터 메서드 바인딩 확정**.
    

---
 **정리**

> **컴파일러는 `static` 멤버를 객체와 독립된 “클래스 레벨 리소스”로 취급하고, 호출도 컴파일 타임에 정적으로 결정합니다.**  
> 실행 시 JVM은 해당 멤버를 **메서드 영역에 적재**하여 모든 인스턴스가 공유하도록 처리합니다.

### 6. Java의 Exception에 대해 설명해 주세요.
##### 설명
Java에서 **Exception(예외)**은 프로그램 실행 중 발생할 수 있는 **비정상적 상황이나 오류를 객체로 표현한 것**입니다.  
자바는 예외를 체계적으로 다루기 위해 **예외 처리(Exception Handling) 메커니즘**을 제공합니다.

---
1. Exception의 개념**

- 예외는 `Throwable` 클래스의 하위 클래스 객체로 표현됩니다.
    
- 예외가 발생하면 **JVM은 해당 예외를 던지고(`throw`)**, 이를 처리할 수 있는 **`catch` 블록을 찾습니다.**
    
- 예외가 처리되지 않으면 프로그램은 비정상 종료됩니다.
    

---
 **2. Exception 계층 구조**
```java
java.lang.Object
  └─ java.lang.Throwable
       ├─ java.lang.Error        // 시스템 레벨 오류
       └─ java.lang.Exception    // 애플리케이션 레벨 예외
            └─ java.lang.RuntimeException

```
 **(1) Error**

- JVM이나 시스템 레벨에서 발생하는 심각한 오류.
    
- 예: `OutOfMemoryError`, `StackOverflowError`.
    
- **애플리케이션에서 복구 불가능**하므로 일반적으로 `catch`하지 않습니다.
    

 **(2) Exception**

- 애플리케이션 실행 중 발생할 수 있는 예외 상황.
    
- 개발자가 적절히 처리할 수 있습니다.
    
    **Checked Exception**
    
    - **컴파일 시점**에 반드시 처리(try-catch 또는 throws)해야 하는 예외.
        
    - 예: `IOException`, `SQLException`, `ClassNotFoundException`.
        
    
    #### **Unchecked Exception (RuntimeException)**
    
    - **런타임 시점**에 발생하며, 명시적인 예외 처리를 강제하지 않음.
    - 예: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`.
        

 **3. Exception 처리 방법**

 **(1) try-catch-finally**

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
} finally {
    System.out.println("항상 실행되는 블록");
}

```

- `try`: 예외 발생 가능 코드.
    
- `catch`: 특정 예외를 잡아서 처리.
    
- `finally`: 예외 발생 여부와 관계없이 항상 실행 (자원 해제 등).
    
 **(2) throws**

- 메서드에서 예외를 직접 처리하지 않고 **호출한 쪽으로 던짐**.
    
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
}

```
 **(3) throw**

- 명시적으로 예외 객체를 생성하여 던짐.
    
```java
	if (value < 0) {
    throw new IllegalArgumentException("음수는 허용되지 않습니다.");
}

```

---
 **4. 사용자 정의 예외**

개발자는 `Exception` 또는 `RuntimeException`을 상속받아 사용자 정의 예외를 만들 수 있습니다.

```java
class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}

```
---
 **5. Exception 처리의 장점**

- 예외를 **객체화**하여 **에러 정보(메시지, 스택 트레이스 등)를 구조적으로 제공**.
    
- 프로그램의 **안정성과 가독성**을 높이고, 비정상 종료를 방지.
    
- **예외 전파(throws)**를 통해 책임을 호출자에 위임 가능.
    

---
 **6. 주의할 점**

- 불필요하게 광범위한 예외(`catch Exception`)를 잡는 것은 디버깅을 어렵게 할 수 있음.
    
- Checked Exception은 코드 가독성을 떨어뜨릴 수 있어, 최근에는 **RuntimeException을 활용**하는 경우가 많음 (Spring, JPA도 이 접근 방식을 채택).
    
 **정리**

> **Exception은 프로그램 실행 중 발생하는 오류를 처리하기 위한 객체화된 메커니즘**으로,  
> Checked/Unchecked로 나뉘며, `try-catch-finally`와 `throws`를 통해 유연하게 처리할 수 있습니다.
##### 예외처리를 하는 세 방법에 대해 설명해 주세요.
**1. `try-catch-finally`로 처리 (직접 처리)**
 **개념**

- 예외가 발생할 수 있는 코드를 `try` 블록에 넣고, 예외 발생 시 `catch` 블록에서 해당 예외를 처리합니다.
    
- `finally` 블록은 예외 발생 여부와 관계없이 **항상 실행**됩니다. (주로 자원 해제에 사용)
    
### **특징**

- 예외를 **직접 잡아서 처리**할 수 있어 프로그램이 비정상 종료되지 않음.
    
- `finally` 블록은 자원 해제, 연결 종료, 로그 기록 등에 사용됩니다.
    

---

## **2. `throws`로 던지기 (호출자에게 예외 전파)**

### **개념**

- 메서드에서 발생한 예외를 **직접 처리하지 않고, 호출한 메서드에 예외를 던짐**.
    
- 메서드 선언부에 `throws 예외클래스명`을 명시해야 합니다.
    

### **예시**

java

복사편집

`public void readFile() throws IOException {     FileReader fr = new FileReader("test.txt");  // IOException 가능 }`

java

복사편집

`public static void main(String[] args) {     try {         readFile();  // 호출한 쪽에서 처리     } catch (IOException e) {         e.printStackTrace();     } }`

### **특징**

- **예외 처리를 상위 호출자에게 위임**할 수 있어 메서드 자체가 더 단순해짐.
    
- Checked Exception은 `throws`로 반드시 명시하거나 `try-catch`로 처리해야 컴파일이 가능.
    

---

## **3. `throw`로 명시적 예외 발생시키기**

### **개념**

- 코드에서 직접 예외 객체를 생성해 **강제로 예외를 발생시킴**.
    
- 주로 **입력값 검증**이나 **비정상 상태**를 알릴 때 사용.
    

### **예시**

java

복사편집

`public void setAge(int age) {     if (age < 0) {         throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");     }     this.age = age; }`

### **특징**

- 원하는 시점에서 예외를 발생시켜 **명확하게 에러 상황을 제어**할 수 있습니다.
    
- `throw`로 던진 예외는 **try-catch** 또는 **throws**로 반드시 처리해야 합니다.
    

---

## **정리**

1. **`try-catch-finally`**: 예외를 **직접 처리**한다.
    
2. **`throws`**: 예외를 **호출자에게 전달**한다.
    
3. **`throw`**: **명시적으로 예외를 발생**시킨다.
##### CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
##### 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
### 7. Synchronized 키워드에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#7-synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 8. Java Stream에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#8-java-stream%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 9. Java의 GC에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#9-java%EC%9D%98-gc%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 10. equals()와 hashcode()에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#10-equals%EC%99%80-hashcode%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 11. IoC와 DI에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#11-ioc%EC%99%80-di%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 12. AOP에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#12-aop%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview
### 6. Java의 Exception에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#6-java%EC%9D%98-exception%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 7. Synchronized 키워드에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#7-synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 8. Java Stream에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#8-java-stream%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 9. Java의 GC에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#9-java%EC%9D%98-gc%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 10. equals()와 hashcode()에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#10-equals%EC%99%80-hashcode%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 11. IoC와 DI에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#11-ioc%EC%99%80-di%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 12. AOP에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#12-aop%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview

### 4. 리플렉션에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#4-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 5. static class와 static method를 비교해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#5-static-class%EC%99%80-static-method%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 6. Java의 Exception에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#6-java%EC%9D%98-exception%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 7. Synchronized 키워드에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#7-synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 8. Java Stream에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#8-java-stream%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 9. Java의 GC에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#9-java%EC%9D%98-gc%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 10. equals()와 hashcode()에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#10-equals%EC%99%80-hashcode%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 11. IoC와 DI에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#11-ioc%EC%99%80-di%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 12. AOP에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#12-aop%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#3-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EC%99%80-%EC%B6%94%EC%83%81-%ED%81%B4%EB%9E%98%EC%8A%A4%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 4. 리플렉션에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#4-%EB%A6%AC%ED%94%8C%EB%A0%89%EC%85%98%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 5. static class와 static method를 비교해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#5-static-class%EC%99%80-static-method%EB%A5%BC-%EB%B9%84%EA%B5%90%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 6. Java의 Exception에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#6-java%EC%9D%98-exception%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 7. Synchronized 키워드에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#7-synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 8. Java Stream에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#8-java-stream%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 9. Java의 GC에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#9-java%EC%9D%98-gc%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 10. equals()와 hashcode()에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#10-equals%EC%99%80-hashcode%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 11. IoC와 DI에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#11-ioc%EC%99%80-di%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 12. AOP에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#12-aop%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.


### 4. 리플렉션에 대해 설명해 주세요.


### 5. static class와 static method를 비교해 주세요.


### 6. Java의 Exception에 대해 설명해 주세요.


### 7. Synchronized 키워드에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#7-synchronized-%ED%82%A4%EC%9B%8C%EB%93%9C%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 8. Java Stream에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#8-java-stream%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 9. Java의 GC에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#9-java%EC%9D%98-gc%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 10. equals()와 hashcode()에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#10-equals%EC%99%80-hashcode%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 11. IoC와 DI에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#11-ioc%EC%99%80-di%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 12. AOP에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#12-aop%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#13-spring-%EC%97%90%EC%84%9C-interceptor%EC%99%80-servlet-filter%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#14-dispatcherservlet-%EC%9D%98-%EC%97%AD%ED%95%A0%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#15-jpa%EC%99%80-%EA%B0%99%EC%9D%80-orm%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 16. @Transactional 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#16-transactional-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#17-java-%EC%97%90%EC%84%9C-annotation-%EC%9D%80-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EB%82%98%EC%9A%94)

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/07-JAVA_SPRING.md#18-tomcat%EC%9D%B4-%EC%A0%95%ED%99%95%ED%9E%88-%EC%96%B4%EB%96%A4-%EC%97%AD%ED%95%A0%EC%9D%84-%ED%95%98%EB%8A%94-%EB%8F%84%EA%B5%AC%EC%9D%B8%EA%B0%80%EC%9A%94)

Tech-Interview/07-JAVA_SPRING.md at main · VSFe/Tech-Interview