### 메모리 관련, 쓰레드 safe 객체, 자바 자료구조,JVM 및 GC 좀 더 자세히,동기화
#### 쓰레드 safe
##### 설명
자바에서 **thread-safe**는 “여러 스레드가 동시에 접근/수정해도 객체의 상태와 불변식이 깨지지 않는다”는 뜻입니다. 핵심은 **(1) 원자성, (2) 가시성, (3) 순서(재정렬)** 3가지를 어떻게 보장하느냐입니다.

---
1) Thread-safe를 만드는 대표 전략 4가지

A. 불변(Immutable)로 만들기

- 상태가 절대 바뀌지 않으면 동기화가 필요 없습니다.
    
- 예: `String`, `Integer`, `LocalDate`, `BigInteger`(불변 타입들)
    

**포인트**

- 필드를 `final`로 두고, 생성자에서만  초기화
    
- 내부에 가변 객체가 있으면 **방어적 복사(defensive copy)**
    

---
B. Thread confinement (공유 자체를 없애기)

- “한 스레드만 쓰게” 가두면 thread-safe가 됩니다.
    
- 예: 메서드 로컬 변수, 스레드별 인스턴스, `ThreadLocal`
    

**포인트**

- 스레드풀에서 `ThreadLocal`은 누수/오염 위험이 있어 `remove()` 습관 필요
    
---
C. 락 기반 동기화(Mutual exclusion)

- 공유 상태를 보호하는 전통적 방법
    

`synchronized`

- 가장 기본. **원자성 + 가시성**을 함께 챙깁니다(락 획득/해제에 메모리 배리어 효과).
    
- 임계구역(critical section)을 최소화하는 것이 성능상 중요합니다.
    
 `ReentrantLock`

- `tryLock()`, 타임아웃, 인터럽트 대응 등 제어가 더 풍부
    
- `unlock()` 누락 위험 → `try/finally` 필수
    

---
D. Lock-free / CAS 기반(Atomic 계열)

- 락 대신 CAS로 경쟁을 해결
    
- 예: `AtomicInteger`, `AtomicLong`, `AtomicReference`
    
- 높은 경쟁에서는 CAS 실패가 늘어 성능이 흔들릴 수 있어, 카운터는 `LongAdder`가 유리한 경우가 많습니다.
    

---
2) 자주 나오는 오해 3가지

(1) `volatile`이면 thread-safe?

- 아닙니다.
    
- `volatile`은 **가시성**은 보장하지만, `i++` 같은 **복합 연산 원자성은 보장하지 않습니다.**
    
(2) “Concurrent 컬렉션이면 다 안전하다”

- 동시성 컬렉션은 “구조가 깨지지 않게” 설계된 것이지,  
    **여러 연산을 묶은 작업(체크 후 삽입 등)은 여전히 원자적이지 않을 수 있습니다.**
    
- 예: `if (!map.containsKey(k)) map.put(k,v)` 는 경쟁 조건 가능  
    → `computeIfAbsent` 같은 원자 메서드를 써야 합니다.
    
 (3) 불변 객체를 담은 컬렉션이면 컬렉션도 안전?

- 요소가 불변이어도 **컬렉션 자체가 동시에 수정**되면 문제입니다.
    
- “요소의 안전”과 “컨테이너의 안전”은 다릅니다.
    

---

3) Thread-safe 컬렉션/클래스 빠른 분류

 기본적으로 Thread-unsafe

- `ArrayList`, `HashMap`, `HashSet`, `StringBuilder`
- 

단일 락으로 감싼(synchronized) 컬렉션

- `Collections.synchronizedList/map/set`
    
- 병목 가능 + 반복(iteration)은 외부 동기화 필요한 경우가 많음
    

(동시성 컬렉션)

- `ConcurrentHashMap`
    
- `ConcurrentLinkedQueue`
    
- `CopyOnWriteArrayList` (읽기 많고 쓰기 적을 때)
    
- `BlockingQueue`(생산자-소비자)
    

 문자열 조립

- `StringBuffer`(동기화 O) vs `StringBuilder`(동기화 X)
    

---

4) 면접에서 “왜?”로 깊게 들어오는 질문에 대한 핵심 답

- 왜 `synchronized`가 가시성도 보장하나요?  
    → 락 획득/해제 시점에 **메모리 배리어 효과**가 있어, 임계구역 내 변경이 다른 스레드에 보이도록 보장됩니다.
    
- 왜 `volatile`은 `i++`를 못 막나요?  
    → `i++`는 read-modify-write의 3단계라서 중간에 끼어들 수 있습니다.
    
- 왜 `ConcurrentHashMap`에서 “check-then-act”가 위험하나요?  
    → 두 연산이 별개라 경쟁 조건이 생기므로 원자 메서드(예: `computeIfAbsent`)를 써야 합니다.
    

---

원하시면, 바로 면접/실무에서 많이 나오는 **대표 패턴 3개**를 코드로 정리해드릴 수 있습니다.

1. `volatile`이 안전한 경우/아닌 경우 (`stop flag` vs `counter`)
    
2. `ConcurrentHashMap`에서 원자적으로 갱신하는 방법 (`compute`, `merge`)
    
3. 카운터 설계: `AtomicLong` vs `LongAdder` 선택 기준


#### GC
##### GC 동작원리
Garbage Collection(GC) 이란?****

가비지 컬렉션(Garbage Collection, 이하 GC)은 자바의 메모리 관리 방법 중의 하나로 JVM(자바 가상 머신)의 **Heap 영역**에서 **동적으로 할당했던 메모리** 중 **필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거**하는 프로세스를 말한다.

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/msA9V/btrISPnVruj/AAAAAAAAAAAAAAAAAAAAAErRy7dpdOvw9VLhdecxVJeDomiUvKhOQx4ryxj88UCJ/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=D7q0I%2BqJnAmgllST%2BiZH7AkvJX0%3D)

C / C++ 언어에서는 이러한 가비지 컬렉션이 없어 프로그래머가 수동으로 메모리 할당과 해제를 일일이 해줘야 했었다.

반면 Java에서는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 Java 프로세스가 한정된 메모리를 효율적으로 사용할수 있게 하고, 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에서 대해 관리하지 않아도 되어 오롯이 **개발에만 집중**할 수 있다는 장점이 있다.

예시를 들자면 다음과 같은 조금 억지스러운(?) 코드를 실행한다고 가정하자.

java

```
for (int i = 0; i < 10000; i++) {
  NewObject obj = new NewObject();  
  obj.doSomething();
}
```



파이썬, 자바스크립트, Go 언어 등 **많은 프로그래밍 언어에서 가비지 컬렉션이 기본으로 내장**되어 있다.

당장 여러분이 보고있는 이 브라우저 역시도 자체적으로 구현된 가비지 컬렉션이 있기 때문에 별다른 메모리 관리 없이 웹페이지를 만들수 있는 것이다.

따라서 이번 시간에 가비지 컬렉션에 대해 제대로 학습한다면, 자바 외의 언어의 가비지 컬렉션 동작에 대해서도 어느정도 통달되었다고 말할 수 있다.

그러나 이런 만능 같은 가비지 컬렉션에도 **단점**이 존재한다.

자동으로 처리해준다 해도 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며, 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 **오버헤드**가 발생되는 문제점이 있다.

이를 전문적인 용어로 **Stop-The-World** 라 한다.

			
        

>             
> 
> Info
> 
>             
> 
> **STW (Stop The World)**  
> GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미.  
> GC가 작동하는 동안 GC 관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있다.  
> 따라서 이 시간을 최소화 시키는 것이 쟁점이다.
> 
> ![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/UGGwm/btrIRGekM2e/AAAAAAAAAAAAAAAAAAAAALiE8u5kvuMvQrahktUlv2M-L862ZsX1R4gKMB-H6EKw/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=3BZZtebOPOWhR3jhhpKubkY2lHw%3D)
> 
>         

이로 인해 GC가 너무 자주 실행되면 소프트웨어 성능 하락의 문제가 되기도 하다.

예를들면 익스플로러는 이 가비지 컬렉션를 너무 자주 실행하여 성능 문제를 일으키는 것으로 악명이 높았다.

이런 특성에 따라 실시간 성이 매우 강조되는 포로그램일 경우 가비지 컬렉터(GC)에게 메모리를 맞기는 것은 맞지 않을 수 있다.

따라서 어플리케이션의 사용성을 유지하면서 효율적이게 GC를 실행하는 최적화 작업이 개발자의 숙제가 된다.

그리고 이러한 GC 최적화 작업을 **GC 튜닝**이라고 하며 이 글의 마지막 단원에서 다룬다.

---

##### **가비지 컬렉션 대상**

그럼 가비지 컬렉션(Garbage Collection)은 어떤 Object를 Garbage로 판단해서 스스로 지워버릴까?

가비지 컬렉션은 특정 객체가 garbage인지 아닌지 판단하기 위해서 도달성, 도달능력(Reachability) 이라는 개념을 적용한다.

객체에 레퍼런스가 있다면 Reachable로 구분되고, 객체에 유효한 레퍼런스가 없다면 Unreachable로 구분해버리고 수거해버린다. 

- Reachable : 객체가 참조되고 있는 상태
- Unreachable  : 객체가 참조되고 있지 않은 상태 (GC의 대상이 됨) 

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/c80g54/btrIT9fcYdX/AAAAAAAAAAAAAAAAAAAAAOiEoC_94bX3B6RxR8v9zgl1Rr-9OaOYd9X8yAniLCc1/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=PjOCaugMtPzTercZULhIY834iaE%3D)

예를들어 JVM 메모리에서는 객체들은 실질적으로 Heap영역에서 생성되고 Method Area이나 Stack Area 에서는 Heap Area에 생성된 객체의 주소만 참조하는 형식으로 구성된다.

하지만 이렇게 생성된 Heap Area의 객체들이 메서드가 끝나는 등의 특정 이벤트들로 인하여 Heap Area 객체의 메모리 주소를 가지고 있는 참조 변수가 삭제되는 현상이 발생하면, 위의 그림에서의 빨간색 객체와 같이 Heap영역에서 어디서든 참조하고 있지 않은 객체(Unreachable)들이 발생하게 된다.

이러한 객체들을 주기적으로 가비지 컬렉터가 제거해주는 것이다.

---


##### **가비지 컬렉션 청소 방식**

위에서 가비지 컬렉션(GC)가 어떻게 Reachable과 Unreachable을 판단할 것인지 간단히 들여다 보았다.

그러면 이제 GC가 Unreachable한 객체를 어떤 방식으로 청소를 하는지 알아보자.

**Mark And Sweep**

**Mark-Sweep** 이란 다양한 GC에서 사용되는 객체를 솎아내는 내부 알고리즘이다.

가비지 컬렉션이 동작하는 아주 **기초적인 청소 과정**이라고 생각하면 된다.

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/c4UAyv/btrIZ64PlNk/AAAAAAAAAAAAAAAAAAAAANHTiBH8o1CTi2l9rpnH6lfi_SA1OM9GzaRZk_7RD8vh/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=Paw3gYAz89b1ENvoKfqOVIxC9To%3D)

원리는 간단하다.

가비지 컬렉션이 될 대상 객체를 식별(Mark)하고 제거(Sweep)하며 객체가 제거되어 파편화된 메모리 영역을 앞에서부터 채워나가는 작업(Compaction)을 수행하게 된다.

- **Mark 과정** : 먼저 Root Space로부터 그래프 순회를 통해 연결된 객체들을 찾아내어 각각 어떤 객체를 참조하고 있는지 찾아서 마킹한다.
- **Sweep 과정** : 참조하고 있지 않은 객체 즉 Unreachable 객체들을 Heap에서 제거한다.
- **Compact 과정** : Sweep 후에 분산된 객체들을 Heap의 시작 주소로 모아 메모리가 할당된 부분과 그렇지 않은 부분으로 압축한다. (가비지 컬렉터 종류에 따라 하지 않는 경우도 있음)

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/cgSNa1/btrIVgyOGYA/AAAAAAAAAAAAAAAAAAAAADVYIHQMN0XJvlNfQVCD3Z7rZohK28N8p18HpJd0Kwry/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=nWgnO7VfTk%2F5otj8Wnpk9nwJ8Rg%3D)

이렇게 Mark And Sweep 방식을 사용하면 루트로부터 연결이 끊긴 순환 참조되는 객체들을 모두 지울수 있다.

			
        

>             
> 
> Info
> 
>             
> 
> **[ GC의 Root Space ]**  
> Mark And Sweep 방식은 루트로 부터 해당 객체에 접근이 가능한지가 해제의 기준이 된다.  
> JVM GC에서의 Root Space는 Heap 메모리 영역을 참조하는 method area, static 변수, stack, native method stack이 되게 된다.  
> 
> ![Language/Java (JVM)](https://blog.kakaocdn.net/dna/cgBYrs/btrI1VuVcpW/AAAAAAAAAAAAAAAAAAAAAIrdehR7OibsqfZh2MKEtkSI-fByc-JfWUaL-ddozcCF/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=SGcmvV31ghTs6O2STavsJYyKI0k%3D)
> 
>         

---

가비지 컬렉션 동작 과정**

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/tgPPC/btrI2Z4pXMo/AAAAAAAAAAAAAAAAAAAAAI6vpYZbroTcSYK_tMjTUcg92v8yCYWVBTFRp7w50Cqa/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=aSqxYoIOKBTl%2B7v9YX3P1wvFsg8%3D)

---
heap 메모리의 구조**

JVM의 **힙(heap)** 영역은 동적으로 레퍼런스 데이터가 저장되는 공간으로서, **가비지 컬렉션**에 대상이 되는 공간이다.

Heap영역은 처음 설계될 때 다음의 2가지를 전제 (Weak Generational Hypothesis)로 설계되었다.

- 대부분의 객체는 금방 접근 불가능한 상태(Unreachable)가 된다.
- 오래된 객체에서 새로운 객체로의 참조는 아주 적게 존재한다.

즉, **객체는 대부분 일회성되며, 메모리에 오랫동안 남아있는 경우는 드물다**는 것이다. 

이러한 특성을 이용해 JVM 개발자들은 보다 효율적인 메모리 관리를 위해, 객체의 생존 기간에 따라 물리적인 Heap 영역을 나누게 되었고 **Young 과 Old 총 2가지 영역**으로 설계하였다.

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/dS5yAY/btrIPXf59mc/AAAAAAAAAAAAAAAAAAAAABX3K3Odhl7dGqRCzfxsZL7m3nZRDS5piI__WEcnVgwD/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=gthTRcCXL%2Bsu9Tj4co%2FU1STyTxc%3D)

###### **Young 영역(Young Generation)**

- 새롭게 생성된 객체가 할당(Allocation)되는 영역
- 대부분의 객체가 금방 Unreachable 상태가 되기 때문에, 많은 객체가 Young 영역에 생성되었다가 사라진다.
- Young 영역에 대한 가비지 컬렉션(Garbage Collection)을 Minor GC라고 부른다.

###### **Old 영역(Old Generation)**

- Young영역에서 Reachable 상태를 유지하여 살아남은 객체가 복사되는 영역
- Young 영역보다 크게 할당되며, 영역의 크기가 큰 만큼 가비지는 적게 발생한다.
- Old 영역에 대한 가비지 컬렉션(Garbage Collection)을 Major GC 또는 Full GC라고 부른다.

  
위 그림에서, Old 영역이 Young 영역보다 크게 할당되는 이유는 Young 영역의 수명이 짧은 객체들은 큰 공간을 필요로 하지 않으며 큰 객체들은 Young 영역이 아니라 바로 Old 영역에 할당되기 때문이다.

---

또 다시 힙 영역은 더욱 효율적인 GC를 위해 **Young 영역**을 **3가지 영역(Eden, survivor 0, survivor 1)** 으로 나눈다.

![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/kYzig/btrIYnMIU2l/AAAAAAAAAAAAAAAAAAAAAN1C95Ciya-LXufLKd1RkVpOZzgQar7SDhOzSCnFkpa4/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=S1x8u%2F97mVJb1dUWFhYVUAr5Gjs%3D)

###### **Eden** 

- new를 통해 새로 생성된 객체가 위치. 
- 정기적인 쓰레기 수집 후 살아남은 객체들은 Survivor 영역으로 보냄

###### **Survivor 0 / Survivor 1** 

- 최소 1번의 GC 이상 살아남은 객체가 존재하는 영역
- Survivor 영역에는 특별한 규칙이 있는데, Survivor 0 또는 Survivor 1 둘 중 하나에는 꼭 비어 있어야 하는 것이다.

이렇게 하나의 힙 영역을 세부적으로 쪼갬으로서 객체의 생존 기간을 면밀하게 제어하여 가비지 컬렉터(GC)를 보다 정확하게 불필요한 객체를 제거하는 프로세스를 실행하도록 한다.

힙 영역 내부 구조에 대해 자세히 알아봤으니, 실제로 객체가 가비지 컬렉터로 제거되는 과정을 그림으로 학습해보자.

			
        

>             
> 
> Info
> 
>             
> 
> **[ Java 8 에서의 Permanent ]**  
> Permanent는 직역하면 영구적인 세대의 의미로서, 생성된 객체들의 정보의 주소값이 저장된 공간이다.  
> 클래스 로더에 의해 load되는 Class, Method 등에 대한 Meta 정보가 저장되는 영역이고 JVM에 의해 사용된다.  
> Java 7 까지는 힙 영역에 존재했지만 Java 8 버전 이후에는 Native Method Stack에 편입되게 된다.  
> 
> ![java-gc-garbage-colleciton](https://blog.kakaocdn.net/dna/bYh0JQ/btrIIRNPCiZ/AAAAAAAAAAAAAAAAAAAAAL8gTEss5cXP3jsuSEH3WqB81qzaD0uXTAGzs0jEoeD9/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=ElTKGf4tG7OoXN34I%2FrEXdj2ExE%3D)
> 
>         

---

##### **Minor GC 과정**

![java-Minor GC](https://blog.kakaocdn.net/dna/cz9lzz/btrIRGyAeEV/AAAAAAAAAAAAAAAAAAAAAPW9-mKpLv2IeUr9BG4ug7R7KQPMbT1NmGM5k8bd4qqH/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=%2FtID7UX%2FuMIU3EfSf3sjzB7xfCE%3D)

Young Generation 영역은 짧게 살아남는 메모리들이 존재하는 공간이다. 

모든 객체는 처음에는 Young Generation에 생성되게 된다.

 Young Generation의 공간은 Old Generation에 비해 상대적으로 작기 때문에 메모리 상의 객체를 찾아 제거하는데 적은 시간이 걸린다. (작은 공간에서 데이터를 찾으니까)

이 때문에 Young Generation 영역에서 발생되는 GC를 **Minor GC**라 불린다.

---

**1.** 처음 생성된 객체는 Young Generation 영역의 일부인 Eden 영역에 위치

![java-Minor GC](https://blog.kakaocdn.net/dna/cXg3ZZ/btrITpQET0n/AAAAAAAAAAAAAAAAAAAAAOuQVW3IRFIkJwQE297o0YDULWvXfWbwfQZP8AXlKIib/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=Y6xf9t8n%2FLmndhCYDNtlqXKSqfU%3D)

![java-Minor GC](https://blog.kakaocdn.net/dna/dnDTuC/btrISOQKFwn/AAAAAAAAAAAAAAAAAAAAAArjkB_d04Nq2WQbGzKWy0wu72TEWVM17ubUQi9zCqa7/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=18Rp%2FWthrtjveF%2FSN3J6yVUNXgM%3D)

**2.** 객체가 계속 생성되어 Eden 영역이 꽉차게 되고 Minor GC가 실행

![java-Minor GC](https://blog.kakaocdn.net/dna/tySvx/btrITpwlB0D/AAAAAAAAAAAAAAAAAAAAAOs8TkltYK7fzH-tiEwj4fcrxjq_qa0inTMO7GM7a9Qs/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=XNHKzkyuweQ8IzA2JAJ4qeIItGs%3D)

**3.** Mark 동작을 통해 reachable 객체를 탐색

![java-Minor GC](https://blog.kakaocdn.net/dna/cJl67l/btrIXRd6Izv/AAAAAAAAAAAAAAAAAAAAADDN4kRQDZM-Y1lQebopz3LAvzmy1d588Da0EtOozs73/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=1A9f%2B%2BGlhWxky94lTflaf3CwxYA%3D)

**4.** Eden 영역에서 살아남은 객체는 1개의 Survivor 영역으로 이동

![java-Minor GC](https://blog.kakaocdn.net/dna/bxY6Md/btrIWNwtetB/AAAAAAAAAAAAAAAAAAAAAB0vETPfIhRWMOxPY-Z5JnV0ujLLjvhilBR3z52Mc6s9/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=RlTlK3oE24DhKJnH2Q7lpZ4u4U0%3D)

**5.** Eden 영역에서 사용되지 않는 객체(unreachable)의 메모리를 해제(sweep)

![java-Minor GC](https://blog.kakaocdn.net/dna/ssSMf/btrIWMYFQlZ/AAAAAAAAAAAAAAAAAAAAANi6a0XEzEr8isvCX6nnEMG0dvCYMSghngFH5nXqtdTo/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=K5UkX2p4km3zfqY3VWdgYjSY044%3D)

**6.** 살아남은 모든 객체들은 age값이 1씩 증가

![java-Minor GC](https://blog.kakaocdn.net/dna/Dno6M/btrIPYfc2VC/AAAAAAAAAAAAAAAAAAAAACFCxK69k9tw1Brb1fY6x_p_XYFB267763YuSdGf3Ghc/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=ppCdpA444MTG4q%2FVCvUO%2FgwyasQ%3D)

			
        

>             
> 
> Info
> 
>             
> 
> **[ age 값이란? ]**  
> Survivor 영역에서 객체의 객체가 살아남은 횟수를 의미하는 값이며, Object Header에 기록된다.  
> 만일 age 값이 임계값에 다다르면 Promotion(Old 영역으로 이동) 여부를 결정한다.  
> JVM 중 가장 일반적인 HotSpot JVM의 경우 이 age의 기본 임계값은 31이다.   
> 객체 헤더에 age를 기록하는 부분이 6 bit로 되어 있기 때문이다.  
>   
> 또한 Survivor 영역의 제한 조건으로 Survivor 영역 중 반드시 1개는 사용되어야 하고, 나머지는 비어 있어야 한다.   
> 만약 두 Survivor 영역에 모두 데이터가 존재하거나, 모두 사용량이 0이라면 현재 시스템이 정상적인 상황이 아니라는 반증이 된다.
> 
>         

**7.** 또다시 Eden 영역에 신규 객체들로 가득 차게 되면 다시한번 minor GC 발생하고 mark 한다

![java-Minor GC](https://blog.kakaocdn.net/dna/cNoD2j/btrIT8gQrk9/AAAAAAAAAAAAAAAAAAAAAHqtziwN8bWr3242OloYDTkRlrUzMYynHGl7GV53dTB_/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=COOHWW2IRguoFv8ejDN4H0WdfCc%3D)

![java-Minor GC](https://blog.kakaocdn.net/dna/8XX01/btrIPYsHxbi/AAAAAAAAAAAAAAAAAAAAAHf2TF6t4IfGpjgjh9mzizK7Gz6b5XPwsp1ifkb6ldWI/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=v6Xjcr80ZYFAnaE%2F%2FzASDVoUe3M%3D)

![java-Minor GC](https://blog.kakaocdn.net/dna/cRhJ1g/btrIXPtPw5o/AAAAAAAAAAAAAAAAAAAAAOP0Tq8XIPqD8K08BRT-DZmwpszfpcxrJUtAoP-UY2VX/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=TKSN5G2OzzE3RtDmKOnS6aKJlRM%3D)

**8.** marking 한 객체들을 비어있는 Survival 1으로 이동하고 sweep

![java-Minor GC](https://blog.kakaocdn.net/dna/dsj6Og/btrIRHqHljJ/AAAAAAAAAAAAAAAAAAAAALptnD8WS8AKXz5QSK1l8T33wdXXpWvq9aDdeBcPwEop/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=joBI3NaziPcBDILMXTav%2BSVcB9Q%3D)

![java-Minor GC](https://blog.kakaocdn.net/dna/blilhe/btrISO4eRF3/AAAAAAAAAAAAAAAAAAAAAH-sqCdcGbX4sJDZ8z7h72TfszZGQZ8Bhumd0ewTfB3o/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=wvA4fsyrq8LYBUsQ8pG9M064AHM%3D)

**10.** 다시 살아남은 모든 객체들은 age가 1씩 증가

![java-Minor GC](https://blog.kakaocdn.net/dna/d8v4Vk/btrIXwVy4Uj/AAAAAAAAAAAAAAAAAAAAAJzflhpJEYGievw74oWtDvhETcLk4uegUHLXNsLlDK0f/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=KZR4C2mr9%2FjouN6GZFBIL4Og1h4%3D)

**11.** 이러한 과정을 반복

![java-Minor GC](https://blog.kakaocdn.net/dna/2WHEq/btrIUaeDqLG/AAAAAAAAAAAAAAAAAAAAADVmnHk_dj00zjTY3PoCz4fPP2lNDpWnIob9cqtqXmZO/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=eeUNDxTFFEYYPBQpG19%2FeEF04so%3D)

---

##### **Major GC 과정**

![java-Major GC](https://blog.kakaocdn.net/dna/Al6rO/btrISO4bXw2/AAAAAAAAAAAAAAAAAAAAADoG54jkbDevL5nkj0GbTlay9xsd9zJRgrglzaQIhmzy/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=qEM3pOVteSTejVdqMj%2FZ1v6e3hA%3D)

Old Generation은 길게 살아남는 메모리들이 존재하는 공간이다.

Old Generation의 객체들은 거슬러 올라가면 처음에는 Young Generation에 의해 시작되었으나, GC 과정 중에 제거되지 않은 경우 age 임계값이 차게되어 이동된 녀석들이다.

그리고 **Ma****jor GC**는 객체들이 계속 Promotion되어 Old 영역의 메모리가 부족해지면 발생하게 된다.

			
        

>             
> 
> Tip
> 
>             
> 
> Major GC는 Full GC라고도 불리운다.
> 
>         

Minor GC와 Major GC 차이점을 표로 정리하면 다음과 같이 된다.

![java-Major GC](https://blog.kakaocdn.net/dna/bQinW1/btrIOSeHYMd/AAAAAAAAAAAAAAAAAAAAAJHXgvxTm9_peoJ11wNITpta15nC1pRAU4R3MExfecFj/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=cuNjQg17%2F6AxoRVJ%2BtCtwVAlU4Q%3D)

---

**1.** 객체의 age가 임계값(여기선 8로 설정)에 도달하게 되면,

![java-Major GC](https://blog.kakaocdn.net/dna/c3ZKIh/btrITnE39P2/AAAAAAAAAAAAAAAAAAAAAPX2u8zwAyNbuEkvpFfoAWcqzs9X8U8D1DaKUB2jnu9n/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=dW0oLN9dhw6dZ46jG3uCJnvCWxg%3D)

**2.** 이 객체들은 Old Generation 으로 이동된다. 이를 promotion 이라 부른다.

![java-Major GC](https://blog.kakaocdn.net/dna/GJGPb/btrIUmFRmQO/AAAAAAAAAAAAAAAAAAAAAIU9L_gTheIO0quj-JzJp0ZlR3RxQCiMZvbQvLBrcQ2I/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=oPdbN%2FKPQ524T90gZWzSGanCOZ8%3D)

**3.** 위의 과정이 반복되어 Old Generation 영역의 공간(메모리)가 부족하게 되면 Major GC가 발생되게 된다.

![java-Major GC](https://blog.kakaocdn.net/dna/mnBRi/btrIUm6WXIl/AAAAAAAAAAAAAAAAAAAAAMxzD8-iyu2J4t9fwefAMNAGrTv8XpPefGFdx4o2MHh5/img.gif?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=5%2B6FvmOzalUNuhmM%2FqOBTXIVxJo%3D)

**Major GC**는 Old 영역은 데이터가 가득 차면 GC를 실행하는 단순한 방식이다. 

Old 영역에 할당된 메모리가 허용치를 넘게 되면, Old 영역에 있는 모든 객체들을 검사하여 참조되지 않는 객체들을 한꺼번에 삭제하는 Major GC가 실행되게 된다.

하지만 Old Generation은 Young Generation에 비해 상대적으로 큰 공간을 가지고 있어, 이 공간에서 메모리 상의 객체 제거에 많은 시간이 걸리게 된다.

예를들어 Young 영역은 일반적으로 Old 영역보다 크키가 작기 때문에 GC가 보통 0.5초에서 1초 사이에 끝난다.

그렇기 때문에 Minor GC는 애플리케이션에 크게 영향을 주지 않는다.

하지만 Old 영역의 Major GC는 일반적으로 Minor GC보다 시간이 오래걸리며, 10배 이상의 시간을 사용한다.

바로 여기서 본문 초반에 소개했던 **Stop-The-World** 문제가 발생하게 된다.

Major GC가 일어나면 Thread가 멈추고 Mark and Sweep 작업을 해야 해서 CPU에 부하를 주기 때문에 멈추거나 버벅이는 현상이 일어나기 때문이다.

따라서 자바 개발진들은 끊임 없이 **가비지 컬렉션 알고리즘을 발전** 시켜왔다.

이제 다음 단원에서 JDK의 가비지 컬렉션 알고리즘 종류를 알아보고, 어느 방식이 효율적이며 또한 Java 버전에따라 어떤 알고리즘이 쓰이는지 학습해보는 시간을 가져보자.

---

##### **가비지 컬렉션 알고리즘 종류**

JVM이 메모리를 자동으로 관리해주는 것은 개발자의 입장에서 상당한 메리트이다. 

하지만 문제는 GC를 수행하기 위해 Stop The World가 발생되고 이 때문에 애플리케이션이 중지되는 문제점이 발생하게 됭써다.

또한 자바가 발전됨에 따라 Heap의 사이즈가 커지면서 애플리케이션의 지연(Suspend) 현상이 두드러지게 되었고, 이를 최적화 위해 다양한 Garbage Collection(가비지 컬렉션) 알고리즘이 개발 되었다.

![java-gc-Algorgorithm](https://blog.kakaocdn.net/dna/Yyftm/btrIT8g2DyE/AAAAAAAAAAAAAAAAAAAAAKjbIZfy5M23Xo-TBCgnIwmQwabpgrhEAxwLHDZgXJA0/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=YhuNUIvOUvwXMUhrZHYnNjy7BDY%3D)

GC 알고리즘 종류

여기서 알아두어야 할 것은 소개할 **GC 알고리즘은 모두 설정을 통해 Java에 적용**할수 있다는 점이다.

즉, **상황에 따라 필요한 GC 방식을 설정해서 사용**할 수 있다. 

그럼, 이제부터 다양한 가비지 콜렉션(GC)방식을 살펴보기로 하자.

---

##### **Serial GC**

- 서버의 CPU 코어가 1개일 때 사용하기 위해 개발된 가장 단순한 GC
- GC를 처리하는 쓰레드가 1개 (싱글 쓰레드) 이어서 가장 stop-the-world 시간이 길다
- Minor GC 에는 Mark-Sweep을 사용하고, Major GC에는 Mark-Sweep-Compact를 사용한다.
-  보통 실무에서 사용하는 경우는 없다 (디바이스 성능이 안좋아서 CPU 코어가 1개인 경우에만 사용) 

![Serial GC](https://blog.kakaocdn.net/dna/kBL3D/btrIT91k2n7/AAAAAAAAAAAAAAAAAAAAADwNDtyDakMmq6-t-n1hFybymhYbUvTbOfjw1iQHnFLE/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=aUyLBXHqS5kLIr%2BmOk44dLNNnq0%3D)

###### **Serial GC 실행 명령어**

- 자바 프로그램을 실행할때 ~~-XX:+UseSerialGC~~ GC 옵션을 지정하여 해당 가비지 컬렉션 알고리즘으로 힙 메모리를 관리하도록 실행할 수 있다.

bash

```
java -XX:+UseSerialGC -jar Application.java
```

---

##### **Parallel GC** 

- Java 8의 디폴트 GC
- Serial GC와 기본적인 알고리즘은 같지만, Young 영역의 Minor GC를 멀티 쓰레드로 수행 (Old 영역은 여전히 싱글 쓰레드)
- Serial GC에 비해 stop-the-world 시간 감소

![Parallel GC](https://blog.kakaocdn.net/dna/ckjP6E/btrIVf74R58/AAAAAAAAAAAAAAAAAAAAAFELkCPmwMYoHvlRRmkLa-haS5HzvOIahseju407-I55/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=Pyd6dZYvoIQcVaiwmECQfp2QWvc%3D)

###### **Parallel GC 실행 명령어**

- GC 스레드는 기본적으로 cpu 개수만큼 할당된다.
- 옵션을 통해 GC를 수행할 쓰레드의 갯수 등을 설정해줄 수 있다.

bash

```
java -XX:+UseParallelGC -jar Application.java 
# -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수
```

---

##### **Parallel Old GC (Parallel Compacting Collector)**

- Parallel GC를 개선한 버전
- Young 영역 뿐만 아니라, Old 영역에서도 멀티 쓰레드로 GC 수행
- 새로운 가비지 컬렉션 청소 방식인 Mark-Summary-Compact 방식을 이용 (Old 영역도 멀티 쓰레드로 처리)

![Parallel Old GC](https://blog.kakaocdn.net/dna/cs71MN/btrI0ePXZqr/AAAAAAAAAAAAAAAAAAAAAH15jhQBZkUvmII4GOHqOt2kOKf18qu8mypMe3VqUfyW/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=R5bWCBHejckl64oA69QU7JNLbKY%3D)

###### **Parallel Old GC 실행 명령어**

bash

```
java -XX:+UseParallelOldGC -jar Application.java
# -XX:ParallelGCThreads=N : 사용할 쓰레드의 갯수
```

---

##### **CMS GC **(Concurrent Mark Sweep)****

- 어플리케이션의 쓰레드와 GC 쓰레드가 동시에 실행되어 stop-the-world 시간을 최대한 줄이기 위해 고안된 GC
- 단, GC 과정이 매우 복잡해짐.
- GC 대상을 파악하는 과정이 복잡한 여러단계로 수행되기 때문에 다른 GC 대비 CPU 사용량이 높다
- 메모리 파편화 문제
- CMS GC는 Java9 버젼부터 deprecated 되었고 결국 Java14에서는 사용이 중지

![CMS GC](https://blog.kakaocdn.net/dna/btq9xn/btrIUalHp5a/AAAAAAAAAAAAAAAAAAAAAAh0sf86ZN68ZEnwuWpnKR0qcV53tVLqUWGGuqMBUzFB/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=MVMLqhv9oW2XBOUppt7QQGZDnCI%3D)

###### **CMS GC 실행 명령어**

bash

```
# deprecated in java9 and finally dropped in java14
java -XX:+UseConcMarkSweepGC -jar Application.java
```

---

##### **G1 GC **(Garbage First)****

- CMS GC를 대체하기 위해 jdk 7 버전에서 최초로 release된 GC
- Java 9+ 버전의 디폴트 GC로 지정
- 4GB 이상의 힙 메모리, Stop the World 시간이 0.5초 정도 필요한 상황에 사용 (Heap이 너무작을경우 미사용 권장)
- 기존의 GC 알고리즘에서는 Heap 영역을 물리적으로 고정된 Young / Old 영역으로 나누어 사용하였지만,   
    G1 gc는 아예 이러한 개념을 뒤엎는 Region이라는 개념을 새로 도입하여 사용.  
    전체 Heap 영역을 Region이라는 영역으로 체스같이 분할하여 상황에 따라 Eden, Survivor, Old 등 역할을 고정이 아닌 동적으로 부여
- Garbage로 가득찬 영역을 빠르게 회수하여 빈 공간을 확보하므로, 결국 GC 빈도가 줄어드는 효과를 얻게 되는 원리

  

![G1 GC](https://blog.kakaocdn.net/dna/cjO5N5/btrI1Ob7Gbb/AAAAAAAAAAAAAAAAAAAAAB5mgWjXJJYoLWCEHBE5DpYgUaOHfFdKRlyl3UAqHqp9/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=Dr5Py3QqkH%2F0rILEUP2hpAG64fA%3D)![G1 GC](https://blog.kakaocdn.net/dna/b3VAZL/btrIVglH89c/AAAAAAAAAAAAAAAAAAAAAGS0UJS2PrmF6oxOMI8hV-Pz1MZVWoYLUKw8LIdAW9LD/img.png?credential=yqXZFxpELC7KVnFOS48ylbz2pIh7yKj8&expires=1767193199&allow_ip=&allow_referer=&signature=dy27rdI293x90otUjQZ%2B4E1p1jc%3D)

			
        

> **[ G1 GC의 효율성 ]**  
> Java9+ 부터 기본 GC로 자리잡은 G1 GC에서는 이전의 GC들처럼 일일히 메모리를 탐색해 객체들을 제거하지 않는다.   
> 대신 메모리가 많이 차있는 영역(region)을 인식하는 기능을 통해 메모리가 많이 차있는 영역을 우선적으로 GC 한다.   
> 즉, G1 GC는 Heap Memory 전체를 탐색하는 것이 아닌 영역(region)을 나눠 탐색하고 영역(region)별로 GC가 일어난다.  
>   
> 또한 이전의 GC 들은 Young Generation에 있는 객체들이 GC가 돌때마다 살아남으면 Eden → Survivor0 → Survivor1으로 순차적으로 이동했지만, G1 GC에서는 순차적으로 이동하지는 않는다.   
> 대신 G1 GC는 더욱 효율적이라고 생각하는 위치로 객체를 Reallocate(재할당) 시킨다.   
> 예를 들어 Survivor1 영역에 있는 객체가 Eden 영역으로 할당하는 것이 더 효율적이라고 판단될 경우 Eden 영역으로 이동시킨다.


### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
[[JVM의 구조와 동작방식]]
##### 설명
JVM(Java Virtual Machine)은 **자바 프로그램이 실행되는 가상화된 실행 환경**으로, 자바뿐만 아니라 Kotlin, Scala 등 JVM 기반 언어로 작성된 프로그램이 동작할 수 있도록 설계된 **추상 컴퓨터(virtual machine)**입니다.

**JVM의 주요 역할**

1. **바이트코드 실행**
    
    - 자바 소스코드(`.java`)는 컴파일러(`javac`)를 통해 **바이트코드(`.class`)**로 변환됩니다.
        
    - JVM은 이 바이트코드를 해석(인터프리트)하거나 **JIT(Just-In-Time) 컴파일러**를 통해 네이티브 머신 코드로 변환하여 실행합니다.
        
2. **운영체제 독립성 제공**
    
    - 자바의 **“Write Once, Run Anywhere”** 철학을 가능하게 하는 핵심 요소입니다.
        
    - 한 번 컴파일된 바이트코드는 JVM이 설치된 어떤 OS나 하드웨어 환경에서도 동일하게 실행됩니다.
        
3. **메모리 관리 (Garbage Collection)**
    
    - JVM은 프로그램에서 사용되는 메모리를 **힙(Heap)**과 **스택(Stack)** 영역으로 관리합니다.
        
    - 사용이 끝난 객체를 자동으로 회수하는 **Garbage Collector(GC)**를 내장하고 있어 메모리 누수를 줄입니다.
        
4. **보안 및 예외 처리**
    
    - 바이트코드 검증(Bytecode Verifier)을 통해 악성 코드 실행을 방지합니다.
        
    - 예외(Exception) 처리 메커니즘을 제공하여 안정적인 실행을 지원합니다.
        
5. **런타임 환경 제공**
    
    - 클래스 로딩(Class Loader), 실행 엔진(Execution Engine), 네이티브 인터페이스(JNI) 등을 통해 애플리케이션 실행에 필요한 런타임 환경을 제공합니다.
        

---
**JVM의 구조**

1. **클래스 로더(Class Loader)**
    
    - `.class` 파일을 메모리로 로드하고, 링크(Linking)와 초기화를 수행합니다.
        
2. **런타임 데이터 영역(Runtime Data Areas)**
    
    - **메서드 영역(Method Area):** 클래스 메타데이터, 정적 변수, 상수 풀 저장.
        
    - **힙(Heap):** 객체가 저장되는 영역, GC의 관리 대상.
        
    - **스택(Stack):** 메서드 호출 시 생성되는 프레임을 저장.
        
    - **PC 레지스터:** 현재 실행 중인 명령어의 주소 저장.
        
    - **네이티브 메서드 스택:** JNI 호출 시 사용.
        
3. **실행 엔진(Execution Engine)**
    
    - **인터프리터:** 바이트코드를 한 줄씩 해석 실행.
        
    - **JIT 컴파일러:** 자주 실행되는 코드를 네이티브 코드로 변환해 성능 향상.
        
    - **Garbage Collector:** 메모리 관리 자동화.
        

---
**정리**

JVM은 **자바 프로그램을 하드웨어와 OS에 독립적으로 실행할 수 있게 하는 가상 컴퓨터**이자, **메모리 관리와 보안을 책임지는 런타임 환경**입니다.  
만약 JVM이 없다면, 자바 프로그램은 현재처럼 다양한 플랫폼에서 동일하게 실행될 수 없습니다.
##### 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
✅ JVM 위에서 실행 가능한 다른 언어들

|언어|특징|
|---|---|
|**Kotlin**|JetBrains에서 개발, 자바와 100% 상호운용 가능. Android 공식 언어.|
|**Scala**|함수형 + 객체지향, 고급 언어 기능. Spark의 주요 언어.|
|**Groovy**|자바 문법 기반의 동적 스크립트 언어, Gradle에 사용됨.|
|**Clojure**|함수형, Lisp 계열 언어. 불변성과 병렬처리 강조.|
|**JRuby**|Ruby를 JVM에서 실행할 수 있게 만든 구현체.|
|**Jython**|Python 2.x 문법을 JVM 위에서 실행 가능. (현재는 거의 사용 안 됨)|
|**Ceylon, Fantom, Frege, Xtend 등**|JVM 기반으로 개발된 다양한 실험적 언어들|

---

🧠 왜 다른 언어들도 JVM 위에서 실행 가능한가요?

JVM은 자바에 특화된 것이 아니라 **“바이트코드”라는 중간 표현을 실행**하는 구조입니다.  
즉, 자바가 아닌 언어도 **“JVM 바이트코드로 컴파일”만 하면** JVM에서 실행할 수 있습니다.

🧩 장점

- **운영체제 독립성**: 어떤 언어든 JVM 위에서 돌아가면 플랫폼 독립성 확보.
    
- **기존 Java 생태계 활용**: Java 라이브러리, 프레임워크 사용 가능.
    
- **성능**: JVM의 JIT 컴파일러, GC 등을 그대로 활용.
    

⚠️ 단점

- **자바 중심 최적화**: JVM은 기본적으로 자바 스타일 코드에 최적화됨.
    
- **언어 특성 제한**: 언어 고유 기능을 JVM이 지원하지 않을 수 있음.
    
- **바이트코드 제약**: 일부 언어 표현은 JVM 바이트코드로 변환하기 까다로움.
    
✅ 결론

> JVM은 **자바 전용이 아닙니다.**  
> **“JVM 바이트코드로 컴파일될 수 있는 언어라면 모두 실행 가능합니다.”**

자바 외에도 Kotlin, Scala, Groovy처럼 **JVM 생태계의 장점을 공유하며 성장한 언어들**이 존재합니다.
##### 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
JVM 계열 언어(예: Java, Kotlin, Scala)는 기본적으로 **JVM 바이트코드(`.class`)를 생성**해 JVM 위에서 실행되도록 설계되었기 때문에 **“일반적인 기계어 바이너리(네이티브 코드)”로 직접 컴파일해 실행**하는 것은 표준 방식이 아닙니다.  
그러나, **특수한 도구나 컴파일러를 사용하면 JVM 없이도 실행할 수 있는 네이티브 바이너리를 만들 수 있습니다.**

---
 **1. JVM 계열 언어를 네이티브로 컴파일할 수 있는 방법**

 **(1) GraalVM Native Image**

- **Java, Kotlin, Scala** 등의 JVM 언어를 **Ahead-Of-Time(AOT)** 컴파일하여 **JVM 없이 실행 가능한 네이티브 실행 파일**을 생성합니다.
    
- **장점:** 시작 속도가 매우 빠르고 메모리 사용량이 줄어듭니다.
    
- **단점:** 빌드 속도가 느리고 리플렉션이나 동적 로딩 지원이 제한될 수 있습니다.
    

---
 **(2) Kotlin/Native**

- Kotlin은 JVM뿐만 아니라 **LLVM 백엔드**를 통해 **iOS, Windows, Linux** 등에서 동작하는 **네이티브 코드로 변환**할 수 있습니다.
    
- 예: 안드로이드 앱에서는 JVM을 쓰지만, iOS 앱에서는 Kotlin/Native로 기계어 코드 생성.
    

 **(3) Excelsior JET (단종)**

- 자바 바이트코드를 **기계어로 직접 컴파일해 실행 파일**로 만드는 상용 솔루션이 있었으나 현재는 개발 중단.
    

---
 **2. 왜 기본적으로 JVM에서 실행되도록 설계되었나?**

1. **운영체제/하드웨어 독립성**
    
    - 한 번 컴파일된 `.class` 파일은 어떤 OS에서든 JVM만 있으면 실행 가능 (**WORA – Write Once, Run Anywhere**).
        
2. **JIT 컴파일러 최적화**
    
    - JVM은 런타임에 자주 실행되는 코드만 **Just-In-Time(동적 최적화)**으로 네이티브 코드로 변환하여 성능을 높임.
        
3. **풍부한 생태계**
    
    - Java 라이브러리, Spring, JPA 등 대부분의 프레임워크가 **JVM 환경**을 전제로 동작.
        

---
 **3. 정리**

- **JVM 언어를 네이티브 코드로 변환하는 것은 가능하지만, 일반적인 접근은 아님.**
    
- **GraalVM Native Image** 또는 **Kotlin/Native** 같은 도구를 사용해야 하며,  
    이런 방식은 **“시작 속도 최적화”나 “JVM 없는 환경(iOS, 서버리스)”에서만 주로 활용**됩니다.
    

---
##### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
**가상머신(Virtual Machine, VM)**을 사용하면 **하드웨어나 운영체제 위에 추상화된 실행 환경**을 제공하여, 프로그램을 실제 물리 하드웨어 대신 **가상의 환경에서 실행**할 수 있습니다.  
대표적으로 Java의 **JVM**이나 시스템 가상화 기술인 **VMware, VirtualBox** 등이 있습니다.

VM 사용은 **높은 이식성, 격리성**을 제공하지만, **성능 저하와 관리 복잡성** 같은 단점도 있습니다.

---
 **1. VM을 사용함으로써 얻는 장점**

 **(1) 플랫폼 독립성 (이식성)**

- 애플리케이션은 VM 위에서 실행되므로 **하드웨어나 OS에 종속되지 않음**.
    
- 예: Java는 JVM만 설치되어 있으면 Windows, Linux, macOS에서 동일한 `.class` 파일을 실행할 수 있습니다.
    
 **(2) 보안 및 격리성**

- VM은 호스트 OS와 **격리된 실행 환경**을 제공하므로, 애플리케이션 오류나 악성 코드가 호스트 시스템에 직접 영향을 주지 않습니다.
    

 **(3) 관리 용이성**

- VM 이미지를 생성하면 **환경을 그대로 복제, 배포, 백업**할 수 있습니다.
    
- 운영체제 환경을 테스트할 때 매우 유용합니다.
    

 **(4) 호환성 확보**

- 오래된 소프트웨어를 새로운 OS에서 실행하거나, 특정 OS 환경이 필요한 소프트웨어를 VM 위에서 구동할 수 있습니다.
    

 **(5) 리소스 효율적 사용**

- 하이퍼바이저 기반 VM에서는 **하나의 물리 서버 위에서 여러 VM이 동작**해 자원을 효율적으로 사용 가능.
    
- 클라우드 서비스(AWS EC2, GCP Compute Engine 등)의 기반 기술이 바로 VM.
    

---

 **2. VM을 사용할 때의 단점**

 **(1) 성능 저하**

- VM은 **하드웨어를 직접 사용하는 것이 아니라 소프트웨어 계층(가상화 계층)을 거쳐 접근**하므로, 네이티브 실행보다 느립니다.
    
- 예: JVM도 바이트코드를 JIT 컴파일로 변환해야 하므로 네이티브 언어(C/C++)보다 초기 성능이 떨어질 수 있습니다.
    
 **(2) 높은 메모리/리소스 사용량**

- VM은 **게스트 OS + 애플리케이션**을 모두 실행해야 하므로, 호스트 OS 대비 메모리와 CPU 사용량이 큽니다.
    

 **(3) 관리 복잡성**

- VM이 많아지면 OS 업데이트, 보안 패치, 이미지 관리가 복잡해집니다.
    

 **(4) 딜레이(시작 속도)**

- VM 부팅은 물리 서버나 단일 애플리케이션 실행보다 시간이 오래 걸립니다.
    
- JVM도 애플리케이션 실행 시 **클래스 로딩과 바이트코드 해석 과정** 때문에 초기 구동이 느릴 수 있습니다.
    

 **(5) 디버깅 어려움**

- VM 계층 때문에 **호스트와 VM 간의 문제 원인 분석이 어렵거나** 성능 병목을 추적하기 힘들 수 있습니다.
    

---

 **3. VM vs 네이티브 실행의 트레이드오프**

- **VM 장점:** 이식성, 보안, 격리성, 유지보수 용이성.
    
- **VM 단점:** 네이티브보다 **성능(속도, 메모리 효율)**이 떨어질 수 있음.
    

---
 **4. 정리**

> **VM은 "유연성과 이식성"을 제공하지만, "성능과 리소스 사용량"에서 네이티브 실행보다 불리합니다.**  
> 최근에는 성능 저하를 최소화하기 위해 **JIT 컴파일러, GraalVM, 컨테이너(Docker)** 등 VM의 단점을 보완하는 기술들이 함께 사용됩니다.
##### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
정확히 말하면, **JVM과 그 내부에서 실행되는 자바 프로그램은 "부모-자식 프로세스" 관계로 볼 수 없습니다.**  
그 이유는 **JVM 자체가 하나의 프로세스**이며, 자바 애플리케이션(클래스, 메서드 등)은 JVM 프로세스 안에서 **스레드로 동작**하기 때문입니다.

---
 **1. JVM은 하나의 프로세스다**

- 자바 애플리케이션을 실행하면 OS는 `java` 실행 파일을 로드하고, 이를 **하나의 독립된 프로세스**로 실행합니다.
    
- 이후 JVM 프로세스는 **클래스 로딩, 바이트코드 실행(인터프리팅/JIT 컴파일), GC, 스레드 관리** 등의 작업을 수행합니다.
    
- **자바 애플리케이션의 main 메서드 또한 JVM 프로세스 내부의 "스레드(메인 스레드)"로 동작합니다.**
    

---
 **2. 부모-자식 프로세스 관계가 아닌 이유**

- 부모-자식 프로세스 관계는 **OS 레벨에서 fork()나 exec()** 같은 시스템 콜로 새로운 프로세스를 생성할 때 형성됩니다.
    
- JVM에서 실행되는 자바 프로그램은 **별도의 OS 프로세스가 아니라, JVM 프로세스 내부의 실행 로직**에 불과합니다.
    
- 따라서 JVM과 자바 프로그램은 **하나의 프로세스 내에서 동작하는 "런타임 환경과 애플리케이션 코드"** 관계입니다.
    

---
 **3. 예외적 상황**

- 자바 애플리케이션이 `ProcessBuilder`나 `Runtime.exec()`을 통해 **외부 명령어를 실행하면**, 해당 외부 프로그램은 **JVM의 자식 프로세스**로 생성됩니다.
    
    java
    
    복사편집
    
    `Process process = Runtime.getRuntime().exec("ls -al");`
    
    이 경우 `ls` 명령은 JVM의 자식 프로세스가 맞습니다.
    

---
 **4. 올바른 표현**

- **JVM = 프로세스**
    
- **자바 애플리케이션(main, Thread 등) = JVM 프로세스 내부의 스레드**
    
- 부모-자식 프로세스 관계는 JVM과 OS 외부 프로그램 간에만 발생할 수 있습니다.
    

---
 **5. 정리**

> **JVM과 내부에서 실행되는 자바 프로그램은 프로세스-프로세스 관계가 아니라, 프로세스(JVM)-스레드(자바 애플리케이션) 관계입니다.**  
> 다만, 자바 프로그램이 외부 명령을 실행한다면 그 외부 명령은 JVM의 자식 프로세스가 됩니다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
##### 설명:
`final` 키워드는 **자바에서 불변성(immutability) 또는 변경 불가능성을 보장하는 데 사용**됩니다. 상황에 따라 클래스, 메서드, 변수에 붙을 수 있으며, 각각 다른 의미와 장점이 있습니다.

---

**1. `final`의 사용 대상과 의미**

 **(1) 변수에 사용**

- **의미:** 변수의 값을 한 번만 할당할 수 있도록 제한합니다.
    
    - **기본 타입:** 값 자체가 변경 불가.
        
    - **참조 타입:** 객체의 참조 주소가 변경 불가(하지만 객체 내부 상태는 변경될 수 있음).
**(2) 메서드에 사용**

- **의미:** 메서드를 오버라이드(override)할 수 없습니다.
    
- **예시:**
    
```java
class Parent {
    public final void show() {
        System.out.println("Can't override me");
    }
}
class Child extends Parent {
    // @Override
    // public void show() { } // 컴파일 에러

```
 **(3) 클래스에 사용**

- **의미:** 상속할 수 없는 클래스가 됩니다.
    
- **예시:**  
    `java.lang.String`, `java.lang.Math` 클래스는 `final`로 선언되어 상속 불가.
    
 **2. `final` 키워드의 장점**
 **(1) 코드 안정성 확보**

- 변수 값을 실수로 변경하거나 상속/오버라이딩으로 인한 예기치 못한 동작을 방지할 수 있습니다.
    
**(2) 불변 객체(Immutable Object) 구현**

- `final`을 멤버 변수에 적용하고 setter를 제거하면 **스레드 안전(Thread-Safety)** 한 객체를 만들 수 있습니다.
    
- 예: `String` 클래스가 `final`이기 때문에 불변성을 보장하고 멀티스레드 환경에서 안전합니다.
    
**(3) 성능 최적화 (JVM 최적화 힌트)**

- `final` 메서드는 오버라이드가 불가능하므로, **JVM JIT 컴파일러가 인라이닝(inlining)** 최적화를 쉽게 적용할 수 있습니다.
    
- 상속 관계에서 메서드 호출 시 발생하는 **동적 디스패치 비용**을 줄일 수 있습니다.
    
 **(4) 설계 의도 명확화**

- 특정 클래스나 메서드가 확장되거나 변경되지 않기를 원할 때 `final`을 명시적으로 사용하면, 코드의 의도를 분명히 할 수 있습니다.
    

---
3. `final`의 한계**

- 불필요하게 `final`을 남발하면 테스트나 확장성이 떨어질 수 있습니다.  
    (예: 모든 메서드를 `final`로 만들면 상속 기반 구조에 제약 발생)
    
- 참조 타입의 `final`은 객체 내부 상태까지 불변하게 만들지는 않기 때문에, **진정한 불변 객체를 위해서는 별도 설계(Immutable Pattern)** 가 필요합니다.
    

 **정리**

> `final`은 **“변경 불가능성”을 보장하여 안정성과 최적화를 돕는 키워드**입니다.  
> 특히 불변 객체 설계와 성능 최적화에서 중요한 역할을 하며, 코드의 의도를 명확히 전달할 수 있습니다.
##### 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
네, **`final` 키워드는 컴파일 과정에서 일반 변수나 메서드와 다르게 취급됩니다.**  
컴파일러와 JVM은 `final`이 붙은 요소가 **절대 변하지 않는다는 사실을 알고 최적화**할 수 있기 때문입니다.

---
**1. `final` 변수의 컴파일 과정**

- **`final` 상수(`static final`)는 컴파일 타임 상수로 취급**됩니다.
```java
public class Test {
    public static final int CONST = 10;
}

    
```
        
    다른 클래스에서 `Test.CONST`를 참조하면, **컴파일 시 값 `10`으로 대체(inline)** 됩니다.
        
- **`final` 지역 변수나 필드도 컴파일러가 “절대 재할당 불가”라는 사실을 알기 때문에 상수 취급**하며, 인라이닝이나 값 추론(Constant Folding) 같은 최적화가 가능합니다.
    

---
**2. `final` 메서드의 컴파일 과정**

- 메서드에 `final`이 붙으면 **JVM은 동적 디스패치(virtual method table lookup)를 거치지 않고 직접 호출**할 수 있습니다.
    
- 보통 오버라이드 가능한 메서드는 실행 시점에 **가상 메서드 테이블(V-Table)** 을 통해 어떤 구현을 호출할지 결정합니다.
        
 - 하지만 `final` 메서드는 **오버라이드가 불가능하므로 호출 대상이 컴파일 시점에 확정**, 호출 비용을 줄일 수 있습니다.
        
  - JIT 컴파일러가 `final` 메서드를 인라인으로 변환하기가 훨씬 수월합니다.
        

---
**3. `final` 클래스의 컴파일 과정**

- 클래스가 `final`이면 상속이 불가능하기 때문에, **JVM이 메서드 호출 시 “다형성 검사”를 생략**할 수 있습니다.
    
- 예를 들어, `String`은 `final`이기 때문에 `"abc".substring(1)` 호출 시 **항상 `String`의 `substring()` 메서드를 직접 실행**하도록 최적화할 수 있습니다.
    

---
 **4. JIT 컴파일러 관점에서의 최적화**

- 런타임 시 JIT(Just-In-Time) 컴파일러는 `final` 키워드를 확인하고:
    
    - **상수 값 인라이닝** (예: `final int x = 10;` → 직접 10으로 대체)
        
    - **메서드 인라이닝** (함수 호출을 제거하고 코드 삽입)
        
    - **Dead Code 제거** (변하지 않는 값 기반의 코드 최적화)  
        를 적용할 수 있습니다.
        

---
 **정리**

- 컴파일러는 `final` 키워드를 통해 **“변하지 않음”을 보장받아 더 강력한 최적화를 수행**합니다.
    
- 특히 `static final` 상수는 **컴파일 타임에 값이 확정**되어 다른 클래스에서 **직접 값이 삽입(inline)**됩니다.
    
- `final` 메서드는 **가상 메서드 호출 비용을 제거하고 인라이닝 최적화를 가능**하게 합니다.

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
##### 설명
**1. 공통점**

- **인스턴스화 불가:** 둘 다 직접 객체를 생성할 수 없습니다.
- **추상 메서드 포함 가능:** 구현을 강제할 수 있습니다.
- **다형성 제공:** 부모 타입(인터페이스/추상 클래스)으로 자식 객체를 참조할 수 있습니다.
    

---
 **2. 차이점 비교**

| 구분         | 인터페이스 (Interface)                                              | 추상 클래스 (Abstract Class)                     |
| ---------- | -------------------------------------------------------------- | ------------------------------------------- |
| **목적**     | **기능(행동)의 약속**: “이런 기능을 제공하겠다”는 규격 제공                          | **공통된 속성과 동작의 공유**: 상속받는 클래스에 **기본 구현** 제공  |
| **메서드**    | 기본적으로 **추상 메서드만 선언 가능** (Java 8 이후 `default`, `static` 메서드 허용) | **추상 메서드 + 일반 메서드(구현 포함)** 모두 가능            |
| **필드**     | **`public static final` (상수)만 선언 가능**                          | **인스턴스 변수(상태) 선언 가능**                       |
| **상속**     | **다중 구현 허용** (클래스는 여러 인터페이스를 구현 가능)                            | **단일 상속만 허용**                               |
| **접근 제어자** | 메서드는 암묵적으로 `public abstract` (default/static 제외)               | `public`, `protected`, `private` 자유롭게 사용 가능 |
| **생성자**    | 없음                                                             | 생성자 가질 수 있음                                 |
| **상속 키워드** | `implements` 사용                                                | `extends` 사용                                |

---
 **3. 사용 예시**

 **인터페이스 예시**

```java
interface Flyable {
    void fly();  // 추상 메서드
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

```

- **의미:** “날 수 있다”라는 기능을 약속.
    
- `Flyable`을 구현하는 모든 클래스는 반드시 `fly()`를 구현해야 합니다.
    

추상 클래스 예시**
```java
abstract class Animal {
    String name;

    abstract void makeSound();  // 추상 메서드

    void eat() {                // 일반 메서드
        System.out.println(name + " is eating");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

```
- **의미:** `Animal`은 공통 속성(`name`)과 공통 동작(`eat()`)을 제공하고, `makeSound()`는 서브클래스가 구현하도록 강제합니다.
    

---
**4. 언제 사용해야 할까?**

- **인터페이스**:
    
    - **“~할 수 있다”**(Can do) 같은 **기능의 명세**를 정의할 때.
        
    - 서로 다른 클래스들이 동일한 행동을 보장해야 할 때 (예: `Comparable`, `Runnable`).
        
    - 다중 상속(여러 동작 인터페이스 구현)이 필요할 때.
        
- **추상 클래스**:
    
    - **공통된 속성(필드)과 기본 동작(메서드)을 공유**해야 할 때.
        
    - 클래스 계층구조에서 **코드 재사용**이 필요한 경우.
        

---

**5. Java 8 이후의 변화**

- 인터페이스에서도 `default` 메서드를 정의하여 **기본 구현을 제공**할 수 있게 되었고,  
    추상 클래스와의 차이가 줄어들었지만 **“상태(필드)”를 가질 수 없다는 점**에서 여전히 차이가 존재합니다.
    

---
 **정리**

> **인터페이스**는 **“무엇을 할 수 있는가(기능의 약속)”**,  
> **추상 클래스**는 **“무엇을 가지고 있고, 기본적으로 어떻게 동작하는가(공통 구현)”**를 제공하는 데 초점을 둡니다.
##### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
그 이유는 **언어 설계 철학과 다중 상속의 문제점**에서 비롯됩니다.

 **1. 클래스 다중 상속의 문제점**

클래스는 **상태(필드)**와 **행동(메서드 구현)**을 모두 포함할 수 있기 때문에, 다중 상속 시 **모호성(Ambiguity)** 문제가 발생합니다.

 **대표적인 다이아몬드 문제 (Diamond Problem)**
```java
class A {
    void hello() { System.out.println("Hello from A"); }
}

class B extends A {
    void hello() { System.out.println("Hello from B"); }
}

class C extends A {
    void hello() { System.out.println("Hello from C"); }
}

// 다중 상속이 가능하다고 가정
class D extends B, C {
    // D.hello() 호출 시, B와 C 중 어느 hello()를 써야 할까?
}

```

- `D`가 `B`와 `C`를 동시에 상속하면 **같은 메서드 시그니처를 가진 `hello()`가 2개 생기므로 호출 우선순위가 모호**해집니다.
    
- 이 모호성을 해결하려면 언어 차원에서 복잡한 규칙(예: C++의 가상 상속)을 도입해야 하는데, **자바는 단순성과 명확성을 위해 클래스 다중 상속을 금지**했습니다.
    

---
**2. 인터페이스는 상태를 가지지 않기 때문**

- 인터페이스는 **필드를 가질 수 없고(상수 `public static final`만 가능)**, 기본적으로 **메서드의 구현을 포함하지 않습니다**(Java 8 이전).
    
- 즉, **상태 충돌 문제**가 발생하지 않습니다.
    
- 다중 구현을 하더라도 **충돌하는 데이터 필드나 상속 체계 모호성**이 없기 때문에 안전하게 허용됩니다.
    

---

**3. Java 8 이후 default 메서드가 생겼는데 왜 여전히 다중 구현이 가능할까?**

- Java 8부터 인터페이스에 `default` 메서드가 생기면서 메서드 구현이 가능해졌지만,  
    **메서드 충돌이 발생하면 반드시 구현 클래스에서 오버라이딩(재정의)하여 해결해야 한다는 규칙**이 추가되었습니다.
    
```java
interface A { default void hello() { System.out.println("A"); } }
interface B { default void hello() { System.out.println("B"); } }

class C implements A, B {
    @Override
    public void hello() {  // 충돌 해결
        A.super.hello();   // 명시적으로 A의 hello 호출
    }
}

    
```
    
    이렇게 **명시적으로 어느 인터페이스의 메서드를 사용할지 지정**할 수 있어 충돌 문제가 해결됩니다.
    

---
 **4. 결론**

- **클래스:** 상태와 구현을 포함하므로 다중 상속 시 모호성과 충돌 문제가 발생 → **단일 상속만 허용.**
    
- **인터페이스:** 상태를 가지지 않고 **행동(계약)만 정의**하기 때문에 충돌 위험이 없음 → **다중 구현 가능.**
    
- **Java 8 이후에도 다중 구현 충돌은 `super` 키워드로 명시적으로 해결하도록 규칙화** → 안전하게 다중 인터페이스 구현 유지 가능.

### 4. 리플렉션에 대해 설명해 주세요.
##### 설명
**리플렉션(Reflection)**은 **런타임(runtime)에 클래스나 객체의 메타데이터(클래스 정보, 메서드, 필드 등)를 동적으로 조사하고 조작할 수 있는 기능**을 말합니다.  
즉, **코드가 실행 중에 자기 자신을 들여다보고 수정할 수 있게 해주는 메커니즘**입니다.

---
**1. 리플렉션의 특징**

- **컴파일 타임이 아닌 런타임에 클래스 정보를 다룸.**
    
- 객체의 **클래스 이름, 메서드 목록, 필드, 생성자** 등에 접근 가능.
    
- 접근 제어자(`private`, `protected`)를 무시하고 필드/메서드에 접근할 수 있음 (`setAccessible(true)`).
    
- 동적으로 객체를 생성하거나 메서드를 호출할 수 있음.
    

---
 **2. 리플렉션의 주요 사용 예**
```java
Class<?> clazz = Class.forName("com.example.MyClass");  // 클래스 로드

// 객체 생성
Object obj = clazz.getDeclaredConstructor().newInstance();

// 메서드 호출
Method method = clazz.getDeclaredMethod("sayHello");
method.invoke(obj);

// 필드 접근
Field field = clazz.getDeclaredField("name");
field.setAccessible(true);
field.set(obj, "Reflection Test");

```

---
3. 리플렉션의 장점**
	1. **유연한 동적 처리**
	    
	    - 실행 시점에 클래스 이름만 알고 있어도 동작 가능.
	        
	    - 예: JDBC 드라이버 로딩(`Class.forName("com.mysql.jdbc.Driver")`).
	        
	2. **프레임워크와 라이브러리 구현에 필수적**
	    
	    - 스프링(Spring)의 DI(의존성 주입), JPA 엔티티 매핑, Jackson JSON 직렬화 등 대부분의 자바 프레임워크는 리플렉션을 사용.
	        
	3. **일반 코드로는 접근 불가능한 정보 활용 가능**
	    
	    - `private` 필드나 메서드를 런타임에 강제로 접근 가능.
        

---
**4. 리플렉션의 단점**

1. **성능 저하**
    
    - 메서드 호출 시 직접 호출보다 **약 20배 이상 느릴 수 있음**(런타임 검사 및 메타데이터 탐색 비용).
        
2. **컴파일 타임 타입 체크 불가**
    
    - 리플렉션을 잘못 사용하면 런타임에 `NoSuchMethodException`, `IllegalAccessException` 등 에러가 발생할 수 있음.
        
3. **캡슐화 위반**
    
    - `private` 멤버에 강제 접근할 수 있어 객체지향 설계를 깨뜨릴 수 있음.
        

---
5. 리플렉션이 많이 쓰이는 곳**

- **프레임워크/라이브러리 내부**  
    (Spring, Hibernate, Jackson, JUnit)  
    → 컴파일 시점에 타입을 몰라도 객체 생성, 메서드 실행, 의존성 주입 등을 해야 하므로 필수적.
    
- **어노테이션 처리**  
    예: `@Autowired`, `@Entity` 같은 어노테이션의 메타데이터를 리플렉션으로 읽어 동작.
    
- **런타임 플러그인/모듈 로딩**  
    → 특정 클래스나 메서드를 동적으로 로딩하고 실행할 때 사용.
    

---
**6. 결론**

> **리플렉션은 런타임에 프로그램 구조를 조작할 수 있는 강력한 도구이지만, 성능 저하와 캡슐화 파괴 가능성이 있으므로 필요한 경우에만 신중히 사용하는 것이 권장됩니다.**
##### 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
맞습니다. **리플렉션은 보안적인 문제를 일으킬 가능성이 있습니다.**  
리플렉션은 `private` 필드나 메서드에도 접근할 수 있기 때문에, 원래 의도한 **캡슐화(encapsulation)**를 깨뜨리고, 잘못 사용되면 **보안 취약점**으로 이어질 수 있습니다.

---
1. 리플렉션의 보안 문제 사례**

2. **`private` 필드 접근**
```java
Field field = SomeClass.class.getDeclaredField("password");
field.setAccessible(true);  // 접근 제한 해제
String pwd = (String) field.get(obj);

    
```
    원래 외부에서 접근할 수 없는 비밀번호 필드에 접근할 수 있습니다.
    
3. **불법적인 메서드 호출**
    
    - 접근 불가한 메서드(예: 관리자 전용 메서드)를 `invoke()`로 호출 가능.
        
4. **클래스 로딩 시 악성 코드 주입**
    
    - `Class.forName("com.hacker.MaliciousClass")` 로 동적 로딩 가능.  
        만약 외부 입력을 그대로 클래스명으로 사용할 경우, 공격자가 의도한 클래스가 실행될 수 있습니다.
        
5. **시스템 클래스 변조**
    
    - `java.lang.reflect` 패키지를 이용하면 JDK 내부 클래스나 필드를 조작할 수 있어 예기치 못한 동작을 유발할 수 있습니다.
        

---
2. 보안 문제를 방지하는 방법**
(1) SecurityManager (자바 17 이전)**
하지만 자바 17부터 `SecurityManager`는 **Deprecated** 되었으므로 대체 수단이 필요합니다.
    

**(2) 모듈 시스템 (Java 9+)**

- Java 9부터 도입된 **모듈 시스템(Jigsaw)** 을 사용하면 **모듈 간 리플렉션 접근을 제한**할 수 있습니다.
```java
module my.module {
    exports com.myapp;
    opens com.myapp.internal to specific.module; // 제한적 리플렉션 허용
}

```
**(3) 클래스 로딩 시 화이트리스트 검증**

- `Class.forName()` 등을 사용할 때 **외부 입력값을 그대로 사용하지 않고**, 허용된 클래스 목록(화이트리스트)을 확인해야 합니다.
    
(4) `setAccessible(true)` 최소화**

- 꼭 필요한 경우에만 사용하고, 라이브러리에서 남용하지 않도록 주의해야 합니다.
    
- Java 9 이상에서는 `setAccessible(true)` 호출 시 **권한 제한 경고**가 발생하며, `--illegal-access=deny` 옵션으로 차단할 수 있습니다.
    
 **(5) 보안 정책 파일 (policy file) 설정**

- 권한이 필요한 코드 영역에 대해 `ReflectPermission`을 제한하는 보안 정책을 설정할 수 있습니다.
    
 **3. 실제 보안적 관점에서의 판단**

- **일반 애플리케이션 코드에서 리플렉션을 남용하는 것은 권장되지 않습니다.**
    
- 하지만 **프레임워크나 라이브러리 수준에서는 필수적**입니다. (예: 스프링 DI, Hibernate 엔티티 매핑)
    
- **보안적으로 민감한 객체(암호키, 인증정보 등)는 리플렉션 접근 방지를 위한 설계(예: SecurityManager 대체 수단, final 클래스, 모듈화)와 정책이 필요**합니다.
    
 **4. 결론**

> 리플렉션은 **강력하지만 위험할 수 있는 도구**입니다.  
> 보안적으로 민감한 시스템에서는 **모듈화, 접근 제어, 화이트리스트 검증, 권한 정책** 등을 조합하여 사용을 제한해야 합니다.
##### 리플렉션을 언제 활용할 수 있을까요?
리플렉션(Reflection)은 **일반적인 애플리케이션 코드에서 매번 사용하는 도구는 아니지만**, **동적인 동작**이나 **프레임워크/라이브러리 개발** 시 매우 유용하게 활용됩니다.

다음은 **리플렉션을 사용하기 적합한 주요 상황**입니다.

---
**1. 컴파일 시점에 타입을 알 수 없는 경우**

- 런타임에 클래스나 메서드 이름이 결정되는 경우 유용합니다.
    
```java
// 클래스 이름을 문자열로만 알고 있는 상황
Class<?> clazz = Class.forName("com.example.MyClass");
Object obj = clazz.getDeclaredConstructor().newInstance();
 
```
- **활용 예:**
    - 플러그인 시스템 (외부에서 로딩되는 모듈 실행)
    - 런타임에 입력받은 클래스명/메서드명을 기반으로 동적 호출
        

---
 **2. 프레임워크 및 라이브러리 내부**

- **Spring**, **Hibernate**, **JUnit**, **Jackson** 등 수많은 자바 프레임워크는 리플렉션을 핵심적으로 활용합니다.
    
    - **Spring DI (의존성 주입)**:  
        `@Autowired` 필드를 리플렉션으로 찾아서 객체를 주입.
        
    - **Hibernate/JPA**:  
        엔티티 클래스의 필드 정보를 리플렉션으로 읽어 DB 컬럼과 매핑.
        
    - **JUnit**:  
        테스트 메서드(`@Test`)를 런타임에 찾아 자동 실행.
        
    - **Jackson/Gson**:  
        클래스 필드/Getter를 리플렉션으로 찾아 JSON 직렬화/역직렬화.
        

---
 **3. 어노테이션(Annotation) 기반 처리**

- 어노테이션 정보를 런타임에 읽어 동작을 제어할 때 사용됩니다.
    
```java
Method method = clazz.getDeclaredMethod("myMethod");
if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
    // 어노테이션이 붙은 메서드만 실행
    method.invoke(obj);
}

```

---
4. 직렬화/역직렬화 및 매핑**

- **객체 → JSON** 또는 **JSON → 객체** 변환 시 리플렉션으로 필드를 탐색하고 값 할당.
    
- **ORM(Object Relational Mapping)** 프레임워크가 DB 테이블과 클래스 필드를 매핑할 때 사용.
    

---
**5. 디버깅, 로깅, 테스트**

- 테스트 코드에서 **비공개 필드(`private`)에 접근**해 상태를 확인할 때.
    
- 런타임에 객체의 구조를 확인하여 **자동 로깅**이나 **디버깅 도구**를 만들 때.
    

---
**6. 유연한 API 설계**

- 클래스 구조가 변경되더라도, 리플렉션을 통해 **필드명/메서드명을 문자열로 참조**하면 코드 수정 없이 동작할 수 있습니다.
    
    - 예: **스프링 BeanFactory**가 Bean을 문자열 이름으로 찾아 인스턴스화.
        

 **정리**

리플렉션은 **정적 타입 시스템으로는 불가능한 동적 동작**을 가능하게 해주는 도구입니다.  
특히 **프레임워크, ORM, 어노테이션 기반 라이브러리**에서 핵심 역할을 하며, **런타임에 타입을 모르는 상황에서 객체를 생성하거나 메서드를 호출할 때** 유용합니다.
### 5. static class와 static method를 비교해 주세요.
##### 설명
`static class`와 `static method`는 **static 키워드를 클래스와 메서드에 적용한 것**이지만, 의미와 용도가 완전히 다릅니다.

---
1. static method (정적 메서드)**
**특징**

- **클래스 레벨에서 동작**하며, 인스턴스 생성 없이 호출 가능.
    
- `this` 키워드를 사용할 수 없음 (인스턴스 변수 접근 불가).
    
- 클래스 로딩 시 메모리에 올라가며, 공유 자원 역할을 함.
    
- **객체 상태와 관계없는 기능(유틸리티 메서드)**에 적합.
    
**예시**

```java
class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }
}

int sum = MathUtil.add(5, 10);  // 객체 생성 없이 호출

```
 **2. static class (정적 클래스)**

자바에서 **클래스 자체에 `static`을 붙일 수는 없습니다.**  
다만, **“static 중첩 클래스(Static Nested Class)”**를 만들 수 있습니다.

 **특징**

- 외부 클래스의 인스턴스에 **종속되지 않는 중첩 클래스**를 의미.
    
- 외부 클래스의 `static` 멤버만 접근 가능 (`non-static` 멤버 접근 불가).
    
- **독립적인 클래스처럼 사용 가능**하여, 외부 클래스 객체 없이 인스턴스화할 수 있습니다.
    
 **예시**

```java
class Outer {
    static class Inner {  // Static Nested Class
        void print() {
            System.out.println("Static nested class");
        }
    }
}

Outer.Inner inner = new Outer.Inner();  // Outer 객체 없이 생성 가능

```

---
**3. 비교 요약**

|구분|**static method**|**static class (중첩 클래스)**|
|---|---|---|
|**적용 대상**|메서드|중첩 클래스(Inner Class)|
|**호출/생성**|클래스 이름으로 직접 호출 가능 (`ClassName.method()`)|외부 클래스 객체 없이 `new Outer.Inner()` 로 생성 가능|
|**목적**|객체 상태와 무관한 **공통 동작 제공**|외부 클래스와 **논리적으로 묶인 클래스**를 독립적으로 사용|
|**this 사용**|불가능|자기 자신에 대한 `this`는 가능|
|**메모리 관리**|클래스 로딩 시 메서드가 메모리에 올라감|외부 클래스 인스턴스와 관계없이 별도로 로딩|

---
 **4. 결론**

- **`static method`는 클래스에 귀속된 함수**이며, 주로 **유틸리티성 메서드**에서 사용됩니다.
    
- **`static class`는 독립적으로 사용할 수 있는 중첩 클래스**로, 외부 클래스의 인스턴스와 무관하게 사용하고자 할 때 유용합니다.

##### static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
`static` 키워드는 **클래스 레벨의 멤버(변수, 메서드, 내부 클래스)를 정의**할 때 사용됩니다.  
이는 **인스턴스와 독립적으로 동작**하게 만들며, **메모리 관리나 호출 방식에서 장점**을 제공합니다. 하지만 동시에 몇 가지 **제약**도 따릅니다.

---
1. static의 주요 이점**
**(1) 인스턴스 생성 없이 접근 가능**

- `static` 멤버는 클래스 로딩 시 메모리에 올라가므로 **객체를 생성하지 않아도 바로 접근**할 수 있습니다.
    
 **(2) 공용 데이터(Shared Data) 관리**

- 모든 인스턴스가 **같은 static 변수**를 공유하므로 **공용 상태를 유지**할 수 있습니다.
    
    `class Counter {     static int count = 0;     Counter() { count++; } } // 모든 Counter 객체가 count를 공유`
    

**(3) 유틸리티 클래스 구현에 유용**

- 상태가 필요 없는 메서드를 묶어서 제공할 때 적합합니다.
    
- 예: `Math`, `Collections`, `Arrays` 클래스.
    
 **(4) 메모리 절약**

- **인스턴스마다 복제되지 않고, 클래스당 하나만 로딩**되므로 메모리 사용량을 줄일 수 있습니다.
    

---
 **2. static의 주요 제약**
 **(1) 인스턴스 변수나 메서드에 접근 불가**

- `static` 메서드는 **객체(인스턴스)의 상태를 알 수 없으므로** `this` 키워드를 사용할 수 없습니다.
    
 **(2) 오버라이딩(Overriding) 불가**

- `static` 메서드는 클래스 레벨에 속하므로 **상속 시 재정의(Overriding)가 불가능**합니다.
    
    - 단, **"메서드 숨김(Method Hiding)"** 형태로 같은 시그니처의 static 메서드를 선언할 수는 있습니다.
        
 **(3) 다형성(Polymorphism) 활용 불가**

- 인스턴스 메서드는 런타임에 동적 바인딩되지만, `static` 메서드는 **컴파일 시점에 정적으로 바인딩**됩니다.
    
 **(4) 가비지 컬렉션(GC) 대상 아님**

- 클래스가 언로드될 때까지 메모리에 상주하므로, 메모리 누수가 발생할 가능성이 있습니다(특히 큰 객체를 static 변수로 유지할 때).
    
 **(5) 동시성 문제**

- `static` 변수는 모든 스레드가 공유하므로, **멀티스레드 환경에서 동기화 이슈**가 발생할 수 있습니다. (e.g., `static` 변수를 갱신하는 경우 `synchronized` 필요)
    

---
 **3. static을 사용하면 좋은 경우**

- **상태를 공유해야 하는 경우:** 예를 들어, 모든 객체가 공유하는 카운터 변수.
    
- **유틸리티성 메서드:** 객체 상태와 무관한 단순 기능 제공 (e.g., `Math`, `Arrays`).
    
- **싱글톤 패턴:** `private static` 인스턴스를 사용하여 전역 접근을 제공.
    

---
 **4. static을 남용하면 생길 문제**

- 객체지향적인 설계가 깨질 수 있음 (모든 상태가 전역화).
    
- 테스트 및 확장성에 불리.
    
- 멀티스레드 환경에서 예기치 못한 동기화 문제 발생 가능.
    

---
 **정리**

> **static의 장점:** 객체 생성 없이 접근 가능, 메모리 절약, 공용 상태 관리, 유틸리티성 메서드 구현.  
> **static의 제약:** 인스턴스 접근 불가, 오버라이딩 불가, 다형성 제한, GC 대상 아님, 동시성 문제.
##### 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
`static` 키워드는 **컴파일러와 JVM이 멤버를 클래스 단위로 관리**하도록 지시합니다.  
즉, **객체(인스턴스)와 분리된 메모리 공간에 로드되고 공유**되며, 호출 및 접근 방식에서도 **컴파일 시점부터 정적으로 처리(static binding)** 됩니다.

---
 **1. 컴파일 시 static 처리 방식**

 **(1) static 변수**

- 컴파일러는 `static` 변수를 **클래스 소속 변수(전역 변수와 유사)**로 인식합니다.
    
- `.class` 파일의 **메서드 영역(Method Area)**에 로딩되며, **클래스가 처음 로드될 때 1회만 메모리에 할당**됩니다.
    
- 각 인스턴스는 `static` 변수를 **공유**하며, `this.variable` 대신 **`ClassName.variable` 형태로 접근하도록 컴파일됩니다.**
    
- **바이트코드 예시 (javap -c)**
    
```java
class Test {
    static int count = 0;
    void inc() { count++; }
}

```
    
    디컴파일 시 `Test.count`로 직접 접근하는 코드가 생성됩니다.
    

---
 **(2) static 메서드**

- 컴파일러는 `static` 메서드를 **클래스 소속 함수로 처리**하고, **인스턴스 메서드와 달리 `this` 참조를 인자로 전달하지 않습니다.**
    
- 호출 시 **정적 바인딩(static binding)** 을 적용합니다.
    
    - 인스턴스 메서드는 **가상 메서드 테이블(v-table)**을 통해 런타임에 호출 대상을 결정하지만, `static` 메서드는 **컴파일 시점에 호출 메서드가 확정**됩니다.
        
- 예시:
    
    java
    
    복사편집
    
    `Test.print(); // 컴파일 시점에 직접 호출로 치환`
    

---
 **(3) static 초기화 블록**

- `static { ... }` 블록은 **클래스 로딩 시점(클래스가 처음 참조될 때)**에 단 한 번 실행됩니다.
    
- 컴파일 시 `.class` 파일의 `<clinit>` (Class Initializer) 메서드로 변환됩니다.
    
- 예시:
    
    java
    
    복사편집
    
    `class InitExample {     static int x;     static { x = 100; } }`
    
    디컴파일 시 `<clinit>` 메서드가 생성되어 `x` 값이 설정됩니다.
    

---

 **2. JVM 실행 시 static 처리**

1. **클래스 로더(ClassLoader)가 클래스 로딩**
    
    - `Test.class`가 처음 참조되면 JVM은 클래스 메타데이터와 static 멤버를 **메서드 영역(Method Area)**에 적재.
        
2. **static 변수 초기화 및 static 블록 실행**
    
    - 클래스가 로드될 때 **단 한 번** 수행됩니다.
        
3. **호출 시 클래스 이름으로 직접 접근**
    
    - 객체 인스턴스와 무관하게 `Test.print()`로 바로 실행.
        

---
 **3. static이 컴파일 시 주는 이점**

- **호출 최적화:**  
    `static` 메서드는 **다형성(virtual dispatch)** 검사를 거치지 않으므로 호출 비용이 적습니다.
    
- **메모리 절약:**  
    인스턴스마다 변수를 복사하지 않고, 하나의 static 메모리를 공유.
    
- **상수 처리:**  
    `static final` 상수는 **컴파일 타임 상수로 인라인 처리**되어 실행 속도가 빨라집니다.
    

---
 **4. 제약점 (컴파일 시 관점)**

- `static` 메서드는 **객체의 인스턴스 변수와 this 참조에 접근 불가** → 컴파일러가 이를 엄격히 체크.
    
- 오버라이딩 불가 → **컴파일 시점부터 메서드 바인딩 확정**.
    

---
 **정리**

> **컴파일러는 `static` 멤버를 객체와 독립된 “클래스 레벨 리소스”로 취급하고, 호출도 컴파일 타임에 정적으로 결정합니다.**  
> 실행 시 JVM은 해당 멤버를 **메서드 영역에 적재**하여 모든 인스턴스가 공유하도록 처리합니다.

### 6. Java의 Exception에 대해 설명해 주세요.
##### 설명
Java에서 **Exception(예외)**은 프로그램 실행 중 발생할 수 있는 **비정상적 상황이나 오류를 객체로 표현한 것**입니다.  
자바는 예외를 체계적으로 다루기 위해 **예외 처리(Exception Handling) 메커니즘**을 제공합니다.

---
1. Exception의 개념**

- 예외는 `Throwable` 클래스의 하위 클래스 객체로 표현됩니다.
    
- 예외가 발생하면 **JVM은 해당 예외를 던지고(`throw`)**, 이를 처리할 수 있는 **`catch` 블록을 찾습니다.**
    
- 예외가 처리되지 않으면 프로그램은 비정상 종료됩니다.
    

---
 **2. Exception 계층 구조**
```java
java.lang.Object
  └─ java.lang.Throwable
       ├─ java.lang.Error        // 시스템 레벨 오류
       └─ java.lang.Exception    // 애플리케이션 레벨 예외
            └─ java.lang.RuntimeException

```
 **(1) Error**

- JVM이나 시스템 레벨에서 발생하는 심각한 오류.
    
- 예: `OutOfMemoryError`, `StackOverflowError`.
    
- **애플리케이션에서 복구 불가능**하므로 일반적으로 `catch`하지 않습니다.
    

 **(2) Exception**

- 애플리케이션 실행 중 발생할 수 있는 예외 상황.
    
- 개발자가 적절히 처리할 수 있습니다.
    
    **Checked Exception**
    
    - **컴파일 시점**에 반드시 처리(try-catch 또는 throws)해야 하는 예외.
        
    - 예: `IOException`, `SQLException`, `ClassNotFoundException`.
        
    
    #### **Unchecked Exception (RuntimeException)**
    
    - **런타임 시점**에 발생하며, 명시적인 예외 처리를 강제하지 않음.
    - 예: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`.
        

 **3. Exception 처리 방법**

 **(1) try-catch-finally**

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
} finally {
    System.out.println("항상 실행되는 블록");
}

```

- `try`: 예외 발생 가능 코드.
    
- `catch`: 특정 예외를 잡아서 처리.
    
- `finally`: 예외 발생 여부와 관계없이 항상 실행 (자원 해제 등).
    
 **(2) throws**

- 메서드에서 예외를 직접 처리하지 않고 **호출한 쪽으로 던짐**.
    
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
}

```
 **(3) throw**

- 명시적으로 예외 객체를 생성하여 던짐.
    
```java
	if (value < 0) {
    throw new IllegalArgumentException("음수는 허용되지 않습니다.");
}

```

---
 **4. 사용자 정의 예외**

개발자는 `Exception` 또는 `RuntimeException`을 상속받아 사용자 정의 예외를 만들 수 있습니다.

```java
class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}

```
---
 **5. Exception 처리의 장점**

- 예외를 **객체화**하여 **에러 정보(메시지, 스택 트레이스 등)를 구조적으로 제공**.
    
- 프로그램의 **안정성과 가독성**을 높이고, 비정상 종료를 방지.
    
- **예외 전파(throws)**를 통해 책임을 호출자에 위임 가능.
    

---
 **6. 주의할 점**

- 불필요하게 광범위한 예외(`catch Exception`)를 잡는 것은 디버깅을 어렵게 할 수 있음.
    
- Checked Exception은 코드 가독성을 떨어뜨릴 수 있어, 최근에는 **RuntimeException을 활용**하는 경우가 많음 (Spring, JPA도 이 접근 방식을 채택).
    
 **정리**

> **Exception은 프로그램 실행 중 발생하는 오류를 처리하기 위한 객체화된 메커니즘**으로,  
> Checked/Unchecked로 나뉘며, `try-catch-finally`와 `throws`를 통해 유연하게 처리할 수 있습니다.
##### 예외처리를 하는 세 방법에 대해 설명해 주세요.
**1. `try-catch-finally`로 처리 (직접 처리)**
 **개념**

- 예외가 발생할 수 있는 코드를 `try` 블록에 넣고, 예외 발생 시 `catch` 블록에서 해당 예외를 처리합니다.
    
- `finally` 블록은 예외 발생 여부와 관계없이 **항상 실행**됩니다. (주로 자원 해제에 사용)
 **특징**

- 예외를 **직접 잡아서 처리**할 수 있어 프로그램이 비정상 종료되지 않음.
    
- `finally` 블록은 자원 해제, 연결 종료, 로그 기록 등에 사용됩니다.
    

---
 **2. `throws`로 던지기 (호출자에게 예외 전파)**
 **개념**

- 메서드에서 발생한 예외를 **직접 처리하지 않고, 호출한 메서드에 예외를 던짐**.
    
- 메서드 선언부에 `throws 예외클래스명`을 명시해야 합니다.
    
 **예시**
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");  // IOException 가능
}

public static void main(String[] args) {
    try {
        readFile();  // 호출한 쪽에서 처리
    } catch (IOException e) {
        e.printStackTrace();
    }
}

```
 **특징**

- **예외 처리를 상위 호출자에게 위임**할 수 있어 메서드 자체가 더 단순해짐.
    
- Checked Exception은 `throws`로 반드시 명시하거나 `try-catch`로 처리해야 컴파일이 가능.
    

 **3. `throw`로 명시적 예외 발생시키기**

 **개념**

- 코드에서 직접 예외 객체를 생성해 **강제로 예외를 발생시킴**.
    
- 주로 **입력값 검증**이나 **비정상 상태**를 알릴 때 사용.
    
 **예시**

```java
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");
    }
    this.age = age;
}

```
**특징**

- 원하는 시점에서 예외를 발생시켜 **명확하게 에러 상황을 제어**할 수 있습니다.
    
- `throw`로 던진 예외는 **try-catch** 또는 **throws**로 반드시 처리해야 합니다.
    

---
 **정리**

1. **`try-catch-finally`**: 예외를 **직접 처리**한다.
    
2. **`throws`**: 예외를 **호출자에게 전달**한다.
    
3. **`throw`**: **명시적으로 예외를 발생**시킨다.
##### CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
Java의 예외(Exception)는 크게 **Checked Exception**과 **Unchecked Exception**으로 나뉘며, 이 둘의 차이는 **컴파일 시점에 예외 처리를 강제하는지 여부**와 **발생하는 상황**에 있습니다.

---
 **1. Checked Exception**

- **컴파일 타임에서 예외 처리(`try-catch` 또는 `throws`)가 강제되는 예외.**
    
- 발생 가능성이 있는 예외를 **개발자가 명시적으로 처리해야 한다**는 것이 특징.
    
- 주로 **외부 자원(I/O, 네트워크, DB 등)**과 관련된 상황에서 발생.
    
- `Exception` 클래스를 상속하지만 `RuntimeException`을 상속하지 않는 예외들이 이에 해당.
    
 **예시**

```java
public void readFile() throws IOException {
    FileReader reader = new FileReader("file.txt"); // IOException 가능
}

```
 **대표 예외**

- `IOException`
    
- `SQLException`
    
- `ClassNotFoundException`
    
- `FileNotFoundException`
    

---
 **2. Unchecked Exception**

- **컴파일 시점에 예외 처리를 강제하지 않는 예외.**
    
- 주로 **프로그래밍 오류(로직 에러)**로 인해 발생하는 경우가 많습니다.
    
- `RuntimeException`을 상속하는 예외들이 이에 해당.
    
- 개발자가 원하면 `try-catch`로 처리할 수 있지만, **필수는 아님**.
    
 **예시**

java

복사편집

`int[] arr = {1, 2, 3}; System.out.println(arr[5]);  // ArrayIndexOutOfBoundsException (Unchecked)`

- 이 예외는 **개발자가 코드 로직을 잘못 작성했기 때문에** 미리 처리하도록 강제하지 않습니다.
    
 **대표 예외**

- `NullPointerException`
    
- `ArrayIndexOutOfBoundsException`
    
- `IllegalArgumentException`
    
- `ArithmeticException`
    

---
 **3. 주요 차이점 정리**

|구분|**Checked Exception**|**Unchecked Exception**|
|---|---|---|
|**상속 관계**|`Exception` (단, `RuntimeException` 제외)|`RuntimeException` 및 하위 클래스|
|**컴파일 시점 처리**|반드시 처리 필요 (`try-catch` 또는 `throws`)|강제되지 않음|
|**발생 원인**|외부 환경 요인 (파일, 네트워크 등)|코드 로직 오류|
|**예시**|`IOException`, `SQLException`|`NullPointerException`, `ArithmeticException`|

---
 **4. 실무적 관점**

- **Checked Exception**: 외부 환경에 의존하는 부분(파일 읽기/쓰기, DB 연결 등)에 주로 사용.  
    _예:_ `Spring`의 `DataAccessException`은 RuntimeException으로 래핑하여 예외 처리를 단순화.
    
- **Unchecked Exception**: 프로그래머 실수로 발생하는 예외에 주로 사용. 보통 **코드 수정으로 해결**.
    

---
 **5. 정리**

> **Checked Exception**은 *"발생 가능성을 미리 대비하라"*는 의미로 컴파일러가 강제합니다.  
> **Unchecked Exception**은 *"로직 버그이므로 코드로 해결하라"*는 의미로, 강제하지 않습니다.
##### 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외 처리는 **정상적인 흐름의 코드보다 성능에 더 많은 비용이 발생**합니다.  
하지만 **예외 발생 자체보다, 예외가 실제로 던져지고(Stack Trace 생성) 처리되는 과정이 느린 것**이 주요 원인입니다.

---
 **1. 예외 처리가 성능에 영향을 미치는 이유**

1. **스택 트레이스 생성 비용**
    
    - 예외가 발생하면 JVM은 현재 스레드의 호출 스택을 추적하여 `Throwable.fillInStackTrace()`를 호출합니다.
        
    - 이 과정에서 스택 프레임 정보를 캡처해야 하므로 **상당한 오버헤드**가 발생합니다.
        
2. **정상 흐름에서 예외를 남용할 경우**
    
    - 예외를 **제어 흐름(Control Flow)으로 사용하면 성능 저하가 큽니다.**  
        (예: 조건문으로 체크할 수 있는 상황을 `try-catch`로 해결하려는 경우)
        
3. **캐치 후 다시 던지는 예외**
    
    - `catch` 블록에서 처리하지 않고 다시 `throw`하면 추가적인 스택 트레이스 생성이 이루어집니다.
        

---
 **2. 어느 정도 느린가?**

- **일반 조건문 검사(`if`)**와 비교하면 **예외 발생은 수십~수백 배 느릴 수 있습니다.**
    
- 예를 들어, 예외를 1만 번 던지면 **수 밀리초에서 수십 밀리초 단위의 지연**이 발생할 수 있습니다.
    
- 하지만 **예외가 발생하지 않는 `try-catch` 자체는 거의 성능 영향을 주지 않습니다.**  
    (즉, "예외가 발생하는 순간"에만 성능 비용이 큼)
    

---
 **3. 성능 부하를 줄이는 방법**

 **(1) 예외를 로직 제어에 사용하지 않는다**

- **잘못된 방식:**
    
    java
    
    복사편집
    
    `try {     int value = Integer.parseInt("abc");  // NumberFormatException 발생 } catch (NumberFormatException e) {     // 예외로 흐름 제어 (비효율적) }`
    
- **개선된 방식:**
    
    java
    
    복사편집
    
    `if (isNumeric(str)) {  // 조건 체크     int value = Integer.parseInt(str); }`
    
 **(2) 예외는 “예외적인 상황”에서만 사용**

- 정상적인 흐름에서는 조건문, Optional, Validation 등으로 사전 체크.
    

 **(3) 스택 트레이스 생성을 줄이기**

- 커스텀 예외 클래스에서 `fillInStackTrace()`를 오버라이딩해 **스택 트레이스 생성 비용을 줄일 수 있습니다.**
    
    java
    
    복사편집
    
    `@Override public synchronized Throwable fillInStackTrace() {     return this;  // 스택 트레이스 생략 }`
    
 **(4) Checked Exception을 과도하게 사용하지 않기**

- Checked Exception은 `throws` 선언과 `try-catch`로 인한 불필요한 오버헤드가 생길 수 있습니다.  
    실무에서 Spring, JPA 등이 **Unchecked(Runtime) Exception** 중심으로 설계된 이유 중 하나입니다.
    

 **(5) Hot Path(빈번히 호출되는 코드)에서는 예외 최소화**

- 성능이 중요한 루프, API 엔드포인트 등에서는 **예외가 발생하지 않도록 사전 방어 로직을 작성**.
    

---

 **4. 결론**

- **예외 발생 자체는 일반 로직보다 훨씬 느립니다.**
    
- 하지만 **예외가 발생하지 않는 한, `try-catch` 문 자체는 거의 오버헤드가 없습니다.**
    
- 따라서 **예외는 진짜 “예외적 상황”에서만 사용하고, 사전 조건 검사로 방어 코드를 작성하는 것이 성능 최적화의 핵심**입니다.
### 7. Synchronized 키워드에 대해 설명해 주세요.
##### 설명
`synchronized` 키워드는 Java에서 **멀티스레드 환경에서의 동기화(synchronization)** 를 위해 사용됩니다. 하나의 자원(변수, 메서드 등)을 여러 스레드가 동시에 접근할 때, **경쟁 조건(race condition)** 을 방지하기 위해 사용됩니다.

---
🔹 1. 핵심 개념

- `synchronized`는 **임계 영역(Critical Section)** 에 **하나의 스레드만 접근하도록 락(lock)을 거는 기능**입니다.
    
- 자바에서 **객체마다 하나의 모니터 락(Monitor Lock)** 을 가지고 있으며, synchronized는 이 락을 기반으로 작동합니다.
    

---
🔹 2. 사용 방법

✅ 1. 메서드 전체 동기화

```java
public synchronized void increment() {
    count++;
}

```
- 인스턴스 메서드의 경우: **해당 객체(this)** 를 락으로 사용
    
- 동시에 여러 스레드가 `increment()`를 호출해도 **한 스레드만 락을 얻고 실행**됨
    

---
✅ 2. 블록 단위 동기화

```java
public void increment() {
    synchronized(this) {
        count++;
    }
}

```
- `this`는 락의 대상입니다. 더 정밀한 제어가 가능하며, 일부 코드만 동기화할 때 사용합니다.
    

---
✅ 3. static 메서드 동기화

```java
public static synchronized void printLog() {
    // ...
}

```
- `static` 메서드는 **클래스 수준의 락 (`ClassName.class`)** 을 사용합니다.
    
🔹 3. 작동 원리

`synchronized` 블록에 진입하면:

1. 대상 객체의 **모니터 락을 획득**합니다.
    
2. 락을 획득한 스레드만 블록을 실행할 수 있습니다.
    
3. 실행이 끝나면 락을 **반환(해제)** 합니다.
    
4. 다른 스레드는 락이 반환될 때까지 **대기 상태(BLOCKED)** 가 됩니다. 

---
🔹 4. 장점과 단점

|항목|설명|
|---|---|
|✅ 장점|Race condition 방지, 스레드 안전성 보장|
|⚠ 단점|성능 저하, 데드락 가능성 있음, 락 경쟁으로 병렬성 감소|

---
🔹 5. 관련 개념

- `ReentrantLock`: `synchronized`보다 정교한 락 제어가 가능 (timeout, tryLock, interruptible 등)
    
- `volatile`: 메모리 가시성을 보장하지만 동기화는 아님
    
- `wait()`, `notify()`: `synchronized` 블록 내에서만 사용 가능 (Object의 모니터를 이용)
    
##### Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
✅ 1. 인스턴스 메서드에 붙을 때

```java
`public synchronized void instanceMethod() {     // ... }`
```


✔ 의미

- **this 객체의 모니터(lock)** 를 사용합니다.
    
- 즉, 같은 객체에 대해 여러 스레드가 `instanceMethod()`를 호출하면 **동시에 접근할 수 없습니다.**
    
❗하지만 서로 다른 인스턴스라면 동시 접근 가능합니다.

---
✅ 2. static 메서드에 붙을 때
```java
public static synchronized void staticMethod() {
    // ...
}

```
 의미

- **해당 클래스의 Class 객체 (`ClassName.class`)의 모니터(lock)** 를 사용합니다.
    
- 모든 인스턴스가 공유하는 클래스 수준의 락입니다.
    
➕ 실전 예

- 싱글턴에서 전역 설정 변경 같은 작업을 synchronized static으로 제어할 수 있음.
    

---
✅ 3. 블록에 붙을 때
```java
public void method() {
    synchronized(this) {
        // ...
    }
}

```
 ✔ 의미

- **명시한 객체의 모니터(lock)** 를 사용합니다.
- `synchronized(obj)` → obj가 락의 대상입니다.
    
➕ 실전 예

- 블록 단위로 최소한의 영역만 동기화하고 싶을 때, 또는
- 객체에 따라 락을 분리하고 싶을 때 (예: `userId`마다 락 다르게 하기)
    

---
✅ 4. 예시 비교

```java
class Example {
    public synchronized void methodA() { }      // this 객체에 락
    public static synchronized void methodB() { } // Class 객체에 락
    public void methodC() {
        synchronized(this) { }                  // this 객체에 락
    }
    public void methodD() {
        synchronized(Example.class) { }         // Class 객체에 락
    }
}

```

|메서드 이름|락 대상|
|---|---|
|methodA|this (인스턴스)|
|methodB|Example.class (클래스)|
|methodC|this (인스턴스)|
|methodD|Example.class (클래스)|

---
✅ 요약 정리

|위치|락 대상|설명|
|---|---|---|
|`synchronized` 인스턴스 메서드|`this`|해당 객체 단위의 동기화|
|`synchronized` static 메서드|`ClassName.class`|클래스 단위의 동기화|
|`synchronized(this)`|`this`|블록 단위로 인스턴스 락 사용|
|`synchronized(obj)`|`obj`|원하는 객체로 락 분리 가능|
##### 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
`synchronized`는 **멀티스레드 환경에서 안전성을 보장하는 데 필수적인 도구**이지만, **효율적인 코드 작성을 위한 도구는 아닙니다**. 오히려 잘못 사용하면 성능 저하나 병목을 유발할 수 있습니다.

따라서 효율적인 코드 작성을 목표로 할 때는 `synchronized`의 **장점과 단점**을 명확히 이해하고 **필요한 최소한의 범위에서 신중하게 사용하는 것**이 중요합니다.

---
 ✅ synchronized의 장점

| 장점                | 설명                                                        |
| ----------------- | --------------------------------------------------------- |
| **간단한 문법**        | 락/언락을 명시적으로 하지 않아도 됨 (`try-finally` 불필요)                  |
| **스레드 안전성 보장**    | 공유 자원에 대한 동시에 접근할 경우, 레이스 컨디션 방지                          |
| **JVM 최적화 적용 대상** | JDK 1.6 이상에서는 biased lock, lightweight lock 등 최적화 기법이 적용됨 |

---
 ❌ synchronized의 단점 (비효율적일 수 있는 이유)

| 단점            | 설명                                               |
| ------------- | ------------------------------------------------ |
| **성능 저하**     | 스레드 간 lock 경쟁 발생 시, context switching 비용 증가      |
| **병목 발생 가능성** | 락 범위를 넓게 설정하면 하나의 스레드 때문에 전체가 대기할 수 있음           |
| **데드락 위험**    | 여러 락을 중첩해서 사용할 경우 발생 가능                          |
| **유연성 부족**    | 락의 조건, 시간 제한, 중단 제어 등을 못 함 (`ReentrantLock`은 가능) |

---
💡 효율적인 대안 또는 개선 방법

| 방법                      | 설명                                                                 |
| ----------------------- | ------------------------------------------------------------------ |
| **락 범위를 줄이기**           | 전체 메서드 대신 필요한 코드 블록만 synchronized 처리                               |
| **`ReentrantLock` 사용**  | 명시적 락 제어, 타임아웃, 락 중단, 공정성 설정 등 가능                                  |
| **`Concurrent` 컬렉션 사용** | `ConcurrentHashMap`, `CopyOnWriteArrayList` 등은 내부적으로 적절히 락을 나눠서 처리 |
| **비동기 처리/락 분리**         | 독립적인 리소스는 서로 다른 락을 사용해서 병렬성 향상 가능                                  |
| **원자 클래스 사용**           | `AtomicInteger`, `AtomicLong` 등은 락 없이도 thread-safe 연산 가능           |

---
 📌 결론

> **“안전성 확보에는 유용하지만, 효율적인 코드 작성만을 고려하면 신중하게 사용해야 할 키워드입니다.”**

- 성능이 중요한 영역에서는 `synchronized` 보다는 더 정밀한 제어가 가능한 도구를 사용하는 것이 좋습니다.
    
- 단, 초기 개발이나 구조가 단순할 때는 빠르게 스레드 안전성을 확보하는 데 좋은 선택이 될 수 있습니다.
##### Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
✅ 1. `ReentrantLock` (java.util.concurrent.locks)

✔ 특징

- `synchronized`보다 유연하고 기능이 풍부한 락
    
- 명시적으로 lock()/unlock() 호출 필요
    

✔ 주요 기능

|기능|설명|
|---|---|
|`tryLock()`|락이 사용 중이면 대기하지 않고 바로 실패|
|`tryLock(timeout)`|일정 시간만 기다렸다가 실패|
|`lockInterruptibly()`|대기 중인 스레드를 interrupt로 중단 가능|
|`isHeldByCurrentThread()`|락 보유 여부 확인|
|`getHoldCount()`|재진입 횟수 확인|
✔ 예시
```java
ReentrantLock lock = new ReentrantLock();

void update() {
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock(); // 반드시 해제
    }
}

```
---
 ✅ 2. `ReadWriteLock` (`ReentrantReadWriteLock`)

✔ 특징

- 읽기 작업은 동시에 허용, 쓰기 작업은 단독 실행
    
- 읽기 많은 시스템에서 성능 향상 가능
    

✔ 예시
```java
ReentrantLock lock = new ReentrantLock();

void update() {
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock(); // 반드시 해제
    }
}

```
---
✅ 3. `StampedLock` (Java 8+)
✔ 특징

- `ReadWriteLock`의 개선 버전
    
- 낙관적 읽기(optimistic read)를 제공하여 **락 없는 읽기** 가능
    
- 더 복잡하지만 **고성능 읽기 시나리오**에 적합
    

---
✅ 4. `Atomic` 클래스 (java.util.concurrent.atomic)
✔ 특징

- 락 없이 CAS(Compare-And-Swap) 기반 원자 연산 제공
    
- 단일 변수 동기화에 매우 효과적
    
✔ 대표 클래스

- `AtomicInteger`, `AtomicLong`
    
- `AtomicReference`, `AtomicBoolean`
    
- `AtomicIntegerArray`, `AtomicReferenceArray`
    
✔ 예시
```java
AtomicInteger count = new AtomicInteger(0);

void increment() {
    count.incrementAndGet(); // thread-safe
}

```
✅ 5. `volatile` 키워드

✔ 특징

- **변수의 변경 내용을 모든 스레드에 즉시 반영** (메모리 가시성 보장)
    
- 락을 사용하지 않으므로 성능은 뛰어나지만 **복잡한 연산에는 불안정**
    
✔ 한계

- 원자성(atomicity)은 보장하지 않음
    
- 단독 사용보다는 다른 구조와 함께 써야 안전함
    

---
✅ 6. `synchronized`와의 비교 요약

| 기법              | 장점          | 단점               |
| --------------- | ----------- | ---------------- |
| `synchronized`  | 간편하고 안정적    | 성능 저하, 데드락 위험    |
| `ReentrantLock` | 고급 제어 가능    | 락 해제 실수 위험       |
| `ReadWriteLock` | 읽기 병렬성      | 쓰기 많으면 오히려 성능 저하 |
| `StampedLock`   | 낙관적 락으로 고성능 | 사용 복잡            |
| `Atomic` 클래스    | 빠르고 가볍다     | 복잡한 연산에는 부적합     |
| `volatile`      | 가시성 확보      | 원자성 미보장          |

---
🧠 결론

- `synchronized`는 단순한 동기화에는 충분하지만, **성능/유연성/복잡성** 요구에 따라 다른 대체 수단을 선택하는 것이 바람직합니다.
    
- **간단한 락** → `synchronized`
    
- **정밀 제어** → `ReentrantLock`, `ReadWriteLock`
    
- **낮은 지연, 높은 성능** → `StampedLock`, `Atomic`
    
- **값 교체만 필요한 경우** → `volatile`, `AtomicReference`
##### Thread Local에 대해 설명해 주세요.
`ThreadLocal`은 **스레드마다 독립적인 변수를 가질 수 있게 해주는 클래스**입니다. 멀티스레드 환경에서 **공유 자원을 피하고**, 각 스레드가 **자기만의 데이터를 보관**하고 사용할 수 있도록 도와줍니다.

---
✅ 1. ThreadLocal의 정의

> `ThreadLocal<T>`은 **각 스레드마다 고유한 변수 값을 저장**할 수 있도록 해주는 Java 클래스입니다.

즉, 하나의 `ThreadLocal` 인스턴스를 여러 스레드가 공유하더라도, **스레드마다 각각의 값**을 따로 저장하고 사용합니다.

---
✅ 2. 기본 사용법

```java
ThreadLocal<Integer> threadLocal = new ThreadLocal<>();

// 값 설정
threadLocal.set(100);

// 값 가져오기
int value = threadLocal.get();

// 값 제거 (메모리 누수 방지)
threadLocal.remove();

```
- `set(value)` → 현재 스레드에 값을 저장
    
- `get()` → 현재 스레드의 값을 조회
    
- `remove()` → 현재 스레드의 값 제거 (메모리 누수 방지)
    

---
✅ 3. ThreadLocal 동작 방식

- 내부적으로 `ThreadLocalMap`이라는 자료구조를 사용하여  
    **`Thread` 객체마다 고유한 Map이 존재**합니다.
    
- 이 Map의 key는 `ThreadLocal` 객체, value는 저장한 데이터입니다.
    
```
Thread A
 └─ ThreadLocalMap
      └─ [ThreadLocal@1a2b3c] -> 100

Thread B
 └─ ThreadLocalMap
      └─ [ThreadLocal@1a2b3c] -> 200

```
→ 같은 ThreadLocal 객체여도, 스레드마다 독립적인 값을 저장합니다.

---
✅ 4. 활용 예시

💡 예: 날짜 포맷 객체 공유 문제 해결

```java
ThreadLocal<DateFormat> dateFormat = ThreadLocal.withInitial(() ->
    new SimpleDateFormat("yyyy-MM-dd")
);

// 스레드마다 안전하게 사용 가능
String today = dateFormat.get().format(new Date());

```
- `SimpleDateFormat`은 **스레드에 안전하지 않음**.
    
- `ThreadLocal`을 이용하면 각 스레드마다 별도의 객체를 사용하므로 동기화 없이도 안전하게 사용 가능.
    

---
✅ 5. 장점과 단점

| 장점                           | 단점                             |
| ---------------------------- | ------------------------------ |
| 락 없이 스레드별 독립 데이터 제공          | **메모리 누수 위험** (remove 누락 시)    |
| 코드 복잡도 감소 (공유 없이도 데이터 유지 가능) | 스레드 수 많을 경우 메모리 사용 증가          |
| 특정 스레드에서만 유효한 값 저장 가능        | 논리적 흐름 따라가기 어려움 (숨겨진 상태 발생 가능) |

---
✅ 6. 실전 활용 사례

|분야|활용 예|
|---|---|
|Spring Security|현재 로그인한 사용자 정보 저장 (`SecurityContextHolder`)|
|DB Connection Pool|트랜잭션 단위로 같은 커넥션 유지 (`DataSourceTransactionManager`)|
|로그 트레이싱|요청 ID를 스레드에 저장해 로그에 일관되게 출력 (e.g. MDC)|

---
🧠 결론

- `ThreadLocal`은 **스레드별로 독립된 변수**가 필요한 경우 유용합니다.
    
- 다만, `remove()`를 반드시 호출하지 않으면 **메모리 누수**가 발생할 수 있으므로 **ThreadPool 사용 시 특히 주의**해야 합니다.
### 8. Java Stream에 대해 설명해 주세요.
##### 설명
Java Stream은 Java 8에서 도입된 기능으로, **데이터를 선언형(Declarative) 방식으로 처리**할 수 있게 해주는 API입니다. **컬렉션 또는 배열의 요소들을 필터링, 변환, 정렬, 집계** 등의 작업을 간결하고 효율적으로 수행할 수 있도록 설계되었습니다.

---
 ✅ Stream의 주요 특징

1. **선언형 처리 방식**
    
    - 반복문 없이 `filter`, `map`, `reduce` 등의 메서드로 데이터를 처리합니다.
        
    - 코드가 간결하고 가독성이 좋습니다.
        
2. **중간 연산과 최종 연산**
    
    - **중간 연산**: `filter`, `map`, `sorted` 등 → Stream을 반환
        
    - **최종 연산**: `collect`, `forEach`, `count`, `reduce` 등 → 결과를 반환하거나 처리 종료
        
3. **지연(Lazy) 연산**
    
    - 중간 연산은 실제로 결과를 필요로 할 때(최종 연산 시점) 실행됩니다.
        
4. **병렬 처리 지원**
    
    - `.parallelStream()`을 사용하면 멀티코어 CPU에서 병렬로 처리할 수 있습니다.
        

---
✅ 예제

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(result); // [ALICE, CHARLIE]

```
 ✅ 주요 메서드 설명

| 메서드                    | 설명                |
| ---------------------- | ----------------- |
| `filter(Predicate)`    | 조건에 맞는 요소만 남김     |
| `map(Function)`        | 요소를 다른 형태로 변환     |
| `sorted()`             | 정렬                |
| `distinct()`           | 중복 제거             |
| `limit(n)` / `skip(n)` | 앞에서 n개 가져오거나 건너뜀  |
| `collect()`            | 결과를 리스트, 셋 등으로 수집 |
| `reduce()`             | 모든 요소를 하나의 값으로 축약 |
 ✅ 주의점

- **Stream은 일회용**이며, 한 번 소비하면 다시 사용할 수 없습니다.
    
- 내부 반복 방식이므로 **디버깅이 어렵거나 성능 튜닝이 필요한 경우 주의**가 필요합니다.
    
- **null을 포함한 컬렉션 처리 시 NPE 주의**가 필요합니다.
    

 

##### Stream과 for ~ loop의 성능 차이를 비교해 주세요,
`Java Stream`과 `for-loop`의 성능 차이는 **상황에 따라 달라지며**, 다음과 같은 측면을 기준으로 비교할 수 있습니다.

---
✅ 1. **기본 성능 비교**

| 항목         | for-loop                   | Stream                      |
| ---------- | -------------------------- | --------------------------- |
| **처리 방식**  | 외부 반복 (External Iteration) | 내부 반복 (Internal Iteration)  |
| **오버헤드**   | 없음 또는 적음                   | 상대적으로 있음                    |
| **속도**     | 일반적으로 더 빠름                 | 약간 느릴 수 있음 (특히 작은 데이터)      |
| **코드 가독성** | 명령형(Imperative) 스타일        | 선언형(Declarative) 스타일 (더 깔끔) |
```java
List<Integer> list = IntStream.range(0, 1_000_000).boxed().collect(Collectors.toList());

// for-loop
long sum1 = 0;
for (int n : list) {
    sum1 += n;
}

// Stream
long sum2 = list.stream().mapToLong(i -> i).sum();

```

- 위 경우 일반적으로 **for-loop가 더 빠릅니다**.
    
- Stream은 람다 표현식, 내부 반복 등으로 **약간의 오버헤드**가 발생합니다.
    
 ✅ 2. **병렬 처리 측면**

|항목|for-loop|Stream (parallel)|
|---|---|---|
|**멀티코어 활용**|수동으로 스레드 작성 필요|`.parallelStream()`으로 간단히 가능|
|**대용량 데이터**|직접 병렬 처리 코드 작성|자동 병렬화로 성능 향상 가능|
|**병렬 안전성**|직접 제어 가능|상태 공유 없이 사용해야 안정적|

`long parallelSum = list.parallelStream()     .mapToLong(i -> i)     .sum();`

- 데이터가 **충분히 크고**, **연산이 독립적**이라면 `parallelStream()`이 **for-loop보다 빠를 수 있습니다**.
    

---
✅ 3. **성능 비교 정리**

|조건|더 적합한 방식|
|---|---|
|작은 데이터셋 / 성능 중요|`for-loop` (낮은 오버헤드)|
|복잡한 변환 / 필터링 / 가독성|`Stream` (선언적이고 간결)|
|병렬 처리 필요|`parallelStream` (멀티코어 활용)|
|디버깅이나 세밀한 제어 필요|`for-loop` (유연한 흐름 제어)|

---
✅ 결론

- **Stream은 가독성과 유지보수에 강점**이 있으나, **성능 면에서는 for-loop보다 느릴 수 있습니다.**
    
- 단, **데이터가 크고 병렬성이 높은 작업**에서는 `parallelStream`이 **for-loop보다 빠를 수 있습니다**.
    
- **성능이 중요한 핵심 로직에서는 반드시 성능 테스트 후 선택**하는 것이 좋습니다. (`JMH` 추천)
##### Stream은 병렬처리 할 수 있나요?
네, **Java Stream은 병렬 처리(parallel processing)를 지원합니다.**  
바로 `.parallelStream()` 또는 `.parallel()` 메서드를 사용하면 여러 CPU 코어를 활용한 병렬 연산을 수행할 수 있습니다.

---
✅ 병렬 스트림 사용법
```java
List<Integer> list = IntStream.rangeClosed(1, 1_000_000).boxed().toList();

// 병렬 처리: sum
long sum = list.parallelStream()
    .mapToLong(i -> i)
    .sum();

```

- 위 코드는 리스트를 여러 스레드로 나눠 병렬로 `sum()` 연산을 수행합니다.
    
- 내부적으로는 **Fork/Join 프레임워크**를 사용합니다.
    

---
✅ 병렬 스트림의 특징

| 항목              | 설명                                              |
| --------------- | ----------------------------------------------- |
| **자동 스레드 분할**   | Stream이 알아서 적절한 스레드 수와 작업 분할 수행                 |
| **멀티코어 CPU 활용** | 작업을 여러 코어에 분산 실행                                |
| **비결정적 순서**     | 연산 순서가 보장되지 않음 (단 `forEachOrdered()`는 순서 보장)    |
| **상태 공유 금지**    | 상태 변경이 있는 연산은 병렬 스트림에서 안전하지 않음 (side-effect 지양) |

---
✅ 주의사항

- **작은 데이터**나 **단순한 연산**에서는 오히려 `.parallelStream()`이 느릴 수 있습니다.  
    → 스레드 분할/병합 비용이 더 클 수 있음
    
- **상태 공유(stateful)** 연산은 주의 필요  
    → 예: `forEach()` 내에서 외부 리스트에 `add()`하면 race condition 발생 가능
    
- `Collectors.toList()` 등 수집 작업도 병렬 안전하게 설계되어 있어야 함
    

---
✅ 병렬 Stream 예시
```java
List<String> names = List.of("Alice", "Bob", "Charlie", "Dave");

names.parallelStream()
     .map(String::toUpperCase)
     .forEach(System.out::println); // 순서 보장 안됨

names.parallelStream()
     .map(String::toUpperCase)
     .forEachOrdered(System.out::println); // 순서 보장

```
 ✅ 요약

|질문|답변|
|---|---|
|**Stream에서 병렬 처리 가능?**|✅ 예, `.parallelStream()` 또는 `.parallel()` 사용|
|**성능 이점?**|✅ 데이터가 크고 독립적 연산이면 성능 향상|
|**주의할 점?**|⚠️ 상태 공유 금지, 순서 비결정성, 작은 데이터는 오히려 느릴 수 있음|
##### Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
Java Stream API는 **함수형 인터페이스(Functional Interface)**를 기반으로 동작합니다. 이 인터페이스들은 **람다 표현식**이나 **메서드 참조**와 함께 사용되며, `Stream`에서 각 요소를 처리하는 역할을 합니다.

다음은 **Stream에서 자주 사용되는 함수형 인터페이스 4가지**입니다:

---
✅ 1. `Predicate<T>`

- **역할**: `boolean` 값을 반환하는 **조건 검사 함수**
    
- **사용처**: `filter()`, `allMatch()`, `anyMatch()` 등에서 사용
    
- **함수형 메서드**: `boolean test(T t)`
    
 예시
```java
Stream.of("apple", "banana", "carrot")
    .filter(s -> s.startsWith("a")) // Predicate<String>
    .forEach(System.out::println);  // 출력: apple

```
✅ 2. `Function<T, R>`

- **역할**: `T` 타입을 받아서 `R` 타입으로 **변환하는 함수**
    
- **사용처**: `map()`, `flatMap()` 등에서 사용
    
- **함수형 메서드**: `R apply(T t)`
    

예시
```java
Stream.of("apple", "banana")
    .map(s -> s.length()) // Function<String, Integer>
    .forEach(System.out::println); // 출력: 5, 6

```
✅ 3. `Consumer<T>`

- **역할**: 입력 값을 받아서 **소비만 하고 반환값이 없는 함수**
    
- **사용처**: `forEach()`, `peek()` 등에서 사용
    
- **함수형 메서드**: `void accept(T t)`
    
예시

```java
Stream.of(1, 2, 3)
    .forEach(n -> System.out.println(n)); // Consumer<Integer>

```
✅ 4. `Supplier<T>`

- **역할**: 입력 없이 **값을 제공하는 함수**
    
- **사용처**: `Stream.generate()`, lazy 초기화 등에서 사용
    
- **함수형 메서드**: `T get()`
    

예시
```java
Stream.of(1, 2, 3)
    .forEach(n -> System.out.println(n)); // Consumer<Integer>

```
✅ 그 외 자주 쓰이는 확장 인터페이스

|인터페이스|설명|
|---|---|
|`UnaryOperator<T>`|`Function<T, T>`의 특수한 형태 (입출력 타입 동일)|
|`BinaryOperator<T>`|`BiFunction<T, T, T>`의 특수한 형태 (두 입력 → 하나의 같은 타입 결과)|
|`BiFunction<T, U, R>`|두 개의 입력을 받아 하나의 결과 생성|
|`BiPredicate<T, U>`|두 개의 입력을 받아 `boolean` 반환|
|`ToIntFunction<T>` 등|`int`, `long`, `double` 특화 함수 (기본형 지원)|

---
✅ 요약

| 인터페이스            | 설명            | 사용 메서드 예                 |
| ---------------- | ------------- | ------------------------ |
| `Predicate<T>`   | 조건 검사         | `filter()`, `allMatch()` |
| `Function<T, R>` | 변환            | `map()`, `flatMap()`     |
| `Consumer<T>`    | 소비 (출력, 저장 등) | `forEach()`, `peek()`    |
| `Supplier<T>`    | 값 공급          | `generate()`             |

---

Stream API의 핵심은 **함수형 인터페이스를 조합해 선언적으로 데이터를 처리하는 것**입니다.
##### 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
좋은 질문입니다. Java에서 람다식이나 익명 클래스 내부에서 외부 변수를 사용할 때 `final` 또는 **사실상 final (effectively final)**이어야 하는 이유는 다음과 같습니다.

---
✅ 왜 `final` 또는 effectively final이어야 할까?

🔸 이유: **스레드 안전성과 일관성 확보를 위해서**

람다식은 내부적으로 **익명 클래스 또는 내부 클래스로 변환**되며, 외부 변수에 접근할 때 **그 값의 복사본을 캡처**합니다.  
이때, 변수의 값이 **변하지 않아야 예측 가능한 결과를 보장**할 수 있으므로 `final` 또는 변경되지 않는 값만 허용합니다.

 ✅ 예시로 살펴보기

```java
int x = 10;

Runnable r = () -> {
    System.out.println(x); // OK: x는 effectively final
};

x = 20; // ❌ 컴파일 에러: x는 더 이상 final이 아님

```
위 코드에서 `x`를 변경하려 하면 컴파일 오류가 발생합니다. 이유는:

- 람다는 `x`의 값을 복사해서 내부에 저장
    
- 그런데 외부에서 `x`를 변경하면 **복사본과 실제 값이 달라질 위험**이 있음
    
- 이를 방지하기 위해 Java는 **변경 가능한 외부 변수는 캡처하지 못하게 막음**
    
✅ 꼭 `final`이어야 하나요?

- **아니요.** Java 8부터는 꼭 `final` 키워드를 명시하지 않아도 됩니다.
    
- 단, 그 변수는 **사실상 final (변경되지 않아야 함)**이어야 합니다.
    
```java
`String name = "Alice"; list.forEach(s -> System.out.println(name)); // OK: name은 변경되지 않음`

```

---
✅ 그럼 값을 바꾸고 싶을 때는?

값을 바꾸고 싶다면, **배열, 리스트, AtomicInteger** 같은 **참조형을 사용**해 내부 값을 변경해야 합니다.

```java
`int[] sum = {0}; list.forEach(n -> sum[0] += n); // 배열은 final이지만 내부 값은 변경 가능`

```
```java
`AtomicInteger sum = new AtomicInteger(0); list.forEach(n -> sum.addAndGet(n));`
```

---
✅ 요약

| 질문                      | 답변                                                         |
| ----------------------- | ---------------------------------------------------------- |
| 외부 변수에 왜 `final`이 필요할까? | 람다/익명 클래스가 **복사본을 캡처**하기 때문에, 값 변경 시 **혼란이나 오류**가 생길 수 있음  |
| 꼭 `final` 붙여야 하나요?      | ❌ Java 8부터는 안 붙여도 되지만, **변경은 금지되어야 함** (effectively final) |
| 변경하려면 어떻게 하나요?          | 배열, 리스트, `AtomicInteger` 등 **참조형 객체 사용**                   |

### 9. Java의 GC에 대해 설명해 주세요.
##### 설명
Java의 **GC(Garbage Collector)**는 **더 이상 사용되지 않는 메모리(객체)를 자동으로 해제**해주는 JVM의 기능입니다. 개발자가 메모리를 직접 해제하지 않아도 되도록 하여 **메모리 누수 방지**와 **안정성 향상**을 돕습니다.

---
✅ 1. GC란 무엇인가?

- **Garbage Collection**: 더 이상 참조되지 않는 객체를 **자동으로 탐지하고 제거**하는 과정
    
- GC의 목적:
    
    - 사용하지 않는 객체 제거
        
    - 메모리 회수 (heap 공간 확보)
        
    - OutOfMemoryError 방지
        

---
✅ 2. 객체는 어디에 저장되나?

Java 객체는 대부분 **힙(Heap)** 메모리에 저장되며, GC는 이 **힙 메모리 영역**을 관리합니다.  
JVM의 힙 영역은 다음과 같이 나뉩니다:

```java
Heap
├── Young Generation (Eden + Survivor)
└── Old Generation (Tenured)


```

---
✅ 3. 주요 개념

| 개념                   | 설명                                      |
| -------------------- | --------------------------------------- |
| **Young Generation** | 새로 생성된 객체가 저장됨. 대부분 금방 사라지므로 빠르게 수집     |
| **Old Generation**   | 오래 살아남은 객체가 저장됨. 크고 무거운 GC가 수행됨         |
| **Eden**             | 새 객체가 처음 할당되는 공간                        |
| **Survivor**         | Eden에서 살아남은 객체가 옮겨가는 공간 (S0, S1 두 개 존재) |
| **Tenuring**         | Survivor 영역에서 일정 횟수 이상 살아남으면 Old로 이동    |

---
✅ 4. GC의 종류 (JVM별 정책)

|GC 종류|특징|적합한 환경|
|---|---|---|
|**Serial GC**|단일 스레드, 정지 시간이 김|단일 CPU, 작은 앱|
|**Parallel GC**|멀티 스레드, Throughput 중심|병렬 처리 가능, 일반적인 서버|
|**CMS (Concurrent Mark & Sweep)**|짧은 정지 시간, 일부 병행 처리|사용자 응답 중요|
|**G1 GC**|영역을 나눠 병렬 처리 + 예측 가능한 정지 시간|대형 서비스, JVM 9+ 기본|
|**ZGC / Shenandoah**|초저지연 GC, 대부분 병렬/비동기 수행|실시간 응답이 중요한 시스템 (JDK 11+)|

---
✅ 5. GC 동작 과정 (Mark-Sweep-Compact)

1. **Mark**: 참조 가능한 객체를 모두 표시
    
2. **Sweep**: 표시되지 않은 객체 제거
    
3. **Compact**: 메모리 조각화를 줄이기 위해 객체들을 한쪽으로 압축
    

---
✅ 6. GC 튜닝의 핵심 지표

|지표|의미|
|---|---|
|**GC Pause Time**|GC로 인한 정지 시간|
|**Throughput**|GC 외 작업 수행 비율|
|**Heap Usage**|GC 빈도와 메모리 효율|
|**Object Allocation Rate**|객체 생성 속도|

→ GC 로그, `jstat`, VisualVM, GCViewer 등을 통해 분석 가능

---
✅ 요약

| 항목         | 내용                                |
| ---------- | --------------------------------- |
| **GC의 목적** | 불필요한 객체 제거로 메모리 누수 방지             |
| **관리 대상**  | 주로 힙 메모리 (Young/Old Generation)   |
| **GC 종류**  | Serial, Parallel, CMS, G1, ZGC 등  |
| **기본 방식**  | Mark → Sweep → Compact            |
| **튜닝 요소**  | Pause time, Heap size, GC 로그 분석 등 |
##### finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
✅ 1. `finalize()`의 원래 목적

- `Object` 클래스에 정의된 메서드로, 객체가 **GC 대상이 되기 직전**에 호출되어 **정리(clean-up) 작업**을 할 수 있게 합니다.
    
- 보통 **자원 해제**, 예: 파일 닫기, 소켓 정리 등의 목적
    
```java
@Override
protected void finalize() throws Throwable {
    try {
        // 자원 해제 코드
    } finally {
        super.finalize();
    }
}

```


> ✅ 하지만, **GC가 객체를 수거할 때만** JVM이 자동으로 호출해야 합니다.

---
❌ 수동 호출이 문제가 되는 이유

1. **객체가 GC되지 않았는데 finalize()가 호출됨**

- `finalize()`는 **객체가 더 이상 사용되지 않을 때** 호출되어야 의미가 있음.
    
- 수동 호출하면 아직 살아있는 객체를 **잘못된 상태로 만듦** (예: 자원을 닫았는데 여전히 사용 중일 수 있음).
    
2. **중복 호출 가능성**

- `finalize()`는 JVM에 의해 한 번만 호출됩니다.
    
- 수동으로 호출하면 **예상치 못한 시점에 두 번 실행**될 수 있어 예측 불가능한 동작 발생.
    
3. **자원 관리에 혼란**

- 수동 호출로 인해, 자원이 **정상적으로 해제된 것인지**, **GC에 의해 해제될 것인지** 구분이 안됨.
    
- 결과적으로 **메모리 누수** 또는 **자원 충돌**이 발생할 수 있음.
    
4. **finalize()는 deprecated**

- Java 9부터 **Deprecated**
    
- Java 18부터는 **기본적으로 제거됨**
    
- 더 안전한 방식인 `try-with-resources`나 `AutoCloseable` 인터페이스 사용 권장
    

---
✅ 권장되는 자원 정리 방법
```java
try (FileInputStream fis = new FileInputStream("test.txt")) {
    // 파일 처리
} catch (IOException e) {
    // 예외 처리
}
// 자원 자동 해제 (close 호출됨)

```

> → `Closeable` 또는 `AutoCloseable` 구현 클래스는 `try-with-resources`로 안전하게 자원을 해제할 수 있습니다.

---
✅ 요약

|항목|설명|
|---|---|
|`finalize()`는 언제 호출됨?|GC 직전에 JVM이 자동 호출|
|수동 호출의 문제점|생명주기 혼란, 중복 호출, 자원 충돌 위험|
|Java에서의 권장 방법|`AutoCloseable` + `try-with-resources` 사용|
|현재 상태|Java 9부터 deprecated, Java 18에서 제거됨|
##### 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
네, **그 변수의 값이 `null`이 되었다면**, 해당 객체는 **GC(가비지 컬렉션)의 대상이 될 가능성이 있습니다.**

단, 그 객체가 **다른 어떤 곳에서도 참조되지 않고 있어야만** 실제로 GC의 대상이 됩니다.

---
✅ 왜 `null` 할당이 GC와 관련이 있을까?

Java의 GC는 **더 이상 "참조되지 않는" 객체**를 찾아서 메모리에서 제거합니다.  
즉, 어떤 객체를 가리키던 변수가 `null`이 되면, **그 객체에 대한 참조가 하나 줄어드는 것**이고,  
그 객체를 참조하는 **모든 참조가 사라지면** GC는 이를 **쓸모없는 객체로 판단하고 수거**할 수 있습니다.

---
✅ 예시로 이해하기

```java
public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass(); // obj가 MyClass 객체를 참조
        obj = null; // 참조 해제 → GC 대상이 될 수 있음
    }
}

```
- 위 코드에서 `obj = null`로 설정한 순간,
    
- `MyClass` 객체는 **다른 참조가 없다면** → **GC 대상**이 됩니다.
    

---
✅ 주의: null로 만들어도 GC되지 않을 수 있는 경우

1. **다른 곳에서 여전히 참조 중인 경우**
    
```java
MyClass obj1 = new MyClass();
MyClass obj2 = obj1;
obj1 = null; // obj2가 여전히 참조 중 → GC 불가

```
2. **static 변수에 저장된 경우**
    
```java
static MyClass global = new MyClass(); // 프로그램 끝까지 참조됨

```

3. **ThreadLocal, WeakReference 등으로 우회 참조되는 경우**
    

---
✅ 요약

|조건|GC 대상 여부|
|---|---|
|참조가 모두 사라짐 (`null` 포함)|✅ 가능함 (GC 대상)|
|다른 참조가 남아 있음|❌ 대상 아님|
|`null`을 명시적으로 할당하면?|✅ GC 대상이 될 가능성은 높아짐, 단 반드시 그런 건 아님|

---
 🔍 참고

Java에서 `null`을 명시적으로 할당하는 것은 **GC 대상이 될 수 있도록 힌트를 주는 것**이지,  
**즉시 GC가 발생하거나 보장되는 것은 아닙니다.**  
GC는 JVM이 **적절한 시점**에 실행합니다.

### 10. equals()와 hashcode()에 대해 설명해 주세요.
##### 설명
`equals()`와 `hashCode()`는 Java의 모든 객체가 상속받는 `Object` 클래스에 정의된 **핵심 메서드**로,  
**객체 비교**와 **해시 기반 컬렉션(HashMap, HashSet 등)**의 동작에 **직접적인 영향을 미칩니다.**

---
✅ 1. `equals()` 메서드

📌 역할:

- 두 객체가 **논리적으로 동일한지 비교**
    
- 기본 구현은 `==` (즉, **주소 비교**)와 동일
    

📌 보통은 오버라이딩해서 사용

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return age == person.age && name.equals(person.name);
}

```

---
✅ 2. `hashCode()` 메서드

📌 역할:

- 객체의 **해시 값을 반환** (정수값)
    
- **HashMap, HashSet, Hashtable** 등에서 **객체를 저장하거나 조회할 때 사용하는 키 값 계산**
    
```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}

```
✅ 3. `equals()`와 `hashCode()`의 관계

> **"equals()가 true면, hashCode()는 반드시 같아야 한다."**

📌 규칙

- `x.equals(y) == true` → `x.hashCode() == y.hashCode()` ✅ 반드시 만족해야 함
    
- 하지만 `x.hashCode() == y.hashCode()` → `x.equals(y)`는 ❌ 반드시 true일 필요는 없음 (충돌 가능)
    

---
✅ 4. 왜 중요할까?

해시 기반 컬렉션(`HashMap`, `HashSet`)에서 **정확한 동작을 위해 반드시 함께 오버라이드**해야 함.

예시:
```java
Set<User> users = new HashSet<>();
users.add(new User("Alice", 20));
System.out.println(users.contains(new User("Alice", 20))); // equals, hashCode 오버라이드 안 하면 false!

```
---
 ✅ 5. 오버라이드 시 주의사항

- `equals()`에서는 `null`과 `instanceof` 체크 반드시 포함
    
- `hashCode()`는 `equals()`에서 비교하는 필드를 기준으로 생성해야 함
    
- `hashCode()`는 가능한 한 **충돌이 적도록 설계**
    

---
✅ 요약

|항목|설명|
|---|---|
|`equals()`|객체의 **논리적 동등성** 비교|
|`hashCode()`|해시 기반 자료구조를 위한 **정수값 식별자**|
|함께 오버라이딩 이유|`HashSet`, `HashMap`의 일관성 보장|
|규칙|`equals() == true → hashCode() == 같음` 반드시 만족|

##### 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
좋은 질문입니다. `hashCode()`를 직접 정의해야 한다면, 다음과 같은 **원칙과 실용적 고려사항**을 반드시 염두에 두고 구현할 것입니다.

---
✅ 1. **equals()와 일관성 유지 (가장 중요)**

> "두 객체가 `equals()`로 같다면, `hashCode()`도 같아야 한다."

- 비교 대상이 되는 필드(예: `id`, `name`, `email` 등)를 기준으로 `hashCode()`도 계산해야 합니다.
    
- 그렇지 않으면 `HashMap`, `HashSet` 등의 컬렉션에서 의도대로 동작하지 않습니다.
    

---
 ✅ 2. **불변성 보장**

- 객체가 컬렉션에 저장된 후 `hashCode()` 값이 바뀌면, 해당 객체를 **찾을 수 없게 됩니다.**
    
- 따라서, `hashCode()` 계산에 사용하는 필드는 **불변(immutable)** 필드로 선택합니다.
    
예: `ID`, 생성 시 설정되는 `UUID`, 혹은 `final` 필드 등

---
 ✅ 3. **충돌 최소화 (균등한 분포)**

- 다른 객체끼리는 **가능하면 서로 다른 hashCode 값을** 갖도록 설계해야 합니다.
    
- 충돌이 많아지면 해시 테이블의 성능이 **선형 탐색 수준으로 저하**될 수 있습니다.
    

✅ 4. **적절한 해시 조합 공식 사용**

- 자주 사용하는 방식: `Objects.hash(...)`, 또는 `31 * result + field.hashCode()` 패턴
    
```java
@Override
public int hashCode() {
    return Objects.hash(name, age); // Java 7+
}
@Override
public int hashCode() {
    int result = name != null ? name.hashCode() : 0;
    result = 31 * result + age;
    return result;
}

```

> `31`은 소수이고 곱셈 연산에서 좋은 분산을 만들어내는 상수로 널리 사용됩니다.

---
✅ 5. null 안전성 고려

- `null` 필드는 `0` 또는 별도의 처리 필요

 ✅ 요약: 내가 `hashCode()`를 정의할 때 고려할 점

| 고려 항목           | 설명                              |
| --------------- | ------------------------------- |
| `equals()`와 일관성 | 같다고 판단되는 객체는 같은 해시값             |
| 불변 필드 사용        | 해시값이 바뀌지 않도록                    |
| 충돌 최소화          | 다른 객체는 다른 해시값                   |
| null 처리         | NPE 방지                          |
| 성능과 가독성         | `Objects.hash()` 또는 31 곱셈 패턴 사용 |
##### 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
좋은 질문입니다. `equals()` 메서드를 재정의해야 할 때는, 단순히 두 객체가 "같다"는 의미를 넘어 **일관성 있고 신뢰할 수 있는 동작을 보장**해야 합니다. 아래는 재정의 시 반드시 염두에 두어야 할 핵심 사항들입니다.

---
 ✅ 1. **`equals()` 메서드의 기본 규약 (Contract)**

Java의 `Object` 클래스가 요구하는 5가지 규칙은 다음과 같습니다:

| 규칙                   | 설명                                                  |
| -------------------- | --------------------------------------------------- |
| **반사성 (Reflexive)**  | `x.equals(x)`는 항상 true                              |
| **대칭성 (Symmetric)**  | `x.equals(y)`이면 `y.equals(x)`도 true                 |
| **추이성 (Transitive)** | `x.equals(y)`이고 `y.equals(z)`이면 `x.equals(z)`도 true |
| **일관성 (Consistent)** | 여러 번 호출해도 결과가 항상 같아야 함 (값이 변하지 않는 한)                |
| **null에 대한 비대칭성**    | `x.equals(null)`은 항상 false                          |

> 이 규약을 지키지 않으면, `HashMap`, `HashSet`, `List.contains()` 등의 동작이 예측 불가능해집니다.

---
✅ 2. **비교 기준이 되는 필드 일관성 유지**

- `equals()`는 **논리적으로 객체가 같은지 비교하는 메서드**이므로, 비교에 사용할 필드를 신중하게 선택해야 합니다.
    
- 보통 **식별자(id)**, **불변 필드**, **주요 속성** 등을 기준으로 합니다.
    

✅ 3. **`hashCode()`와 항상 함께 재정의**

> `equals()`를 재정의하면 반드시 `hashCode()`도 재정의해야 합니다.

그렇지 않으면 `equals()`는 true인데 `hashCode()`가 다르게 되어,  
`HashSet`, `HashMap` 등에선 **정상적으로 동작하지 않습니다.**

---
✅ 4. **클래스 타입 비교 방법**

- 안전한 방식: `getClass()` 사용 (같은 클래스일 때만 equal)
    
- 유연한 방식: `instanceof` 사용 (상속 관계 포함 가능)
    
```java
// getClass 방식: 대칭성 보장에 안전
if (getClass() != o.getClass()) return false;

```
✅ 5. **성능과 null 안전성 고려**

- `Objects.equals(a, b)`를 사용하면 `null` 비교도 안전하게 처리됩니다.
    


`Objects.equals(this.name, other.name);`

---
✅ 요약: equals() 재정의 시 체크리스트

|항목|설명|
|---|---|
|✅ 반사성/대칭성/추이성 등 규약 준수|Java가 보장하는 동작의 전제|
|✅ 주요 필드를 기준으로 비교|주로 식별자, 불변 필드|
|✅ `hashCode()`도 함께 재정의|컬렉션에서 일관된 동작 보장|
|✅ 클래스 타입 비교 명확히|`getClass()` 또는 `instanceof` 선택|
|✅ null 안전성 고려|`Objects.equals()` 활용 권장|

### 11. IoC와 DI에 대해 설명해 주세요.
##### 설명
IoC와 DI는 객체 지향 프로그래밍과 스프링(Spring) 같은 프레임워크에서 매우 중요한 개념입니다. 두 개념은 밀접하게 관련되어 있으나 의미는 다릅니다. 아래에서 개념과 차이, 예시를 통해 명확히 설명하겠습니다.

---
✅ 1. IoC (Inversion of Control, 제어의 역전)

📌 개념:

- **객체 생성과 의존성 관리의 주도권(제어권)을 개발자 → 프레임워크로 넘기는 것**
    
- 즉, **누가 무엇을 제어하느냐가 바뀌는 것**입니다.
    

📌 예전 방식 (제어권: 개발자)

`UserService service = new UserService(new UserRepository());`

📌 IoC 적용 (제어권: 프레임워크)

> 프레임워크가 객체를 생성하고 필요한 의존성을 주입하며, 객체 간의 관계를 설정함

---
 ✅ 2. DI (Dependency Injection, 의존성 주입)
 📌 개념:

- IoC의 **구현 방법 중 하나**
    
- 어떤 객체가 필요로 하는 **의존 객체를 외부에서 주입**받는 방식
    
 📌 DI 종류

| 방법         | 설명                              |
| ---------- | ------------------------------- |
| **생성자 주입** | 생성자를 통해 의존성 전달 (불변성 보장, 테스트 용이) |
| **세터 주입**  | 세터 메서드로 주입 (선택적 의존성)            |
| **필드 주입**  | 필드에 직접 주입 (`@Autowired`, 권장 X)  |


---
 ✅ 3. IoC vs DI

| 구분     | IoC                   | DI                           |
| ------ | --------------------- | ---------------------------- |
| **의미** | 제어권을 프레임워크로 넘기는 개념    | 의존성을 외부에서 주입하는 방식            |
| **범위** | 포괄적인 설계 철학            | IoC를 구현하는 구체적 수단             |
| **예시** | 객체 생성/초기화를 Spring이 담당 | `@Autowired`, 생성자, 세터 등으로 주입 |

---
 ✅ 4. 예시 (Spring 기반)

 📌 일반적인 DI 코드
```java
@Component
public class UserService {

    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

```
- `UserService`는 `UserRepository`에 의존
    
- 프레임워크(Spring)가 `UserRepository`를 생성해서 `UserService`에 **주입**해줌
    
- 이 전체 과정은 **IoC 컨테이너가 제어권을 가지며**, DI는 **구체적인 주입 행위**
    

---
✅ 요약

| 개념               | 설명                                            |
| ---------------- | --------------------------------------------- |
| **IoC**          | 객체 생성 및 제어권을 프레임워크가 갖는 구조                     |
| **DI**           | 외부에서 필요한 의존 객체를 주입하는 방법                       |
| **관계**           | DI는 IoC의 구현 방식 중 하나                           |
| **Spring에서의 구현** | `@Component`, `@Autowired`, `@Bean`, 생성자 주입 등 |

##### 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
그럼에도 불구하고 **Spring에서 Bean으로 등록해서 사용하는 이유**는 단순히 “대체 가능성” 때문만이 아니라, **아키텍처적 유연성과 핵심 기능 활용** 때문입니다. 아래에서 차근차근 설명드리겠습니다.

---
 ✅ 1. 지금은 하나지만, 나중엔 바뀔 수 있기 때문

- 현재는 구현체가 하나뿐이지만, 시간이 지나면서 요구사항이 늘어나고 다양한 구현이 필요해질 수 있습니다.
    
    - 예: `EmailNotificationService` → 나중엔 `SmsNotificationService`, `PushNotificationService` 추가될 수 있음
        
- 이때 **DI로 설계되어 있다면 구조 변경이 최소화**됩니다.
    

 ✅ 2. Spring의 핵심 기능을 쓰기 위해서 (프레임워크 통합)

Bean으로 등록하면 다음과 같은 **Spring의 기능**들을 사용할 수 있습니다:

| 기능               | 설명                        |
| ---------------- | ------------------------- |
| `@Transactional` | 트랜잭션 자동 관리                |
| `@Async`         | 비동기 실행                    |
| `@Scheduled`     | 스케줄링                      |
| AOP              | 로깅, 보안, 성능 측정 등 횡단 관심사 처리 |
| 프록시 기반 확장        | 실제 구현체를 감싸서 기능 추가 가능      |

→ 일반 클래스 직접 사용하면 이 기능들을 **적용할 수 없습니다.**

---
 ✅ 3. 테스트 용이성

- DI 구조에서는 **Mock 또는 Stub을 쉽게 주입할 수 있습니다.**
    
- 반면 직접 생성하면 테스트가 어렵고, **결합도가 높아집니다.**
    
```java
// 나중에 쉽게 바꿀 수 있음
@Autowired
NotificationService notificationService;

```
 ✅ 4. 생명주기 및 리소스 관리

- Spring은 Bean의 **생성, 초기화, 소멸까지 생명주기를 관리**합니다.
    
- 예: DB 커넥션 풀, 쓰레드풀, 캐시 초기화 등 → 일반 객체로 만들면 수동 관리해야 함
    

---
 ✅ 5. 의존성 자동 주입 및 설정 분리

- Bean을 사용하면 설정을 외부로 분리하고, 구성요소를 동적으로 바꿀 수 있습니다.
    
- `@Profile`, `@Conditional`, `@Value` 등을 이용해 **환경에 따라 유연한 설정** 가능
    

---
 ✅ 요약: 왜 Spring에서는 Bean으로 관리할까?

| 이유                  | 설명                     |
| ------------------- | ---------------------- |
| 확장성                 | 나중에 구현체가 늘어나도 쉽게 대체 가능 |
| AOP/트랜잭션 등 핵심 기능 사용 | Spring이 내부적으로 프록시로 감쌈  |
| 테스트 용이성             | Mock 주입 가능 (DI)        |
| 생명주기 관리             | 객체의 생성~소멸까지 통제         |
| 환경 유연성              | 설정 기반으로 동적으로 선택 가능     |

---
 🔎 결론

> **“지금 하나니까 그냥 쓰자”는 단기적 판단이고, Bean으로 관리하면 ‘유연한 설계’와 ‘Spring의 기능’을 제대로 활용할 수 있는 구조가 됩니다.**

즉, Bean 등록은 단순한 기술적인 선택이 아니라, **좋은 아키텍처를 위한 기반 설계**라고 볼 수 있습니다.
##### Spring의 Bean 생성 주기에 대해 설명해 주세요.
Spring의 Bean 생성 주기(생명주기, Bean Lifecycle)는 **Bean이 컨테이너에 등록되고 소멸되기까지 거치는 단계들**을 의미합니다. 이 과정은 Spring이 **의존성 주입과 초기화, 정리 작업을 자동으로 관리**할 수 있게 해줍니다.

---
 ✅ Spring Bean 생성 주기 (Lifecycle)

1. **Bean 정의 확인 (BeanDefinition 생성)**
    
    - `@Component`, `@Bean`, XML 설정 등에서 Bean 정의를 읽어들임
        
2. **Bean 인스턴스 생성** (`new`)
    
    - 객체 생성 (리플렉션으로 생성자 호출)
        
3. **의존성 주입 (Dependency Injection)**
    
    - `@Autowired`, 생성자, 세터 등을 통해 필요한 의존 객체 주입
        
4. **Aware 인터페이스 호출 (선택적)**
    
    - `BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware` 등
        
    - 자신이 컨테이너 안에서 어떤 Bean인지, 어떤 환경인지 알 수 있음
        
5. **초기화 콜백 호출 (초기화 작업)**
    
    - `@PostConstruct`
        
    - `InitializingBean.afterPropertiesSet()`
        
    - `@Bean(initMethod="...")` 지정 등
        
6. **Bean 사용 (애플리케이션에서 동작)**
    
    - 컨테이너에서 getBean하거나 주입되어 실제 사용됨
        
7. **소멸 콜백 호출 (컨테이너 종료 시)**
    
    - `@PreDestroy`
        
    - `DisposableBean.destroy()`
        
    - `@Bean(destroyMethod="...")` 지정 등
        

---
 ✅ 시각화

`[정의 → 생성 → 주입 → 초기화 → 사용 → 소멸]`

---
 ✅ Bean 초기화 & 소멸 방법 요약

|방식|초기화|소멸|
|---|---|---|
|애노테이션|`@PostConstruct`|`@PreDestroy`|
|인터페이스|`InitializingBean`|`DisposableBean`|
|XML/Java 설정|`initMethod`|`destroyMethod`|

---
 ✅ 예시 코드

```java
@Component
public class MyService implements InitializingBean, DisposableBean {

    @PostConstruct
    public void postConstruct() {
        System.out.println("PostConstruct 초기화");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("InitializingBean 초기화");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("PreDestroy 정리");
    }

    @Override
    public void destroy() {
        System.out.println("DisposableBean 정리");
    }
}

```
✅ 요약

|단계|설명|
|---|---|
|정의|어떤 클래스를 Bean으로 쓸지 인식 (`@Component`, `@Bean`)|
|생성|객체를 인스턴스화|
|의존성 주입|필요한 다른 Bean 주입|
|초기화|`@PostConstruct`, `afterPropertiesSet()`|
|사용|애플리케이션이 사용|
|소멸|`@PreDestroy`, `destroy()`|

---

##### 프로토타입 빈은 무엇인가요?
Spring에서 **프로토타입(Prototype) 빈**은 **요청할 때마다 새로운 인스턴스를 생성하는 Bean 범위(scope)**입니다.  
기본적으로 Spring Bean은 **싱글톤(Singleton)**으로 관리되지만, 필요에 따라 프로토타입 스코프로 설정할 수 있습니다.

---
 ✅ 1. 프로토타입(Prototype) 빈이란?

- **싱글톤 빈**: 컨테이너 시작 시 1개만 생성, 모든 요청에 동일 객체 반환
    
- **프로토타입 빈**: **`getBean()` 호출 시마다 새 객체 생성**
    
```java
@Component
@Scope("prototype")  // 또는 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyPrototypeBean {
    ...
}

```
 ✅ 2. 특징

| 항목         | 설명                                      |
| ---------- | --------------------------------------- |
| **생성 시점**  | `getBean()` 호출할 때마다 새 인스턴스 생성           |
| **관리 범위**  | 생성 및 의존성 주입까지만 Spring이 관리 (소멸은 직접 해야 함) |
| **재사용 여부** | ❌ 항상 새로 생성됨                             |
| **대표 예시**  | 상태가 독립적인 객체, 임시 계산기, 사용자 세션 단위 객체 등     |

---
✅ 3. 사용 예시

```java
@Component
@Scope("prototype")
public class SessionData {
    private final UUID id = UUID.randomUUID();

    public UUID getId() {
        return id;
    }
}

ApplicationContext context = ...
SessionData s1 = context.getBean(SessionData.class);
SessionData s2 = context.getBean(SessionData.class);
System.out.println(s1 == s2); // false (다른 인스턴스)

```
 ✅ 4. 주의사항

❗ 의존성 주입 시 주의 (싱글톤 → 프로토타입)

- 프로토타입 빈을 싱글톤 빈에서 주입받으면 **초기 1회만 생성됨** (즉, 계속 같은 객체)
    
🔧 해결 방법

1. **`ObjectProvider<T>` 또는 `Provider<T>` 사용**
    
```java
@Component
public class SingletonBean {
    @Autowired
    private ObjectProvider<MyPrototypeBean> provider;

    public void logic() {
        MyPrototypeBean prototype = provider.getObject();
    }
}

```
1. **`@Lookup` 애노테이션**
```java
@Component
public class SingletonBean {
    @Lookup
    public MyPrototypeBean getPrototypeBean() {
        return null; // 런타임에 오버라이딩됨
    }
}

```
✅ 5. 프로토타입 빈의 소멸 처리 주의

- Spring은 **생성까지만 관리**하고 `@PreDestroy` 같은 **소멸 콜백을 호출하지 않습니다.**
    
- 필요한 경우 **직접 종료 처리**해야 함.
    

---
 ✅ 요약

|항목|설명|
|---|---|
|스코프 이름|`"prototype"`|
|생성 시점|매번 요청 시 새 인스턴스|
|용도|상태를 가지는 독립적인 객체 필요할 때|
|단점|소멸 관리 책임이 사용자에게 있음|
|싱글톤과 함께 사용할 때|`ObjectProvider`, `@Lookup` 등으로 해결|

### 12. AOP에 대해 설명해 주세요.
##### 설명
AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)는  
**공통 관심사(Cross-Cutting Concerns)**를 **핵심 로직과 분리하여 모듈화하는 프로그래밍 패러다임**입니다.  
주로 **로깅, 보안, 트랜잭션, 성능 측정, 예외 처리** 같은 기능을 핵심 비즈니스 코드와 분리하기 위해 사용됩니다.

---
 ✅ 왜 AOP가 필요한가요?

**기존 OOP만으로는 공통 기능을 여러 클래스에 반복적으로 작성해야 함**

 ❌ OOP만 사용하는 경우 (중복 발생)

```java
public void placeOrder() {
    log.info("주문 시작"); // 공통 관심사
    ... // 주문 처리 로직
    log.info("주문 완료");
}

```

 ✅ AOP를 사용하는 경우

```java
@Around("execution(* com.myapp.service.*.*(..))")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    log.info("메서드 시작");
    Object result = joinPoint.proceed();
    log.info("메서드 끝");
    return result;
}

```
→ 핵심 로직은 그대로 유지되며, **공통 기능은 분리된 AOP 모듈로 관리**

---
 ✅ 핵심 개념

| 용어             | 설명                                           |
| -------------- | -------------------------------------------- |
| **Aspect**     | 공통 관심사를 모듈화한 클래스 (`@Aspect`)                 |
| **Join Point** | Aspect가 적용 가능한 지점 (ex. 메서드 호출 시점)            |
| **Advice**     | Join Point에서 수행될 코드 (실제 실행 로직)               |
| **Pointcut**   | Advice를 적용할 Join Point를 선정하는 표현식             |
| **Weaving**    | Aspect를 실제 코드에 적용하는 과정 (컴파일/런타임/클래스 로딩 시점 등) |

---
 ✅ Advice 종류

|타입|설명|
|---|---|
|`@Before`|메서드 실행 **전** 실행|
|`@After`|메서드 실행 **후(무조건)** 실행|
|`@AfterReturning`|메서드가 **정상 종료**되었을 때 실행|
|`@AfterThrowing`|**예외 발생** 시 실행|
|`@Around`|메서드 **전후** 모두 처리 가능 (`joinPoint.proceed()`로 핵심 로직 호출)|

---
 ✅ Spring AOP vs AspectJ

|구분|설명|
|---|---|
|**Spring AOP**|프록시 기반, 메서드 단위만 지원, DI 환경에 통합|
|**AspectJ**|바이트코드 조작 기반, 더 정밀한 weaving 가능, 독립 사용 가능|

 ✅ 요약

|항목|설명|
|---|---|
|정의|공통 관심사를 모듈화하여 핵심 로직과 분리하는 기법|
|장점|코드 중복 제거, 관심사 분리, 유지보수 용이|
|사용 사례|트랜잭션, 로깅, 보안, 캐싱, 예외 처리|
|핵심 개념|Aspect, JoinPoint, Advice, Pointcut, Weaving|
|Spring AOP|프록시 기반, 런타임에 적용됨|
##### @Aspect는 어떻게 동작하나요?
좋은 질문입니다.  
`@Aspect`는 **Spring AOP에서 공통 관심사를 구현하는 핵심 어노테이션**입니다.  
이 어노테이션이 어떻게 동작하는지 이해하려면, **프록시 기반의 AOP 처리 방식**과 **스프링 컨테이너 내부 처리 흐름**을 함께 살펴봐야 합니다.

---
✅ 핵심 요약:

`@Aspect`가 붙은 클래스는 **Spring이 자동으로 프록시 객체를 만들어**,  
**지정한 Pointcut에 Advice를 삽입**하는 방식으로 동작합니다.

---
 ✅ 동작 흐름 요약 (Spring AOP)

1. **`@Aspect` 클래스 스캔**
    
    - `@EnableAspectJAutoProxy` 또는 Spring Boot의 자동 설정에 의해,
        
    - `@Aspect`가 붙은 클래스를 **빈으로 등록**하고 AOP 대상으로 인식함
        
2. **Pointcut 분석**
    
    - `execution(...)`, `within(...)`, `@annotation(...)` 등의 표현식을 분석해,
        
    - 어떤 **JoinPoint(=대상 메서드)**에 Advice를 적용할지 결정
        
3. **프록시 생성**
    
    - 대상 객체(Bean)에 대한 **프록시(Proxy) 객체**를 생성
        
        - **인터페이스 기반**이면 → JDK 동적 프록시
            
        - **클래스 기반**이면 → CGLIB 프록시
            
4. **Advice 연결**
    
    - 프록시 객체의 메서드가 호출되면,
        
    - 설정한 Pointcut 조건에 맞는 Advice(`@Before`, `@After`, `@Around` 등)가 **실행 순서에 따라 호출**됨
        
    - 이후 **원래 메서드 호출** (`joinPoint.proceed()`)
        

---
 ✅ 그림으로 이해 (예시: `@Around`)
```
[Client Code] 
    ↓
[프록시 객체]
    ↓  (1) @Before
    ↓  (2) @Around (joinPoint.proceed())
    ↓  (3) 원래 Bean의 메서드 실행
    ↑  (4) @AfterReturning 또는 @AfterThrowing
    ↑  (5) @After

```
 ✅ 예제 코드
```java
@Aspect
@Component
public class LoggingAspect {
 
    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Before: " + joinPoint.getSignature());
        Object result = joinPoint.proceed(); // 실제 메서드 호출
        System.out.println("After: " + joinPoint.getSignature());
        return result;
    }
}

```
 ✅ 주의할 점

| 항목                       | 주의 내용                           |
| ------------------------ | ------------------------------- |
| **private 메서드에는 적용 안 됨** | 프록시 기반이므로 public 메서드만 가능        |
| **자기 자신 내부 호출에는 적용 안 됨** | this 내부 호출은 프록시 우회 → AOP 안 먹힘   |
| **final 클래스/메서드는 제한 있음** | CGLIB은 final 메서드 오버라이딩 불가       |
| **빈으로 등록되어야 동작**         | `@Component` 또는 `@Bean`으로 등록 필요 |

---
 ✅ 요약

| 항목          | 설명                                            |
| ----------- | --------------------------------------------- |
| `@Aspect`란? | 공통 관심사를 모듈화한 클래스 정의용 어노테이션                    |
| 동작 방식       | Spring이 프록시 객체를 만들어 Advice를 삽입                |
| 핵심 기술       | JDK Proxy 또는 CGLIB, `@EnableAspectJAutoProxy` |
| 트리거 시점      | Pointcut으로 지정한 JoinPoint가 호출될 때               |
| 주의사항        | 프록시 기반 특성: 자기 호출, private, final 등 제한         |


### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
##### 설명
Spring에서 **Interceptor**와 **Servlet Filter**는 모두 HTTP 요청/응답의 흐름을 가로채서 공통 처리를 할 수 있는 기능이지만, 동작 시점과 적용 범위, 사용 목적에서 차이가 있습니다.

---
1. Servlet Filter

**(서블릿 스펙의 기능, Spring 프레임워크 밖에서 동작)**

특징

- **Servlet API**에 정의된 표준 기능 → `javax.servlet.Filter` 구현.
    
- **DispatcherServlet** 실행 전/후에 동작 (즉, 스프링 MVC 전 단계에서 요청과 응답을 가로챔).
    
- Spring뿐 아니라 모든 서블릿 기반 애플리케이션에서 동작.
    
- **주요 용도**
    
    - 요청/응답 로깅
        
    - 인코딩 설정 (`CharacterEncodingFilter`)
        
    - CORS 처리 (`CorsFilter`)
        
    - 보안 관련 체크 (XSS 방지, 인증 토큰 검증 등)
        
    - 요청 래핑/변환
        
- **동작 구조**
    
    sql
    
    복사편집
    
    `클라이언트 → Filter → DispatcherServlet → Controller → View → Filter → 클라이언트`
    
구현 예시
```java
@WebFilter(urlPatterns = "/*")
public class MyFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Filter: Before request");
        chain.doFilter(request, response);
        System.out.println("Filter: After response");
    }
}

```

---
2. Spring Interceptor

**(Spring MVC 기능, DispatcherServlet 이후 동작)**

특징

- Spring MVC 전용 기능 → `HandlerInterceptor` 인터페이스 구현.
    
- **Handler(Controller)** 호출 전/후, View 렌더링 전 단계에서 동작.
    
- Spring 컨텍스트 내부에서 동작하므로 **Spring Bean** 의존성 주입 가능.
    
- **주요 용도**
    
    - 로그인 여부 체크
        
    - 권한(Authorization) 검사
        
    - 컨트롤러에 전달될 데이터 가공
        
    - Controller 실행 전후 로깅
        
    - 특정 URI 접근 제한
        
- **동작 구조**
    
    scss
    
    복사편집
    
    `클라이언트 → Filter → DispatcherServlet    → Interceptor preHandle() → Controller   → Interceptor postHandle() → View   → Interceptor afterCompletion() → Filter → 클라이언트`
    
구현 예시
```java
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        System.out.println("Interceptor: Before Controller");
        return true; // false 반환 시 이후 흐름 중단
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) {
        System.out.println("Interceptor: After Controller, before View");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) {
        System.out.println("Interceptor: After View rendering");
    }
}

```

---
3. 주요 차이점 정리

| 구분                 | Servlet Filter                           | Spring Interceptor                       |
| ------------------ | ---------------------------------------- | ---------------------------------------- |
| **소속**             | Servlet 표준 스펙                            | Spring MVC                               |
| **실행 시점**          | DispatcherServlet **전/후**                | DispatcherServlet 내부, Controller **전/후** |
| **적용 범위**          | 모든 요청(정적 리소스 포함)                         | Spring MVC Handler(Controller) 요청만       |
| **Spring Bean 사용** | 불가능(직접 DI 불가)                            | 가능                                       |
| **대표 예시**          | 인코딩 필터, CORS 필터, XSS 필터                  | 인증 체크, 로깅, Controller 파라미터 가공            |
| **등록 방법**          | `@WebFilter` 또는 `FilterRegistrationBean` | `WebMvcConfigurer.addInterceptors()`     |
|                    |                                          |                                          |

---

📌 **정리**

- **전역적·저수준 처리**가 필요하면 → **Filter**
    
- **Spring MVC Handler 전후 로직**이 필요하면 → **Interceptor**

##### 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?
겉으로 보면 Interceptor가 더 편리해 보이지만, **필터(Filter)만이 적합한 경우**가 분명히 있습니다.  
이유는 **동작 범위와 위치**가 다르기 때문입니다.

---
1. 인터셉터만 쓰면 안 되는 경우

Interceptor는 **Spring MVC의 DispatcherServlet 이후**에 동작합니다.  
즉, **다음과 같은 요청은 아예 Interceptor를 거치지 않습니다**:

- 정적 리소스 (이미지, CSS, JS 파일)
    
- DispatcherServlet 매핑 범위 밖의 요청 (예: `/error`, 서블릿 직접 호출)
    
- 필터 단계에서 차단해야 하는 저수준 보안 처리
    

따라서, 이런 경우에는 Interceptor가 아닌 Filter를 써야 합니다.

---
2. 필터가 꼭 필요한 대표 상황
(1) **서블릿 단 레벨의 전역 처리**

- 요청 인코딩 강제 설정 (`CharacterEncodingFilter`)
    
- 요청·응답 Wrapping (예: XSS 방지 필터, 파라미터 변조 방지)
    
- 모든 HTTP 요청/응답에 대한 로깅 (정적 리소스 포함)
    
- 특정 HTTP Header 강제 추가/수정
    

➡️ **이유:** Interceptor는 Spring MVC 요청만 가로채므로 이런 범위의 처리는 Filter가 유리합니다.

---

(2) **Spring 컨텍스트 로딩 전 단계에서 처리해야 하는 경우**

- 애플리케이션 보안 초기화 (`DelegatingFilterProxy` 기반 Spring Security 필터 체인)
    
- 요청 차단 (화이트리스트, 블랙리스트)  
    → Spring MVC에 도달시키지 않고 응답을 끝내야 하는 경우
    
- 압축/디컴프레션(Gzip) 처리
    

➡️ **이유:** Interceptor는 이미 DispatcherServlet이 요청 객체를 만든 이후에 동작하므로, 그 전에 처리해야 하는 로직은 Filter에서만 가능.

---
(3) **프레임워크 통합**

- Spring Security, CORS, Sitemesh, Shiro 같은 보안/뷰 레이아웃 프레임워크 대부분이 필터 기반.
    
- 이유는 Servlet 스펙에 의존해야 하고, Spring 외부에서도 동작 가능해야 하기 때문.
    

---
3. 비교 관점 요약

| 구분             | Filter                           | Interceptor                           |
| -------------- | -------------------------------- | ------------------------------------- |
| **위치**         | DispatcherServlet **전/후** (더 바깥) | DispatcherServlet 내부 (Controller 전/후) |
| **적용 대상**      | 모든 요청 (정적 리소스 포함)                | Spring MVC Handler 요청만                |
| **사용 목적**      | 전역·저수준 처리                        | 컨트롤러 전후 로직                            |
| **Spring 의존성** | 없음                               | 있음                                    |
| **차단 가능 시점**   | 서블릿 진입 전                         | Handler 실행 전                          |

---

💡 **결론**

- **전역적인 보안, 인코딩, 로깅, 전처리** → **Filter**
    
- **Spring MVC Controller 전/후 로직** → **Interceptor**
    
- 보통 실무에서는 **Filter + Interceptor를 함께** 사용합니다.  
    예: Filter로 인코딩·보안 프레임워크 적용 → Interceptor로 로그인 체크, 파라미터 가공.

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.
##### 설명
**DispatcherServlet**은 Spring MVC에서 **중앙 제어(Front Controller)** 역할을 하는 핵심 서블릿입니다.  
클라이언트로부터 들어온 HTTP 요청을 받고, 알맞은 컨트롤러로 분배(dispatch)한 뒤, 처리 결과를 적절한 뷰(View)에 연결해 응답을 반환합니다.

---
 1. **DispatcherServlet의 위치와 흐름**

Spring MVC의 전형적인 요청 처리 순서:
```
클라이언트 → (필터) → DispatcherServlet
    → HandlerMapping
    → HandlerAdapter
    → Controller (Handler)
    → ModelAndView 반환
    → ViewResolver
    → View
    → 응답 반환 → (필터) → 클라이언트

```
---
2. **DispatcherServlet의 주요 역할**
(1) **요청 수신과 분배 (Dispatch)**

- 클라이언트 요청을 받아 **HandlerMapping**을 사용해 어떤 컨트롤러(Handler)가 처리할지 결정.
    
- 예: `/users` 요청 → `UserController` 매핑.
    

---
(2) **Handler 실행**

- 결정된 컨트롤러를 실행할 수 있는 **HandlerAdapter**를 찾아 실행.
    
- HandlerAdapter는 다양한 형태의 컨트롤러를 호출 가능 (예: `@Controller`, `HttpRequestHandler`, `SimpleControllerHandlerAdapter` 등).
    

---
 (3) **결과(ModelAndView) 수집**

- 컨트롤러 실행 결과로 **Model(데이터)**와 **View 이름**을 함께 받음.
    
- 예: `ModelAndView("userList", model)`.
    

---
 (4) **뷰(View) 선택과 렌더링**

- **ViewResolver**를 사용해 뷰 이름을 실제 뷰 객체(예: JSP, Thymeleaf)로 변환.
    
- 변환된 뷰 객체에 Model 데이터를 전달하고 렌더링.
    

---
(5) **예외 처리**

- 컨트롤러나 뷰 처리 중 예외가 발생하면 **HandlerExceptionResolver**를 통해 예외 처리 로직 실행.
    
- 예: 특정 예외 시 에러 페이지로 이동.
    

---
(6) **전역 부가기능 연동**

- Spring MVC에서 제공하는 Interceptor, LocaleResolver, MultipartResolver 등의 부가기능과 연동.
    

---
3. **DispatcherServlet 초기화 과정**

- 애플리케이션 시작 시 `DispatcherServlet`이 로드되면, 내부적으로 Spring MVC 관련 빈을 초기화.
    
- **기본 전략 클래스**들을 로드 (`DispatcherServlet.properties`)
    - HandlerMapping
    - HandlerAdapter
    - ViewResolver
    - LocaleResolver
    - ThemeResolver
    - MultipartResolver
    - ExceptionResolver
---
4. **한 줄로 요약**

> DispatcherServlet = **요청과 응답을 총괄 지휘하는 Spring MVC의 Front Controller**  
> 요청 → 컨트롤러 실행 → 모델+뷰 결합 → 뷰 렌더링 → 응답 반환
##### 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
1. 왜 동시에 처리할 수 있는가

- **DispatcherServlet**은 서블릿 표준을 구현한 클래스(`HttpServlet` 상속).
    
- 서블릿 컨테이너(예: Tomcat, Jetty, Undertow)는 **요청마다 별도의 스레드**를 만들어 `service()` → `doGet()` / `doPost()` 메서드를 호출.
    
- 하나의 DispatcherServlet 인스턴스가 애플리케이션에 단 하나만 존재하지만,  
    요청이 오면 각 요청은 **서로 다른 스레드**에서 같은 인스턴스의 메서드를 호출합니다.
    

즉, 구조상 **싱글 인스턴스 + 멀티스레드 처리**입니다.

---

2. 동작 예시



`클라이언트1 → Thread-1 → DispatcherServlet → Controller 클라이언트2 → Thread-2 → DispatcherServlet → Controller 클라이언트3 → Thread-3 → DispatcherServlet → Controller ...`

- 각 요청은 **독립적인 HttpServletRequest / HttpServletResponse 객체**를 가집니다.
    
- 스레드끼리 요청 데이터가 섞이지 않음.
    

---
3. 주의할 점

멀티스레드 환경이므로 **DispatcherServlet 내부에서 사용하는 객체의 상태 관리**에 주의해야 합니다.

- **스레드 안전성(Thread-safety)** 보장 필요.
    
- 필드(인스턴스 변수)에 요청별 데이터를 저장하면 **데이터 섞임(경쟁 상태)** 발생 가능.
    
- 요청별 상태는 **지역변수** 또는 **ThreadLocal**을 사용.
    

---
4. 결론

- **DispatcherServlet은 동시에 여러 요청을 받을 수 있다.**
    
- 이는 서블릿 컨테이너가 스레드를 요청별로 할당해 주기 때문.
    
- 따라서 Controller, Service 계층에서도 **상태를 공유하는 필드**를 두면 안 되고, **무상태(stateless)**로 설계하는 것이 원칙.
##### 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?
DispatcherServlet이 여러 개의 `@Controller` 중에서 **어떤 컨트롤러를 실행할지 구분**하는 핵심 비밀은 **HandlerMapping** 덕분입니다.

---
1. 요청이 들어왔을 때의 기본 흐름


`클라이언트 요청  → DispatcherServlet    → HandlerMapping(매핑 조회)    → HandlerAdapter(호출 방식 결정)    → 해당 @Controller 메서드 실행`

---
2. HandlerMapping의 역할

- Spring MVC에서 **HandlerMapping**은  
    _"이 URL 요청은 어느 핸들러(Controller 메서드)가 처리해야 하는가?"_  
    를 찾아주는 컴포넌트입니다.
    
- DispatcherServlet은 요청을 받자마자 **여러 HandlerMapping 구현체**를 순서대로 조회합니다.
    

---
3. @Controller 매핑이 등록되는 방식

Spring은 애플리케이션 시작 시 다음 과정을 거칩니다:

1. **`@Controller` 빈 스캔**
    
    - `@Controller`, `@RequestMapping`이 붙은 클래스와 메서드를 찾음.
        
2. **RequestMappingHandlerMapping에 등록**
    
    - 각 메서드의 URL 패턴, HTTP 메서드(GET, POST 등), 파라미터 조건 등을 키로 해서 매핑 테이블 생성.
        
        
        `"/users" + GET  → UserController.listUsers() "/users/{id}" + GET → UserController.getUser() "/users" + POST → UserController.createUser()`
        
3. 요청이 들어오면 RequestMappingHandlerMapping이 이 테이블에서 해당하는 메서드를 찾아서 반환.
    

---
4. 예시

```java
@Controller
@RequestMapping("/users")
public class UserController {

    @GetMapping
    public String listUsers() { ... }

    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id) { ... }

    @PostMapping
    public String createUser(UserDto dto) { ... }
}

```
서버 시작 시 매핑 테이블:

|URL 패턴|HTTP Method|핸들러 메서드|
|---|---|---|
|`/users`|GET|listUsers()|
|`/users/{id}`|GET|getUser()|
|`/users`|POST|createUser()|

---
5. DispatcherServlet이 구분하는 핵심 로직

	1. **요청 URL**과 **HTTP Method**를 기준으로  
    `RequestMappingHandlerMapping`이 알맞은 컨트롤러 메서드를 찾음.
    
	2. 매칭된 메서드와 컨트롤러 객체를 `HandlerExecutionChain` 형태로 DispatcherServlet에 반환.
    
	3. DispatcherServlet은 해당 Handler를 **HandlerAdapter**를 통해 실행.
    

---
 6. 한 줄 요약

> DispatcherServlet이 여러 @Controller를 구분할 수 있는 이유는  
> **HandlerMapping(특히 RequestMappingHandlerMapping)이 URL, HTTP 메서드, 조건을 기준으로 미리 매핑 테이블을 만들어두기 때문**입니다.

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
##### 설명
JPA 같은 **ORM(Object-Relational Mapping)**을 사용하는 이유는 단순히 “SQL을 대신 작성해주기 때문”이 아니라, **객체 지향 애플리케이션과 관계형 데이터베이스 사이의 불일치를 해결하고 생산성을 높이기 위해서**입니다.

아래에 이유를 정리하겠습니다.

---
1. 객체-관계 불일치(패러다임 불일치) 해결

- **문제:**
    
    - 자바는 객체 지향 언어 → 객체, 상속, 연관관계, 캡슐화 등을 사용
        
    - DB는 관계형 모델 → 테이블, 외래키, 조인 사용
        
    - 양쪽의 데이터 구조와 표현 방식이 다름.
        
- **JPA 역할:**
    
    - 자바 객체와 DB 테이블 간의 매핑을 자동화해 개발자가 SQL을 직접 매번 작성하지 않아도 됨.
        
    - 예: 객체 필드 ↔ 테이블 컬럼, 객체 관계 ↔ 외래키·조인 자동 처리
        
---
 2. 생산성 향상

- **JPA 사용 전**
```java
    String sql = "SELECT * FROM member WHERE id = ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setLong(1, id);
ResultSet rs = ps.executeQuery();

```
- **JPA 사용 후**
    
```java
    Member member = em.find(Member.class, id);

```
    
- SQL, JDBC API, ResultSet 매핑 작업을 대폭 줄여 코드량과 개발 시간이 단축.
    

---
 3. 유지보수성 향상

- SQL이 코드에 직접 섞여 있으면, 테이블 구조가 바뀔 때 관련된 SQL을 모두 찾아 수정해야 함.
    
- JPA는 매핑 설정만 변경하면 대부분의 CRUD 로직은 그대로 동작 → **변경에 유연**.
    

---
4. 객체 지향적인 데이터 접근 가능

- **지연 로딩(Lazy Loading)**, **즉시 로딩(Eager Loading)** 설정으로 필요한 시점에 데이터를 가져옴.
    
- 객체 그래프 탐색 가능:
    
    java
    
    복사편집
    
    `member.getOrders().get(0).getProduct();`
    
    → 객체처럼 참조를 타고 데이터 접근 가능.
    

---
5. 벤더 종속성 줄이기

- 순수 JDBC나 MyBatis는 DBMS에 따라 SQL 문법이 달라지면 수정해야 함.
    
- JPA는 표준 스펙이므로 구현체(Hibernate, EclipseLink 등)를 바꾸거나 DB를 변경해도 매핑 설정만 조금 조정하면 재사용 가능.
    

---
6. 캐싱과 성능 최적화 기능

- 1차 캐시, 변경 감지(Dirty Checking), 쓰기 지연(SQL batching) 등 JDBC에서 직접 구현하려면 복잡한 기능들을 제공.
    
- 복잡한 N+1 문제, 벌크 연산, 페이징 처리 같은 것도 API로 제공.
    

---
7. 트랜잭션과 일관성 유지

- 엔티티 변경을 트랜잭션 범위에서 자동으로 감지하고, 커밋 시점에 변경 사항을 DB에 반영(Flush).
    
- 개발자가 직접 update 문을 작성하지 않아도 데이터 일관성 유지 가능.
    

---
📌 한 줄 결론

> JPA 같은 ORM은 **객체 지향과 관계형 DB 사이의 패러다임 불일치를 해결**하고,  
> **생산성과 유지보수성, 성능, 이식성을 향상**시키기 위해 사용합니다.  
> 단, 내부 동작 원리를 모르면 성능 문제(N+1, 불필요한 쿼리)나 복잡한 쿼리 작성에서 한계가 있으므로 학습이 필수입니다.
##### 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
네, JPA에서 말하는 **영속성(Persistence)** 기능은 단순히 데이터를 오래 저장하는 의미가 아니라, **엔티티를 “영속성 컨텍스트”라는 1차 캐시에 저장하고 관리하는 것**을 뜻합니다.  
이게 성능에도 꽤 도움이 되고, 데이터 일관성 유지에도 핵심 역할을 합니다.

---
1. 영속성 컨텍스트의 역할

영속성 컨텍스트(Persistence Context)는 **엔티티와 DB 사이에서 엔티티를 관리하는 가상의 저장소(1차 캐시)**입니다.  
`EntityManager`가 관리하며, 트랜잭션 범위 안에서 동작합니다.

주요 기능은 다음과 같습니다:

---
(1) 1차 캐시 (First-level Cache)

- 한 트랜잭션 안에서 같은 엔티티를 여러 번 조회하면, DB를 매번 접근하지 않고 **메모리에 있는 엔티티를 재사용**합니다.
    

java

복사편집

`Member m1 = em.find(Member.class, 1L); // DB 조회 Member m2 = em.find(Member.class, 1L); // 1차 캐시에서 반환 (쿼리 안 날림)`

➡️ 장점: **불필요한 DB 쿼리 제거** → 성능 향상.

---
(2) 동일성 보장 (Identity Guarantee)

- 같은 영속성 컨텍스트 안에서 조회한 엔티티는 **동일한 객체 인스턴스**를 반환.
    


`em.find(Member.class, 1L) == em.find(Member.class, 1L) // true`

➡️ 비즈니스 로직에서 객체 비교 시 예기치 않은 버그 방지.

---
 (3) 쓰기 지연(Write-behind)

- `persist()` 호출 시 바로 insert 쿼리를 DB에 날리지 않고, **SQL 저장소에 모아두었다가** 트랜잭션 커밋 시점에 한 번에 실행(batch).
    

java

복사편집

`em.persist(m1); em.persist(m2); // 커밋 시점에 INSERT 2개를 모아서 실행`

➡️ 장점: DB I/O 횟수 줄어듦, 배치 최적화 가능.

---
(4) 변경 감지(Dirty Checking)

- 영속 상태 엔티티의 필드를 변경하면, 트랜잭션 커밋 시점에 **변경된 부분만 update 쿼리로 자동 반영**.
    

java

복사편집

`Member m = em.find(Member.class, 1L); m.setName("newName"); // update 안 해도 됨`

➡️ 장점: 개발자가 update SQL을 직접 작성하지 않아도 됨, 데이터 일관성 유지.

---
(5) 지연 로딩(Lazy Loading) 지원

- 연관된 엔티티를 필요할 때만 SELECT 쿼리로 불러옴 → 초기 로딩 부담 감소.
    

java

복사편집

`member.getOrders(); // 접근 시점에 쿼리 실행`

---
2. 성능 향상 효과

영속성 컨텍스트의 성능 이점은 주로 **DB 접근 최소화**에서 옵니다.

- 같은 트랜잭션에서 같은 데이터 재조회 → DB I/O 제거 (1차 캐시)
    
- INSERT/UPDATE 모아서 실행 → 네트워크 왕복 횟수 줄임
    
- Lazy Loading으로 불필요한 데이터 미조회
    

하지만 **주의점**도 있습니다:

- 1차 캐시는 **트랜잭션 단위 캐시**이므로, 대규모 반복 조회에는 큰 도움 안 됨 (그 경우 2차 캐시 필요).
    
- 너무 많은 엔티티를 영속성 컨텍스트에 올리면 메모리 사용량 증가 → 성능 저하 가능.
    

---
3. 결론

> 영속성 컨텍스트는 **JPA 성능 최적화의 핵심 기능**입니다.  
> 특히 1차 캐시, 쓰기 지연, 변경 감지 덕분에 불필요한 SQL 실행을 줄이고, 개발 편의성과 일관성을 동시에 확보할 수 있습니다.  
> 다만 무조건 성능이 좋아지는 건 아니며, 대규모 데이터 처리 시 캐시 관리 전략이 필요합니다.
##### N + 1 문제에 대해 설명해 주세요.
**N+1 문제**는 JPA 같은 ORM을 사용할 때 자주 발생하는 **성능 문제**로,  
"한 번의 쿼리로 끝낼 수 있는 작업이 N+1번의 쿼리로 쪼개져 실행되는 현상"을 말합니다.

---
1. 상황 예시

예를 들어 **회원(Member)**과 **주문(Order)**이 1:N 관계라고 합시다.

java

복사편집

`List<Member> members = em.createQuery("SELECT m FROM Member m", Member.class)                          .getResultList();  for (Member m : members) {     System.out.println(m.getOrders().size()); }`

쿼리 실행 흐름

1. **첫 번째 쿼리 (1번)**
    
    sql
    
    복사편집
    
    `SELECT * FROM member;`
    
    → 모든 회원 목록 조회
    
2. **반복문 돌 때마다 N번의 쿼리**
    
    sql
    
    복사편집
    
    `SELECT * FROM orders WHERE member_id = 1; SELECT * FROM orders WHERE member_id = 2; ...`
    
    → 회원이 100명이면 100번 실행
    

➡ 총 쿼리 수 = **1 + N** → 이게 바로 **N+1 문제**

---
 2. 왜 발생하나?

- JPA에서 `@OneToMany`, `@ManyToOne` 같은 연관관계는 **기본이 Lazy Loading**.
    
- Lazy Loading은 연관 데이터를 처음 접근하는 시점에 SELECT 쿼리를 날림.
    
- 결과적으로 첫 조회 후, 컬렉션이나 연관 엔티티에 접근할 때마다 새로운 쿼리가 발생.
    

---
 3. 문제점

- 쿼리 수가 데이터 개수에 비례해 폭발적으로 증가.
    
- DB 부하 + 네트워크 왕복 비용 증가.
    
- 대량 데이터 조회 시 심각한 성능 저하.
    

---
4. 해결 방법
(1) **Fetch Join** 사용

- 연관 엔티티를 한 번의 조인 쿼리로 함께 조회.
    

java

복사편집

`SELECT m FROM Member m JOIN FETCH m.orders;`

➡ 회원과 주문을 한 번에 가져와 N+1 방지.

---
(2) **Entity Graph** 사용

- `@EntityGraph` 애너테이션을 활용해 fetch join 효과를 선언적으로 적용.
    

java

복사편집

`@EntityGraph(attributePaths = {"orders"}) @Query("SELECT m FROM Member m") List<Member> findAllWithOrders();`

---
(3) **Batch Size 설정**

- 컬렉션이나 프록시 초기화 시 한 번에 여러 건을 IN 쿼리로 가져오도록 설정.
    

java

복사편집

`@OneToMany(mappedBy = "member") @BatchSize(size = 100) private List<Order> orders;`

또는 `hibernate.default_batch_fetch_size` 전역 설정.

---
 5. 결론

> N+1 문제는 **ORM의 지연 로딩 전략이 잘못 적용될 때 발생하는 대표적인 성능 이슈**입니다.  
> 해결을 위해서는 **fetch join, entity graph, batch size 조정** 등을 상황에 맞게 사용해야 하며,  
> 쿼리 로그를 항상 확인하는 습관이 중요합니다.

### 16. @Transactional 은 어떤 기능을 하나요?
##### 설명
`@Transactional`은 **Spring에서 메서드나 클래스에 트랜잭션 경계를 선언적으로 지정**하는 애너테이션입니다.  
이걸 붙이면 해당 코드가 실행될 때 **트랜잭션 시작 → 커밋(또는 롤백)** 과정을 스프링이 자동으로 처리해 줍니다.

---
 1. 기본 동작

`@Transactional`이 붙은 메서드가 호출되면 스프링이 다음과 같이 동작합니다.

1. **트랜잭션 시작**
    
    - DB 커넥션을 가져오고 `setAutoCommit(false)`로 설정.
        
    - 이후 실행되는 모든 JDBC 작업이 하나의 트랜잭션 안에서 수행됨.
        
2. **비즈니스 로직 실행**
    
    - DAO, JPA repository 등에서 SQL 실행.
        
3. **정상 종료 → 커밋**
    
    - 예외 없이 메서드가 끝나면 `commit()` 호출.
        
4. **예외 발생 → 롤백**
    
    - 기본적으로 **런타임 예외(언체크 예외)** 발생 시 rollback.
        
    - 체크 예외는 rollback하지 않지만 `rollbackFor` 옵션으로 변경 가능.
        

---
 2. 주요 기능
 (1) **트랜잭션 경계 자동 관리**

- 수동으로 커넥션, 커밋, 롤백 처리할 필요 없이 애너테이션으로 지정.
    
 (2) **트랜잭션 전파(Propagation)**

- 이미 진행 중인 트랜잭션이 있으면 합류할지, 새로운 트랜잭션을 만들지 결정.
    
- 예: `REQUIRED`(기본) → 기존 트랜잭션 있으면 합류, 없으면 새로 생성.
    
 (3) **격리 수준(Isolation Level) 설정**

- Dirty Read, Non-repeatable Read, Phantom Read 같은 문제 방지 수준 지정 가능.
    

java

복사편집

`@Transactional(isolation = Isolation.READ_COMMITTED)`

 (4) **읽기 전용 모드**

- `readOnly = true` 설정 시 Hibernate나 JPA가 플러시를 생략해 성능 최적화 가능.
    

java

복사편집

`@Transactional(readOnly = true)`

 (5) **롤백 조건 지정**

- 기본은 RuntimeException, Error 롤백.
    
- 체크 예외나 특정 예외에 대해서도 롤백 가능.
    

java

복사편집

`@Transactional(rollbackFor = SQLException.class)`

---
 3. 예시

java

복사편집

`@Service public class OrderService {      @Transactional     public void placeOrder(Order order) {         orderRepository.save(order); // INSERT         paymentService.pay(order);   // UPDATE/INSERT         // 예외 발생 시 위 두 작업 모두 롤백     } }`

---
 4. 핵심 포인트

- **트랜잭션을 선언적으로 관리** → 코드 단순화.
    
- DB 일관성과 원자성을 보장.
    
- Spring AOP 기반으로 프록시가 메서드 호출 전후에 트랜잭션 처리 로직을 넣어줌.
    
- **주의:** 같은 클래스 안의 메서드끼리 `@Transactional` 호출하면 적용 안 될 수 있음(프록시 우회).
    

---

📌 **한 줄 요약**

> `@Transactional`은 메서드나 클래스에 붙여서 **트랜잭션의 시작, 커밋, 롤백을 자동으로 관리**하는 선언적 트랜잭션 처리 도구입니다.  
> 덕분에 개발자는 트랜잭션 경계와 JDBC API를 직접 다루지 않아도 되고, 일관성과 무결성을 쉽게 유지할 수 있습니다.
##### @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
`@Transactional(readOnly = true)`는 **트랜잭션을 읽기 전용 모드로 실행하겠다**는 선언입니다.  
단순히 “쓰기 금지”라는 의미가 아니라, **성능 최적화와 의도 전달** 두 가지 목적이 있습니다.

---
 1. 동작 방식

 (1) **JPA/Hibernate 관점**

- 기본 트랜잭션(`readOnly=false`)에서는 JPA가 **변경 감지(Dirty Checking)**를 수행합니다.
    
    - 엔티티 필드 변경 여부를 추적하기 위해 **스냅샷(snapshot)**을 생성.
        
    - 트랜잭션 종료 시점(`flush()`)에 변경 사항이 있으면 UPDATE SQL 실행.
        
- `readOnly=true`로 설정하면:
    
    - 하이버네이트가 스냅샷 생성을 생략 → 변경 감지 로직 비활성화.
        
    - flush 시점에 쓰기 작업을 하지 않음.
        

➡ 불필요한 메모리 사용과 SQL 생성을 줄임 → 조회 전용 로직에서 성능 최적화 가능.

---
 (2) **JDBC/DB 관점**

- 일부 데이터베이스와 JDBC 드라이버는 `readOnly=true` 트랜잭션에 대해 **DB 차원에서 최적화**를 수행.
    
    - 예: Oracle은 읽기 전용 트랜잭션에 대해 undo 로그 최소화.
        
    - MySQL InnoDB는 큰 최적화는 없지만 의도를 명확히 전달.
        
- 하지만 DB 엔진별로 지원 여부와 최적화 수준은 다름.
    

---
 (3) **Spring 관점**

- Spring이 트랜잭션을 시작할 때 `Connection.setReadOnly(true)`를 호출.
    
- 하위 레벨(JPA, JDBC, MyBatis 등)에 읽기 전용 힌트를 전달.
    

---
 2. 사용 시 이점
 (1) 성능 최적화

- JPA의 Dirty Checking 비활성화로 메모리·CPU 사용량 감소.
    
- flush 과정 생략 → DB I/O 감소.
    

 (2) 의도 명시

- 해당 메서드가 **데이터 조회 전용임을 명확히 표현**.
    
- 나중에 유지보수 시 의도 파악이 쉽고, 실수로 엔티티 변경을 하는 경우 잡아낼 수 있음.
    
 (3) 실수 방지

- 일부 DB에서는 readOnly 트랜잭션에서 쓰기 시도 시 예외 발생 → 의도치 않은 데이터 변경 방지.
    

---
 3. 주의사항

- `readOnly=true`라도 엔티티 값을 변경하면 **자바 객체 값은 바뀝니다**.  
    단지 JPA가 이를 DB에 반영하지 않을 뿐입니다.
    
- DB에서의 동작은 벤더별로 다르므로 “성능 향상 폭”은 환경에 따라 차이 있음.
    
- 읽기와 쓰기가 섞여 있는 메서드에 `readOnly=true`를 붙이면 쓰기 로직이 무시되어 **데이터가 저장되지 않을 수 있음**.
    

---
 4. 결론

> `@Transactional(readOnly = true)`는 **조회 전용 트랜잭션에서 불필요한 변경 감지와 flush를 생략해 성능을 최적화**하고,  
> **코드 의도를 명확히 드러내는** 도구입니다.  
> 특히 조회 전용 API, 리포트 생성, 페이징 처리 같은 경우 성능 이점이 있습니다.

---
##### 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
언제 읽기에도 @Transactional(readOnly = true)가 ‘필요’한가?

1. **일관된 스냅샷이 필요한 읽기**  
    서비스 메서드 안에서 여러 SELECT가 실행된다면, 트랜잭션 경계를 잡아야 **하나의 격리 수준**(예: READ COMMITTED/REPEATABLE READ) 아래서 **일관된 뷰**를 보장할 수 있습니다.  
    트랜잭션이 없으면 각 쿼리가 **서로 다른 자동 커밋 트랜잭션**으로 실행되어, 중간에 데이터가 바뀌면 **non-repeatable read / phantom**이 발생할 수 있습니다.
    
2. **지연 로딩(Lazy Loading)을 사용할 때**  
    `@Transactional` 경계 밖에서는 영속성 컨텍스트가 닫혀 `LazyInitializationException`이 발생하기 쉽습니다.  
    읽기 전용 트랜잭션을 걸면 **세션(영속성 컨텍스트)** 이 메서드 범위에서 열려 있어 안전하게 지연 로딩을 사용할 수 있습니다.
    
3. **반복 조회·캐시·배치 페치 최적화**  
    트랜잭션이 있으면 **1차 캐시**가 유효해 같은 엔티티 재조회 시 DB를 다시 치지 않습니다.  
    또한 JPA/Hibernate의 **batch fetch** 최적화도 한 세션 안에서 이득을 봅니다.
    
4. **의도와 안전성**  
    `readOnly = true`는 하이버네이트의 **변경 감지/flush 최소화**로 오버헤드를 줄이고, 일부 DB에 **읽기 전용 힌트**를 전달합니다.  
    또한 “이 메서드는 쓰지 않는다”는 선언이 되어 **우발적인 업데이트**를 방지합니다.
    
 언제 굳이 없어도 되는가?

- **단일 쿼리로 끝나는 간단한 조회**(특히 **DTO/프로젝션**으로 바로 매핑하고, 지연 로딩이 전혀 없을 때)
    
- 컨트롤러 → 리포지토리 한 번 호출로 결과를 반환하고, 추가적인 컬렉션 탐색이나 연관 접근이 전혀 없는 경우
    

이런 경우 @Transactional(readOnly = true)를 생략해도 기능적으로 문제는 없습니다. 다만 붙여도 **거의 무해하고 의도가 명확**해지는 이점이 있습니다.

 권장 실무 기준

- **서비스 레이어의 조회 메서드에는 기본적으로 `@Transactional(readOnly = true)`**
    
    - 여러 SELECT, 지연 로딩, 캐시/배치 페치 이점, 스냅샷 일관성 확보
        
- **쓰기 메서드에는 `@Transactional`(기본)**
    
- **단일 간단 조회 + DTO 반환**만 하는 메서드는 선택사항 (붙여도 무방)
    
 간단 예시

```java
@Service
public class OrderQueryService {

    // 여러 SELECT와 지연 로딩을 사용할 수 있는 복합 조회
    @Transactional(readOnly = true)
    public OrderDetailView getOrderDetail(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow();
        // 지연 로딩 안전 (same transaction/session)
        List<OrderItem> items = order.getItems();
        // 1차 캐시로 동일 엔티티 재조회 시 DB hit 없음
        Customer customer = order.getCustomer();
        return OrderDetailView.of(order, items, customer);
    }

    // 단일 쿼리로 DTO만 뽑는 경우: 선택적으로 생략 가능
    public SimpleOrderDto getSimple(Long orderId) {
        return orderRepository.findSimpleDtoById(orderId);
    }
}

```

결론

- “읽기니까 트랜잭션 필요 없다”는 **절반만 맞는 말**입니다.
    
- **여러 조회를 하나의 일관된 시점으로 묶고**, **지연 로딩/캐시/배치 페치 최적화**를 활용하려면 `@Transactional(readOnly = true)`가 **실질적 도움**이 됩니다.
    
- 매우 단순한 단일 조회 + DTO 반환에는 필수가 아니지만, **붙이는 쪽이 의도 명확성과 안전성 면에서 더 낫다**가 일반적 실무 기준입니다.

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?
##### 설명
Java에서 **Annotation**은

> 코드에 **메타데이터(metadata)**를 부여해서, **컴파일러나 런타임에 추가적인 정보나 동작을 제공**하는 기능  
> 입니다.

즉, **“이 코드에 이런 의미/설정을 부여한다”** 라고 표시하는 주석과 비슷하지만,  
단순 주석과 달리 **프로그램이 실행되거나 컴파일될 때 실제로 활용**될 수 있습니다.

---
1. Annotation의 주요 역할
 (1) **컴파일러 지시**

- 컴파일러에게 경고를 무시하게 하거나, 특정 검사를 하도록 지시.
    
- 예:
    
    java
    
    복사편집
    
    `@Override  // 부모 메서드를 정확히 오버라이드하는지 컴파일러가 검사 public String toString() { ... }  @SuppressWarnings("unchecked")  // 경고 무시`
    

---
(2) **코드 분석 도구에 정보 제공**

- IDE, 빌드 도구, 린트(lint) 도구가 코드 분석 시 활용.
    
- 예: `@Deprecated` → 해당 API가 더 이상 사용되지 않음을 알림.
    

---
(3) **런타임 동작 변경**

- 리플렉션(Reflection)으로 애노테이션을 읽어서 실행 로직에 반영.
    
- 프레임워크(Spring, JPA 등)에서 광범위하게 사용:
    
    java
    
    복사편집
    
    `@Controller  // 스프링이 이 클래스를 웹 컨트롤러로 인식 @Transactional // 메서드 실행 시 트랜잭션 시작/커밋/롤백 관리`
    

---
(4) **코드 생성·변환**

- 애노테이션 프로세서(Annotation Processor)를 사용해 컴파일 시 코드 생성/수정.
    
- 예: Lombok의 `@Getter`, `@Builder` → getter 메서드나 빌더 코드 자동 생성.
    

---
2. Annotation의 구성 요소
선언 방법

java

복사편집

`public @interface MyAnnotation {     String value();      // 필수 속성     int count() default 1; // 기본값 속성 }`

메타 애노테이션 (Meta-Annotation)

애노테이션 자체의 동작을 정의하는 애노테이션:

- `@Target` → 적용 가능한 위치 지정 (클래스, 메서드, 필드 등)
    
- `@Retention` → 유지 범위 지정
    
    - `SOURCE` (컴파일 후 버려짐)
        
    - `CLASS` (클래스 파일에 남지만 런타임에는 사용 불가)
        
    - `RUNTIME` (런타임에도 유지, 리플렉션 가능)
        
- `@Documented` → Javadoc에 포함
    
- `@Inherited` → 하위 클래스에 상속 가능
    

---
 3. 예시
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {
}

public class MyService {

    @LogExecutionTime
    public void process() {
        // 실행 시간 측정 대상
    }
}

```

- 프레임워크나 AOP 설정에서 `@LogExecutionTime`이 붙은 메서드를 찾아 실행 시간을 로깅할 수 있음.
    

---
4. 한 줄 정리

> **Java의 Annotation은 코드에 의미와 설정을 부여하는 메타데이터**로,  
> 컴파일러, 빌드 도구, 프레임워크가 이 정보를 읽어 **검사·코드 생성·실행 동작 변경**을 할 수 있게 해 줍니다.

##### 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?
좋은 질문입니다.  
겉으로 보면 Java 애노테이션은 **그냥 붙여 놓는 “메모” 정도**처럼 보이는데,  
Spring 같은 프레임워크에서는 `@Controller`, `@Transactional`, `@Autowired` 같은 애노테이션이  
**동작 자체를 바꾸는 핵심 기능**이 되죠.

이게 가능한 이유는, **Spring이 애노테이션을 적극적으로 “읽고” 동작을 연결하는 구조를 만들었기 때문**입니다.  
즉, 애노테이션 자체가 기능을 하는 게 아니라,  
**프레임워크가 애노테이션을 해석해서 동작을 붙이는 것**입니다.

---
 1. 애노테이션 자체는 “메타데이터”일 뿐

Java 애노테이션은 실행 로직이 없습니다.  
그저 **"이 코드에 이런 의미가 있다"**를 붙여놓는 표식일 뿐입니다.  
예:

java

복사편집

`@Controller public class MyController { ... }`

→ `@Controller` 자체는 아무 일도 안 합니다.

---
 2. Spring이 기능을 부여하는 방식
(1) **런타임 리플렉션(Reflection)**

- Spring이 애플리케이션 시작 시 **클래스와 메서드를 스캔**하면서,  
    특정 애노테이션이 붙은 대상에 특별한 처리를 함.
    
- 예:
    
    - `@Controller` → Spring MVC의 RequestMappingHandlerMapping이 이 클래스를 컨트롤러로 등록.
        
    - `@Autowired` → 의존성 주입 단계에서 해당 필드/생성자에 Bean 주입.
        
```java
for (Class<?> clazz : scannedClasses) {
    if (clazz.isAnnotationPresent(Controller.class)) {
        registerAsController(clazz);
    }
}

```
---

(2) **빈 후처리기(BeanPostProcessor)**

- Spring의 **BeanPostProcessor** 인터페이스 구현체들이 Bean 생성 전/후에 애노테이션을 해석.
    
- 예:
    
    - `@Autowired` → `AutowiredAnnotationBeanPostProcessor`
        
    - `@Transactional` → `TransactionalAnnotationBeanPostProcessor` + 프록시 생성
        

---
 (3) **AOP(Aspect-Oriented Programming)**

- `@Transactional`, `@Cacheable` 같은 애노테이션은 프록시 객체를 생성해서  
    **메서드 호출 전/후에 부가 로직**을 자동 실행.
    
- 예:
    
    1. `@Transactional`이 붙은 메서드 호출
        
    2. 프록시가 가로채서 트랜잭션 시작
        
    3. 실제 메서드 실행
        
    4. 성공 시 커밋, 실패 시 롤백
        

---

(4) **애노테이션 기반 설정(Annotation-Driven Configuration)**

- XML 대신 애노테이션으로 Bean 정의, 스캔, 의존성 주입, 설정 가능.
    
- 예:
    
    java
    
    복사편집
    
    `@Configuration @ComponentScan(basePackages = "com.example") public class AppConfig { }`
    

---
 3. 요약하면

- **애노테이션은 그 자체로 기능을 수행하지 않는다.**
    
- Spring이 **시작 시 애노테이션을 스캔하고**,  
    **BeanPostProcessor + Reflection + AOP**로  
    → 애노테이션이 붙은 곳에 **특정 동작**을 자동으로 주입하는 구조를 만들었기 때문에  
    → 마치 애노테이션이 “기능”을 하는 것처럼 보인다.
    

---
4. 비유

- 애노테이션 = “여기 중요한 표시 있음”이라는 포스트잇
    
- Spring = 포스트잇을 읽고 “아, 여기는 트랜잭션 붙여야지”, “여기는 HTTP 요청 매핑해야지” 하고 동작을 구현하는 사람
##### Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?
`@Data`는 Lombok에서 한 번에 **`@Getter` + `@Setter` + `@RequiredArgsConstructor` + `@ToString` + `@EqualsAndHashCode`**를 만들어주는 “올인원” 애너테이션입니다.  
편리하지만, **실무에서는 잘 안 쓰이거나 조심해서 쓰는 경향**이 있습니다.

이유를 하나씩 보면 다음과 같습니다.

---
 1. **불필요한 Setter 생성 → 불변성(immutability) 깨짐**

- `@Data`는 **모든 필드에 public Setter**를 만들어줍니다.
    
- 도메인 객체(Entity, VO 등)는 **한 번 생성 후 변경 불가능**해야 하는 경우가 많습니다.
    
- Setter를 남발하면 객체 상태가 아무 데서나 바뀌어 **버그 추적이 어려워지고, 동시성 문제**가 생길 수 있습니다.
    

`@Data public class User {     private String name; }`

→ 나중에 아무 곳에서나 `user.setName("...")` 가능  
→ 객체의 무결성과 의도를 해칠 위험

---
 2. **Equals/HashCode 자동 생성 문제**

- `@Data`는 모든 필드를 기반으로 `equals()`와 `hashCode()`를 생성합니다.
    
- 컬렉션, 연관 객체(특히 JPA Entity의 양방향 연관관계)가 포함되면 **무한 루프**나 **성능 저하** 가능.
    
- JPA Entity에서는 ID 값이 영속화 전후로 바뀌므로, equals/hashCode가 잘못 동작해 **HashSet/HashMap 문제**가 발생할 수 있음.
    

---
 3. **의도치 않은 ToString 위험**

- 모든 필드를 포함한 `toString()` 생성 → 민감한 데이터(비밀번호 등)가 로그에 노출될 수 있음.
    
- 연관관계가 순환 구조일 경우 `StackOverflowError` 발생.
    

---
 4. **너무 많은 책임을 한 번에 부여**

- `@Data`는 Getter/Setter/ToString/Equals/HashCode/Constructor를 **모두 생성**하므로,  
    필요한 것만 선택적으로 쓰는 제어가 어렵습니다.
    
- 명시적으로 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`를 필요한 곳에만 붙이는 것이 **더 안전하고 유지보수에 유리**.
    

---
 5. **특히 JPA Entity와 궁합이 좋지 않음**

- JPA에서는 다음 이유로 `@Data`가 권장되지 않습니다:
    
    - 무분별한 Setter → 무결성 약화
        
    - equals/hashCode/toString 자동 생성 → 지연 로딩 프록시 접근 시 문제 발생
        
    - 필드 변경 시 flush 타이밍에서 의도치 않은 update 발생 가능
        

---
 6. **실무에서 권장되는 대안**

- **DTO**: `@Data` 사용 가능 (순수 데이터 전달 객체이고 불변성 중요하지 않을 때)
    
- **Entity/Domain 객체**:
    
    - `@Getter`만 사용 + 생성자를 통한 값 설정
        
    - 불변 객체라면 `@Value` (Lombok)
        
    - 필요한 경우에만 Setter 메서드 직접 작성 (비즈니스 의미 부여)
        

---

✅ **정리**

> `@Data`는 편리하지만, **모든 필드에 Getter/Setter를 열어버리고, equals/hashCode/toString을 무분별하게 생성**하는 위험이 있습니다.  
> 특히 **도메인 객체나 JPA Entity**에서는 객체 불변성과 무결성을 해치기 쉬워서 실무에서는 잘 사용하지 않습니다.  
> 대신 필요한 Lombok 애너테이션을 **개별적으로 조합**하는 방식이 안전합니다.

---

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?
##### 설명
Tomcat은 한마디로 **Java 기반 웹 애플리케이션을 실행시키기 위한 서버(서블릿 컨테이너)**입니다.  
정확히는 **HTTP 서버 + Servlet/JSP 컨테이너** 역할을 하는 오픈소스 소프트웨어입니다.

---
 1. Tomcat의 핵심 역할

 (1) **Servlet 컨테이너**

- Java EE(현 Jakarta EE) 스펙 중 **Servlet**과 **JSP**를 구현한 서버입니다.
    
- Servlet 클래스의 생명주기 관리  
    → 생성, 초기화(`init()`), 요청 처리(`service()`), 소멸(`destroy()`)
    
- 클라이언트 HTTP 요청을 **Servlet 객체에 전달**하고, 응답을 만들어 클라이언트에 반환.
    

---
 (2) **HTTP 서버 기능**

- HTTP 프로토콜을 이해하고, 소켓 통신을 통해 요청/응답 처리.
    
- Apache HTTP Server 같은 별도 웹 서버 없이도 정적 리소스(HTML, CSS, JS, 이미지) 제공 가능.
    

---
 (3) **웹 애플리케이션 관리**

- `webapps` 폴더에 `.war` 파일이나 디렉토리 형태로 배포된 웹 애플리케이션을 로드/관리.
    
- 애플리케이션별로 **서블릿, 필터, 리스너, JSP** 등을 실행 환경에 맞게 초기화.
    

---
 (4) **서블릿 매핑과 요청 분배**

- web.xml, 애노테이션(`@WebServlet`) 설정을 기반으로 요청 URL → 해당 서블릿 매핑.
    
- 예:
    
    bash
    
    복사편집
    
    `/user → UserServlet /product → ProductServlet`
    

---

 2. Tomcat 요청 처리 흐름
```
[클라이언트 브라우저]
        ↓ (HTTP 요청)
   [Tomcat HTTP Connector] ← (8080 포트 대기)
        ↓
   [Servlet Container]
        ↓  (URL 매핑)
  해당 Servlet 실행 → doGet()/doPost()
        ↓
   [Servlet Container]
        ↓
   [HTTP Connector]
        ↓
[클라이언트 브라우저로 HTTP 응답 전송]

```
 3. Tomcat과 다른 서버의 관계

- **Tomcat** = Servlet 컨테이너 + 기본 HTTP 서버
    
- **Apache HTTP Server, Nginx** = 정적 리소스 제공 + 리버스 프록시 역할 가능
    
- Spring Boot 내장 Tomcat → Spring MVC 앱을 배포 없이 `main()` 실행만으로 구동 가능.
    

---
 4. 한 줄로 정리

> **Tomcat은 Java 웹 애플리케이션을 실행시키기 위해 HTTP 요청을 받아 서블릿/JSP로 처리하고, 응답을 반환하는 서버(서블릿 컨테이너)입니다.**
##### 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?
네, Netty는 꽤 유명한 **비동기 이벤트 기반 네트워크 애플리케이션 프레임워크**입니다.  
간단히 말해, **TCP/UDP 같은 네트워크 프로토콜 위에서 고성능·비동기 서버를 쉽게 만들 수 있게 해주는 Java 라이브러리**입니다.

---
 1. Netty란 무엇인가

- Java NIO(Non-blocking I/O) 기반으로 만든 네트워크 통신 프레임워크.
    
- TCP/UDP, HTTP, WebSocket 등 다양한 프로토콜을 처리할 수 있음.
    
- 멀티스레드, 이벤트 루프 기반의 설계로 **고성능, 고확장성** 네트워크 서버·클라이언트 구현 가능.
    
- 예: 채팅 서버, 게임 서버, 스트리밍 서버, 메시지 브로커(Kafka의 내부 통신도 Netty 기반) 등.
    

---
 2. 왜 Netty를 사용하는가?

 (1) **Java NIO의 복잡성을 추상화**

- 순수 Java NIO API는 Selector, Channel, Buffer를 직접 관리해야 하고 코드가 복잡.
    
- Netty는 이를 추상화해 **이벤트 기반 파이프라인** 형태로 쉽게 작성 가능.
    

---

 (2) **비동기·논블로킹 처리로 높은 성능**

- 동기/블로킹 방식은 요청 하나당 스레드를 점유 → 동시 연결 수가 많아지면 스레드 부하.
    
- Netty는 이벤트 루프(EventLoop) 모델을 사용해 소수의 스레드로 수많은 연결을 동시에 처리.
    
- → **적은 리소스로 높은 동시성** 지원.
    

---

 (3) **다양한 프로토콜 지원과 확장성**

- HTTP, WebSocket, FTP, MQTT 등 여러 프로토콜 코덱(Codec) 제공.
    
- 커스텀 프로토콜도 쉽게 구현 가능.
    

---

 (4) **안정성과 실무 검증**

- Hadoop, Elasticsearch, gRPC, Apache Cassandra, Kafka, Spark 같은 대형 프로젝트에서도 사용.
    
- 검증된 성능과 안정성.
    

---
 3. 동작 구조 예시

Netty는 **ChannelPipeline**이라는 구조로 동작합니다.

복사편집

`클라이언트 요청  → ChannelInboundHandler 1  → ChannelInboundHandler 2  → 비즈니스 로직 처리  → ChannelOutboundHandler 1  → 응답 전송`

- 각 Handler는 이벤트(데이터 수신, 연결 생성, 예외 발생 등)에 반응해 동작.
    
- 파이프라인 방식이라 유지보수·확장이 용이.
    

---
 4. Tomcat과 Netty의 차이

|구분|Tomcat|Netty|
|---|---|---|
|주 용도|서블릿/JSP 기반 웹 애플리케이션 실행|네트워크 애플리케이션(HTTP 포함) 전반|
|I/O 모델|(기본) 스레드 풀 기반 블로킹 I/O + 일부 NIO|완전한 비동기 논블로킹 I/O|
|특징|Servlet 스펙 준수, Spring MVC와 바로 호환|HTTP뿐 아니라 TCP/UDP/WebSocket 등 자유롭게|
|사용 예|Spring MVC, JSP 기반 서버|게임 서버, 채팅 서버, gRPC, IoT, 메시지 브로커|

---
5. 한 줄 요약

> **Netty는 Java NIO 기반의 고성능, 비동기 네트워크 프레임워크**로,  
> 수많은 동시 연결을 효율적으로 처리해야 하는 서버(HTTP, TCP, WebSocket 등)에 적합합니다.
