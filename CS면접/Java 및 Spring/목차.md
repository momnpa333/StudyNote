### 1. JVM이 정확히 무엇이고, 어떤 기능을 하는지 설명해 주세요.
##### 설명
JVM(Java Virtual Machine)은 **자바 프로그램이 실행되는 가상화된 실행 환경**으로, 자바뿐만 아니라 Kotlin, Scala 등 JVM 기반 언어로 작성된 프로그램이 동작할 수 있도록 설계된 **추상 컴퓨터(virtual machine)**입니다.

**JVM의 주요 역할**

1. **바이트코드 실행**
    
    - 자바 소스코드(`.java`)는 컴파일러(`javac`)를 통해 **바이트코드(`.class`)**로 변환됩니다.
        
    - JVM은 이 바이트코드를 해석(인터프리트)하거나 **JIT(Just-In-Time) 컴파일러**를 통해 네이티브 머신 코드로 변환하여 실행합니다.
        
2. **운영체제 독립성 제공**
    
    - 자바의 **“Write Once, Run Anywhere”** 철학을 가능하게 하는 핵심 요소입니다.
        
    - 한 번 컴파일된 바이트코드는 JVM이 설치된 어떤 OS나 하드웨어 환경에서도 동일하게 실행됩니다.
        
3. **메모리 관리 (Garbage Collection)**
    
    - JVM은 프로그램에서 사용되는 메모리를 **힙(Heap)**과 **스택(Stack)** 영역으로 관리합니다.
        
    - 사용이 끝난 객체를 자동으로 회수하는 **Garbage Collector(GC)**를 내장하고 있어 메모리 누수를 줄입니다.
        
4. **보안 및 예외 처리**
    
    - 바이트코드 검증(Bytecode Verifier)을 통해 악성 코드 실행을 방지합니다.
        
    - 예외(Exception) 처리 메커니즘을 제공하여 안정적인 실행을 지원합니다.
        
5. **런타임 환경 제공**
    
    - 클래스 로딩(Class Loader), 실행 엔진(Execution Engine), 네이티브 인터페이스(JNI) 등을 통해 애플리케이션 실행에 필요한 런타임 환경을 제공합니다.
        

---
**JVM의 구조**

1. **클래스 로더(Class Loader)**
    
    - `.class` 파일을 메모리로 로드하고, 링크(Linking)와 초기화를 수행합니다.
        
2. **런타임 데이터 영역(Runtime Data Areas)**
    
    - **메서드 영역(Method Area):** 클래스 메타데이터, 정적 변수, 상수 풀 저장.
        
    - **힙(Heap):** 객체가 저장되는 영역, GC의 관리 대상.
        
    - **스택(Stack):** 메서드 호출 시 생성되는 프레임을 저장.
        
    - **PC 레지스터:** 현재 실행 중인 명령어의 주소 저장.
        
    - **네이티브 메서드 스택:** JNI 호출 시 사용.
        
3. **실행 엔진(Execution Engine)**
    
    - **인터프리터:** 바이트코드를 한 줄씩 해석 실행.
        
    - **JIT 컴파일러:** 자주 실행되는 코드를 네이티브 코드로 변환해 성능 향상.
        
    - **Garbage Collector:** 메모리 관리 자동화.
        

---
**정리**

JVM은 **자바 프로그램을 하드웨어와 OS에 독립적으로 실행할 수 있게 하는 가상 컴퓨터**이자, **메모리 관리와 보안을 책임지는 런타임 환경**입니다.  
만약 JVM이 없다면, 자바 프로그램은 현재처럼 다양한 플랫폼에서 동일하게 실행될 수 없습니다.
##### 그럼, 자바 말고 다른 언어는 JVM 위에 올릴 수 없나요?
✅ JVM 위에서 실행 가능한 다른 언어들

|언어|특징|
|---|---|
|**Kotlin**|JetBrains에서 개발, 자바와 100% 상호운용 가능. Android 공식 언어.|
|**Scala**|함수형 + 객체지향, 고급 언어 기능. Spark의 주요 언어.|
|**Groovy**|자바 문법 기반의 동적 스크립트 언어, Gradle에 사용됨.|
|**Clojure**|함수형, Lisp 계열 언어. 불변성과 병렬처리 강조.|
|**JRuby**|Ruby를 JVM에서 실행할 수 있게 만든 구현체.|
|**Jython**|Python 2.x 문법을 JVM 위에서 실행 가능. (현재는 거의 사용 안 됨)|
|**Ceylon, Fantom, Frege, Xtend 등**|JVM 기반으로 개발된 다양한 실험적 언어들|

---

🧠 왜 다른 언어들도 JVM 위에서 실행 가능한가요?

JVM은 자바에 특화된 것이 아니라 **“바이트코드”라는 중간 표현을 실행**하는 구조입니다.  
즉, 자바가 아닌 언어도 **“JVM 바이트코드로 컴파일”만 하면** JVM에서 실행할 수 있습니다.

🧩 장점

- **운영체제 독립성**: 어떤 언어든 JVM 위에서 돌아가면 플랫폼 독립성 확보.
    
- **기존 Java 생태계 활용**: Java 라이브러리, 프레임워크 사용 가능.
    
- **성능**: JVM의 JIT 컴파일러, GC 등을 그대로 활용.
    

⚠️ 단점

- **자바 중심 최적화**: JVM은 기본적으로 자바 스타일 코드에 최적화됨.
    
- **언어 특성 제한**: 언어 고유 기능을 JVM이 지원하지 않을 수 있음.
    
- **바이트코드 제약**: 일부 언어 표현은 JVM 바이트코드로 변환하기 까다로움.
    
✅ 결론

> JVM은 **자바 전용이 아닙니다.**  
> **“JVM 바이트코드로 컴파일될 수 있는 언어라면 모두 실행 가능합니다.”**

자바 외에도 Kotlin, Scala, Groovy처럼 **JVM 생태계의 장점을 공유하며 성장한 언어들**이 존재합니다.
##### 반대로 JVM 계열 언어를 일반적으로 컴파일해서 사용할 순 없나요?
JVM 계열 언어(예: Java, Kotlin, Scala)는 기본적으로 **JVM 바이트코드(`.class`)를 생성**해 JVM 위에서 실행되도록 설계되었기 때문에 **“일반적인 기계어 바이너리(네이티브 코드)”로 직접 컴파일해 실행**하는 것은 표준 방식이 아닙니다.  
그러나, **특수한 도구나 컴파일러를 사용하면 JVM 없이도 실행할 수 있는 네이티브 바이너리를 만들 수 있습니다.**

---
 **1. JVM 계열 언어를 네이티브로 컴파일할 수 있는 방법**

 **(1) GraalVM Native Image**

- **Java, Kotlin, Scala** 등의 JVM 언어를 **Ahead-Of-Time(AOT)** 컴파일하여 **JVM 없이 실행 가능한 네이티브 실행 파일**을 생성합니다.
    
- **장점:** 시작 속도가 매우 빠르고 메모리 사용량이 줄어듭니다.
    
- **단점:** 빌드 속도가 느리고 리플렉션이나 동적 로딩 지원이 제한될 수 있습니다.
    

---
 **(2) Kotlin/Native**

- Kotlin은 JVM뿐만 아니라 **LLVM 백엔드**를 통해 **iOS, Windows, Linux** 등에서 동작하는 **네이티브 코드로 변환**할 수 있습니다.
    
- 예: 안드로이드 앱에서는 JVM을 쓰지만, iOS 앱에서는 Kotlin/Native로 기계어 코드 생성.
    

 **(3) Excelsior JET (단종)**

- 자바 바이트코드를 **기계어로 직접 컴파일해 실행 파일**로 만드는 상용 솔루션이 있었으나 현재는 개발 중단.
    

---
 **2. 왜 기본적으로 JVM에서 실행되도록 설계되었나?**

1. **운영체제/하드웨어 독립성**
    
    - 한 번 컴파일된 `.class` 파일은 어떤 OS에서든 JVM만 있으면 실행 가능 (**WORA – Write Once, Run Anywhere**).
        
2. **JIT 컴파일러 최적화**
    
    - JVM은 런타임에 자주 실행되는 코드만 **Just-In-Time(동적 최적화)**으로 네이티브 코드로 변환하여 성능을 높임.
        
3. **풍부한 생태계**
    
    - Java 라이브러리, Spring, JPA 등 대부분의 프레임워크가 **JVM 환경**을 전제로 동작.
        

---
 **3. 정리**

- **JVM 언어를 네이티브 코드로 변환하는 것은 가능하지만, 일반적인 접근은 아님.**
    
- **GraalVM Native Image** 또는 **Kotlin/Native** 같은 도구를 사용해야 하며,  
    이런 방식은 **“시작 속도 최적화”나 “JVM 없는 환경(iOS, 서버리스)”에서만 주로 활용**됩니다.
    

---
##### VM을 사용함으로써 얻을 수 있는 장점과 단점에 대해 설명해 주세요.
**가상머신(Virtual Machine, VM)**을 사용하면 **하드웨어나 운영체제 위에 추상화된 실행 환경**을 제공하여, 프로그램을 실제 물리 하드웨어 대신 **가상의 환경에서 실행**할 수 있습니다.  
대표적으로 Java의 **JVM**이나 시스템 가상화 기술인 **VMware, VirtualBox** 등이 있습니다.

VM 사용은 **높은 이식성, 격리성**을 제공하지만, **성능 저하와 관리 복잡성** 같은 단점도 있습니다.

---
 **1. VM을 사용함으로써 얻는 장점**

 **(1) 플랫폼 독립성 (이식성)**

- 애플리케이션은 VM 위에서 실행되므로 **하드웨어나 OS에 종속되지 않음**.
    
- 예: Java는 JVM만 설치되어 있으면 Windows, Linux, macOS에서 동일한 `.class` 파일을 실행할 수 있습니다.
    
 **(2) 보안 및 격리성**

- VM은 호스트 OS와 **격리된 실행 환경**을 제공하므로, 애플리케이션 오류나 악성 코드가 호스트 시스템에 직접 영향을 주지 않습니다.
    

 **(3) 관리 용이성**

- VM 이미지를 생성하면 **환경을 그대로 복제, 배포, 백업**할 수 있습니다.
    
- 운영체제 환경을 테스트할 때 매우 유용합니다.
    

 **(4) 호환성 확보**

- 오래된 소프트웨어를 새로운 OS에서 실행하거나, 특정 OS 환경이 필요한 소프트웨어를 VM 위에서 구동할 수 있습니다.
    

 **(5) 리소스 효율적 사용**

- 하이퍼바이저 기반 VM에서는 **하나의 물리 서버 위에서 여러 VM이 동작**해 자원을 효율적으로 사용 가능.
    
- 클라우드 서비스(AWS EC2, GCP Compute Engine 등)의 기반 기술이 바로 VM.
    

---

 **2. VM을 사용할 때의 단점**

 **(1) 성능 저하**

- VM은 **하드웨어를 직접 사용하는 것이 아니라 소프트웨어 계층(가상화 계층)을 거쳐 접근**하므로, 네이티브 실행보다 느립니다.
    
- 예: JVM도 바이트코드를 JIT 컴파일로 변환해야 하므로 네이티브 언어(C/C++)보다 초기 성능이 떨어질 수 있습니다.
    
 **(2) 높은 메모리/리소스 사용량**

- VM은 **게스트 OS + 애플리케이션**을 모두 실행해야 하므로, 호스트 OS 대비 메모리와 CPU 사용량이 큽니다.
    

 **(3) 관리 복잡성**

- VM이 많아지면 OS 업데이트, 보안 패치, 이미지 관리가 복잡해집니다.
    

 **(4) 딜레이(시작 속도)**

- VM 부팅은 물리 서버나 단일 애플리케이션 실행보다 시간이 오래 걸립니다.
    
- JVM도 애플리케이션 실행 시 **클래스 로딩과 바이트코드 해석 과정** 때문에 초기 구동이 느릴 수 있습니다.
    

 **(5) 디버깅 어려움**

- VM 계층 때문에 **호스트와 VM 간의 문제 원인 분석이 어렵거나** 성능 병목을 추적하기 힘들 수 있습니다.
    

---

 **3. VM vs 네이티브 실행의 트레이드오프**

- **VM 장점:** 이식성, 보안, 격리성, 유지보수 용이성.
    
- **VM 단점:** 네이티브보다 **성능(속도, 메모리 효율)**이 떨어질 수 있음.
    

---
 **4. 정리**

> **VM은 "유연성과 이식성"을 제공하지만, "성능과 리소스 사용량"에서 네이티브 실행보다 불리합니다.**  
> 최근에는 성능 저하를 최소화하기 위해 **JIT 컴파일러, GraalVM, 컨테이너(Docker)** 등 VM의 단점을 보완하는 기술들이 함께 사용됩니다.
##### JVM과 내부에서 실행되고 있는 프로그램은 부모 프로세스 - 자식 프로세스 관계를 갖고 있다고 봐도 무방한가요?
정확히 말하면, **JVM과 그 내부에서 실행되는 자바 프로그램은 "부모-자식 프로세스" 관계로 볼 수 없습니다.**  
그 이유는 **JVM 자체가 하나의 프로세스**이며, 자바 애플리케이션(클래스, 메서드 등)은 JVM 프로세스 안에서 **스레드로 동작**하기 때문입니다.

---
 **1. JVM은 하나의 프로세스다**

- 자바 애플리케이션을 실행하면 OS는 `java` 실행 파일을 로드하고, 이를 **하나의 독립된 프로세스**로 실행합니다.
    
- 이후 JVM 프로세스는 **클래스 로딩, 바이트코드 실행(인터프리팅/JIT 컴파일), GC, 스레드 관리** 등의 작업을 수행합니다.
    
- **자바 애플리케이션의 main 메서드 또한 JVM 프로세스 내부의 "스레드(메인 스레드)"로 동작합니다.**
    

---
 **2. 부모-자식 프로세스 관계가 아닌 이유**

- 부모-자식 프로세스 관계는 **OS 레벨에서 fork()나 exec()** 같은 시스템 콜로 새로운 프로세스를 생성할 때 형성됩니다.
    
- JVM에서 실행되는 자바 프로그램은 **별도의 OS 프로세스가 아니라, JVM 프로세스 내부의 실행 로직**에 불과합니다.
    
- 따라서 JVM과 자바 프로그램은 **하나의 프로세스 내에서 동작하는 "런타임 환경과 애플리케이션 코드"** 관계입니다.
    

---
 **3. 예외적 상황**

- 자바 애플리케이션이 `ProcessBuilder`나 `Runtime.exec()`을 통해 **외부 명령어를 실행하면**, 해당 외부 프로그램은 **JVM의 자식 프로세스**로 생성됩니다.
    
    java
    
    복사편집
    
    `Process process = Runtime.getRuntime().exec("ls -al");`
    
    이 경우 `ls` 명령은 JVM의 자식 프로세스가 맞습니다.
    

---
 **4. 올바른 표현**

- **JVM = 프로세스**
    
- **자바 애플리케이션(main, Thread 등) = JVM 프로세스 내부의 스레드**
    
- 부모-자식 프로세스 관계는 JVM과 OS 외부 프로그램 간에만 발생할 수 있습니다.
    

---
 **5. 정리**

> **JVM과 내부에서 실행되는 자바 프로그램은 프로세스-프로세스 관계가 아니라, 프로세스(JVM)-스레드(자바 애플리케이션) 관계입니다.**  
> 다만, 자바 프로그램이 외부 명령을 실행한다면 그 외부 명령은 JVM의 자식 프로세스가 됩니다.

### 2. final 키워드를 사용하면, 어떤 이점이 있나요?
##### 설명:
`final` 키워드는 **자바에서 불변성(immutability) 또는 변경 불가능성을 보장하는 데 사용**됩니다. 상황에 따라 클래스, 메서드, 변수에 붙을 수 있으며, 각각 다른 의미와 장점이 있습니다.

---

**1. `final`의 사용 대상과 의미**

 **(1) 변수에 사용**

- **의미:** 변수의 값을 한 번만 할당할 수 있도록 제한합니다.
    
    - **기본 타입:** 값 자체가 변경 불가.
        
    - **참조 타입:** 객체의 참조 주소가 변경 불가(하지만 객체 내부 상태는 변경될 수 있음).
**(2) 메서드에 사용**

- **의미:** 메서드를 오버라이드(override)할 수 없습니다.
    
- **예시:**
    
```java
class Parent {
    public final void show() {
        System.out.println("Can't override me");
    }
}
class Child extends Parent {
    // @Override
    // public void show() { } // 컴파일 에러

```
 **(3) 클래스에 사용**

- **의미:** 상속할 수 없는 클래스가 됩니다.
    
- **예시:**  
    `java.lang.String`, `java.lang.Math` 클래스는 `final`로 선언되어 상속 불가.
    
 **2. `final` 키워드의 장점**
 **(1) 코드 안정성 확보**

- 변수 값을 실수로 변경하거나 상속/오버라이딩으로 인한 예기치 못한 동작을 방지할 수 있습니다.
    
**(2) 불변 객체(Immutable Object) 구현**

- `final`을 멤버 변수에 적용하고 setter를 제거하면 **스레드 안전(Thread-Safety)** 한 객체를 만들 수 있습니다.
    
- 예: `String` 클래스가 `final`이기 때문에 불변성을 보장하고 멀티스레드 환경에서 안전합니다.
    
**(3) 성능 최적화 (JVM 최적화 힌트)**

- `final` 메서드는 오버라이드가 불가능하므로, **JVM JIT 컴파일러가 인라이닝(inlining)** 최적화를 쉽게 적용할 수 있습니다.
    
- 상속 관계에서 메서드 호출 시 발생하는 **동적 디스패치 비용**을 줄일 수 있습니다.
    
 **(4) 설계 의도 명확화**

- 특정 클래스나 메서드가 확장되거나 변경되지 않기를 원할 때 `final`을 명시적으로 사용하면, 코드의 의도를 분명히 할 수 있습니다.
    

---
3. `final`의 한계**

- 불필요하게 `final`을 남발하면 테스트나 확장성이 떨어질 수 있습니다.  
    (예: 모든 메서드를 `final`로 만들면 상속 기반 구조에 제약 발생)
    
- 참조 타입의 `final`은 객체 내부 상태까지 불변하게 만들지는 않기 때문에, **진정한 불변 객체를 위해서는 별도 설계(Immutable Pattern)** 가 필요합니다.
    

 **정리**

> `final`은 **“변경 불가능성”을 보장하여 안정성과 최적화를 돕는 키워드**입니다.  
> 특히 불변 객체 설계와 성능 최적화에서 중요한 역할을 하며, 코드의 의도를 명확히 전달할 수 있습니다.
##### 그렇다면 컴파일 과정에서, final 키워드는 다르게 취급되나요?
네, **`final` 키워드는 컴파일 과정에서 일반 변수나 메서드와 다르게 취급됩니다.**  
컴파일러와 JVM은 `final`이 붙은 요소가 **절대 변하지 않는다는 사실을 알고 최적화**할 수 있기 때문입니다.

---
**1. `final` 변수의 컴파일 과정**

- **`final` 상수(`static final`)는 컴파일 타임 상수로 취급**됩니다.
```java
public class Test {
    public static final int CONST = 10;
}

    
```
        
    다른 클래스에서 `Test.CONST`를 참조하면, **컴파일 시 값 `10`으로 대체(inline)** 됩니다.
        
- **`final` 지역 변수나 필드도 컴파일러가 “절대 재할당 불가”라는 사실을 알기 때문에 상수 취급**하며, 인라이닝이나 값 추론(Constant Folding) 같은 최적화가 가능합니다.
    

---
**2. `final` 메서드의 컴파일 과정**

- 메서드에 `final`이 붙으면 **JVM은 동적 디스패치(virtual method table lookup)를 거치지 않고 직접 호출**할 수 있습니다.
    
- 보통 오버라이드 가능한 메서드는 실행 시점에 **가상 메서드 테이블(V-Table)** 을 통해 어떤 구현을 호출할지 결정합니다.
        
 - 하지만 `final` 메서드는 **오버라이드가 불가능하므로 호출 대상이 컴파일 시점에 확정**, 호출 비용을 줄일 수 있습니다.
        
  - JIT 컴파일러가 `final` 메서드를 인라인으로 변환하기가 훨씬 수월합니다.
        

---
**3. `final` 클래스의 컴파일 과정**

- 클래스가 `final`이면 상속이 불가능하기 때문에, **JVM이 메서드 호출 시 “다형성 검사”를 생략**할 수 있습니다.
    
- 예를 들어, `String`은 `final`이기 때문에 `"abc".substring(1)` 호출 시 **항상 `String`의 `substring()` 메서드를 직접 실행**하도록 최적화할 수 있습니다.
    

---
 **4. JIT 컴파일러 관점에서의 최적화**

- 런타임 시 JIT(Just-In-Time) 컴파일러는 `final` 키워드를 확인하고:
    
    - **상수 값 인라이닝** (예: `final int x = 10;` → 직접 10으로 대체)
        
    - **메서드 인라이닝** (함수 호출을 제거하고 코드 삽입)
        
    - **Dead Code 제거** (변하지 않는 값 기반의 코드 최적화)  
        를 적용할 수 있습니다.
        

---
 **정리**

- 컴파일러는 `final` 키워드를 통해 **“변하지 않음”을 보장받아 더 강력한 최적화를 수행**합니다.
    
- 특히 `static final` 상수는 **컴파일 타임에 값이 확정**되어 다른 클래스에서 **직접 값이 삽입(inline)**됩니다.
    
- `final` 메서드는 **가상 메서드 호출 비용을 제거하고 인라이닝 최적화를 가능**하게 합니다.

### 3. 인터페이스와 추상 클래스의 차이에 대해 설명해 주세요.
##### 설명
**1. 공통점**

- **인스턴스화 불가:** 둘 다 직접 객체를 생성할 수 없습니다.
- **추상 메서드 포함 가능:** 구현을 강제할 수 있습니다.
- **다형성 제공:** 부모 타입(인터페이스/추상 클래스)으로 자식 객체를 참조할 수 있습니다.
    

---
 **2. 차이점 비교**

|구분|인터페이스 (Interface)|추상 클래스 (Abstract Class)|
|---|---|---|
|**목적**|**기능(행동)의 약속**: “이런 기능을 제공하겠다”는 규격 제공|**공통된 속성과 동작의 공유**: 상속받는 클래스에 **기본 구현** 제공|
|**메서드**|기본적으로 **추상 메서드만 선언 가능** (Java 8 이후 `default`, `static` 메서드 허용)|**추상 메서드 + 일반 메서드(구현 포함)** 모두 가능|
|**필드**|**`public static final` (상수)만 선언 가능**|**인스턴스 변수(상태) 선언 가능**|
|**상속**|**다중 구현 허용** (클래스는 여러 인터페이스를 구현 가능)|**단일 상속만 허용**|
|**접근 제어자**|메서드는 암묵적으로 `public abstract` (default/static 제외)|`public`, `protected`, `private` 자유롭게 사용 가능|
|**생성자**|없음|생성자 가질 수 있음|
|**상속 키워드**|`implements` 사용|`extends` 사용|

---
 **3. 사용 예시**

 **인터페이스 예시**

```java
interface Flyable {
    void fly();  // 추상 메서드
}

class Bird implements Flyable {
    @Override
    public void fly() {
        System.out.println("Bird is flying");
    }
}

```

- **의미:** “날 수 있다”라는 기능을 약속.
    
- `Flyable`을 구현하는 모든 클래스는 반드시 `fly()`를 구현해야 합니다.
    

추상 클래스 예시**
```java
abstract class Animal {
    String name;

    abstract void makeSound();  // 추상 메서드

    void eat() {                // 일반 메서드
        System.out.println(name + " is eating");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Woof!");
    }
}

```
- **의미:** `Animal`은 공통 속성(`name`)과 공통 동작(`eat()`)을 제공하고, `makeSound()`는 서브클래스가 구현하도록 강제합니다.
    

---
**4. 언제 사용해야 할까?**

- **인터페이스**:
    
    - **“~할 수 있다”**(Can do) 같은 **기능의 명세**를 정의할 때.
        
    - 서로 다른 클래스들이 동일한 행동을 보장해야 할 때 (예: `Comparable`, `Runnable`).
        
    - 다중 상속(여러 동작 인터페이스 구현)이 필요할 때.
        
- **추상 클래스**:
    
    - **공통된 속성(필드)과 기본 동작(메서드)을 공유**해야 할 때.
        
    - 클래스 계층구조에서 **코드 재사용**이 필요한 경우.
        

---

**5. Java 8 이후의 변화**

- 인터페이스에서도 `default` 메서드를 정의하여 **기본 구현을 제공**할 수 있게 되었고,  
    추상 클래스와의 차이가 줄어들었지만 **“상태(필드)”를 가질 수 없다는 점**에서 여전히 차이가 존재합니다.
    

---
 **정리**

> **인터페이스**는 **“무엇을 할 수 있는가(기능의 약속)”**,  
> **추상 클래스**는 **“무엇을 가지고 있고, 기본적으로 어떻게 동작하는가(공통 구현)”**를 제공하는 데 초점을 둡니다.
##### 왜 클래스는 단일 상속만 가능한데, 인터페이스는 2개 이상 구현이 가능할까요?
그 이유는 **언어 설계 철학과 다중 상속의 문제점**에서 비롯됩니다.

 **1. 클래스 다중 상속의 문제점**

클래스는 **상태(필드)**와 **행동(메서드 구현)**을 모두 포함할 수 있기 때문에, 다중 상속 시 **모호성(Ambiguity)** 문제가 발생합니다.

 **대표적인 다이아몬드 문제 (Diamond Problem)**
```java
class A {
    void hello() { System.out.println("Hello from A"); }
}

class B extends A {
    void hello() { System.out.println("Hello from B"); }
}

class C extends A {
    void hello() { System.out.println("Hello from C"); }
}

// 다중 상속이 가능하다고 가정
class D extends B, C {
    // D.hello() 호출 시, B와 C 중 어느 hello()를 써야 할까?
}

```

- `D`가 `B`와 `C`를 동시에 상속하면 **같은 메서드 시그니처를 가진 `hello()`가 2개 생기므로 호출 우선순위가 모호**해집니다.
    
- 이 모호성을 해결하려면 언어 차원에서 복잡한 규칙(예: C++의 가상 상속)을 도입해야 하는데, **자바는 단순성과 명확성을 위해 클래스 다중 상속을 금지**했습니다.
    

---
**2. 인터페이스는 상태를 가지지 않기 때문**

- 인터페이스는 **필드를 가질 수 없고(상수 `public static final`만 가능)**, 기본적으로 **메서드의 구현을 포함하지 않습니다**(Java 8 이전).
    
- 즉, **상태 충돌 문제**가 발생하지 않습니다.
    
- 다중 구현을 하더라도 **충돌하는 데이터 필드나 상속 체계 모호성**이 없기 때문에 안전하게 허용됩니다.
    

---

**3. Java 8 이후 default 메서드가 생겼는데 왜 여전히 다중 구현이 가능할까?**

- Java 8부터 인터페이스에 `default` 메서드가 생기면서 메서드 구현이 가능해졌지만,  
    **메서드 충돌이 발생하면 반드시 구현 클래스에서 오버라이딩(재정의)하여 해결해야 한다는 규칙**이 추가되었습니다.
    
```java
interface A { default void hello() { System.out.println("A"); } }
interface B { default void hello() { System.out.println("B"); } }

class C implements A, B {
    @Override
    public void hello() {  // 충돌 해결
        A.super.hello();   // 명시적으로 A의 hello 호출
    }
}

    
```
    
    이렇게 **명시적으로 어느 인터페이스의 메서드를 사용할지 지정**할 수 있어 충돌 문제가 해결됩니다.
    

---
 **4. 결론**

- **클래스:** 상태와 구현을 포함하므로 다중 상속 시 모호성과 충돌 문제가 발생 → **단일 상속만 허용.**
    
- **인터페이스:** 상태를 가지지 않고 **행동(계약)만 정의**하기 때문에 충돌 위험이 없음 → **다중 구현 가능.**
    
- **Java 8 이후에도 다중 구현 충돌은 `super` 키워드로 명시적으로 해결하도록 규칙화** → 안전하게 다중 인터페이스 구현 유지 가능.

### 4. 리플렉션에 대해 설명해 주세요.
##### 설명
**리플렉션(Reflection)**은 **런타임(runtime)에 클래스나 객체의 메타데이터(클래스 정보, 메서드, 필드 등)를 동적으로 조사하고 조작할 수 있는 기능**을 말합니다.  
즉, **코드가 실행 중에 자기 자신을 들여다보고 수정할 수 있게 해주는 메커니즘**입니다.

---
**1. 리플렉션의 특징**

- **컴파일 타임이 아닌 런타임에 클래스 정보를 다룸.**
    
- 객체의 **클래스 이름, 메서드 목록, 필드, 생성자** 등에 접근 가능.
    
- 접근 제어자(`private`, `protected`)를 무시하고 필드/메서드에 접근할 수 있음 (`setAccessible(true)`).
    
- 동적으로 객체를 생성하거나 메서드를 호출할 수 있음.
    

---
 **2. 리플렉션의 주요 사용 예**
```java
Class<?> clazz = Class.forName("com.example.MyClass");  // 클래스 로드

// 객체 생성
Object obj = clazz.getDeclaredConstructor().newInstance();

// 메서드 호출
Method method = clazz.getDeclaredMethod("sayHello");
method.invoke(obj);

// 필드 접근
Field field = clazz.getDeclaredField("name");
field.setAccessible(true);
field.set(obj, "Reflection Test");

```

---
3. 리플렉션의 장점**
	1. **유연한 동적 처리**
	    
	    - 실행 시점에 클래스 이름만 알고 있어도 동작 가능.
	        
	    - 예: JDBC 드라이버 로딩(`Class.forName("com.mysql.jdbc.Driver")`).
	        
	2. **프레임워크와 라이브러리 구현에 필수적**
	    
	    - 스프링(Spring)의 DI(의존성 주입), JPA 엔티티 매핑, Jackson JSON 직렬화 등 대부분의 자바 프레임워크는 리플렉션을 사용.
	        
	3. **일반 코드로는 접근 불가능한 정보 활용 가능**
	    
	    - `private` 필드나 메서드를 런타임에 강제로 접근 가능.
        

---
**4. 리플렉션의 단점**

1. **성능 저하**
    
    - 메서드 호출 시 직접 호출보다 **약 20배 이상 느릴 수 있음**(런타임 검사 및 메타데이터 탐색 비용).
        
2. **컴파일 타임 타입 체크 불가**
    
    - 리플렉션을 잘못 사용하면 런타임에 `NoSuchMethodException`, `IllegalAccessException` 등 에러가 발생할 수 있음.
        
3. **캡슐화 위반**
    
    - `private` 멤버에 강제 접근할 수 있어 객체지향 설계를 깨뜨릴 수 있음.
        

---
5. 리플렉션이 많이 쓰이는 곳**

- **프레임워크/라이브러리 내부**  
    (Spring, Hibernate, Jackson, JUnit)  
    → 컴파일 시점에 타입을 몰라도 객체 생성, 메서드 실행, 의존성 주입 등을 해야 하므로 필수적.
    
- **어노테이션 처리**  
    예: `@Autowired`, `@Entity` 같은 어노테이션의 메타데이터를 리플렉션으로 읽어 동작.
    
- **런타임 플러그인/모듈 로딩**  
    → 특정 클래스나 메서드를 동적으로 로딩하고 실행할 때 사용.
    

---
**6. 결론**

> **리플렉션은 런타임에 프로그램 구조를 조작할 수 있는 강력한 도구이지만, 성능 저하와 캡슐화 파괴 가능성이 있으므로 필요한 경우에만 신중히 사용하는 것이 권장됩니다.**
##### 의미만 들어보면 리플렉션은 보안적인 문제가 있을 가능성이 있어보이는데, 실제로 그렇게 생각하시나요? 만약 그렇다면, 어떻게 방지할 수 있을까요?
맞습니다. **리플렉션은 보안적인 문제를 일으킬 가능성이 있습니다.**  
리플렉션은 `private` 필드나 메서드에도 접근할 수 있기 때문에, 원래 의도한 **캡슐화(encapsulation)**를 깨뜨리고, 잘못 사용되면 **보안 취약점**으로 이어질 수 있습니다.

---
1. 리플렉션의 보안 문제 사례**

2. **`private` 필드 접근**
```java
Field field = SomeClass.class.getDeclaredField("password");
field.setAccessible(true);  // 접근 제한 해제
String pwd = (String) field.get(obj);

    
```
    원래 외부에서 접근할 수 없는 비밀번호 필드에 접근할 수 있습니다.
    
3. **불법적인 메서드 호출**
    
    - 접근 불가한 메서드(예: 관리자 전용 메서드)를 `invoke()`로 호출 가능.
        
4. **클래스 로딩 시 악성 코드 주입**
    
    - `Class.forName("com.hacker.MaliciousClass")` 로 동적 로딩 가능.  
        만약 외부 입력을 그대로 클래스명으로 사용할 경우, 공격자가 의도한 클래스가 실행될 수 있습니다.
        
5. **시스템 클래스 변조**
    
    - `java.lang.reflect` 패키지를 이용하면 JDK 내부 클래스나 필드를 조작할 수 있어 예기치 못한 동작을 유발할 수 있습니다.
        

---
2. 보안 문제를 방지하는 방법**
(1) SecurityManager (자바 17 이전)**
하지만 자바 17부터 `SecurityManager`는 **Deprecated** 되었으므로 대체 수단이 필요합니다.
    

**(2) 모듈 시스템 (Java 9+)**

- Java 9부터 도입된 **모듈 시스템(Jigsaw)** 을 사용하면 **모듈 간 리플렉션 접근을 제한**할 수 있습니다.
```java
module my.module {
    exports com.myapp;
    opens com.myapp.internal to specific.module; // 제한적 리플렉션 허용
}

```
**(3) 클래스 로딩 시 화이트리스트 검증**

- `Class.forName()` 등을 사용할 때 **외부 입력값을 그대로 사용하지 않고**, 허용된 클래스 목록(화이트리스트)을 확인해야 합니다.
    
(4) `setAccessible(true)` 최소화**

- 꼭 필요한 경우에만 사용하고, 라이브러리에서 남용하지 않도록 주의해야 합니다.
    
- Java 9 이상에서는 `setAccessible(true)` 호출 시 **권한 제한 경고**가 발생하며, `--illegal-access=deny` 옵션으로 차단할 수 있습니다.
    
 **(5) 보안 정책 파일 (policy file) 설정**

- 권한이 필요한 코드 영역에 대해 `ReflectPermission`을 제한하는 보안 정책을 설정할 수 있습니다.
    
 **3. 실제 보안적 관점에서의 판단**

- **일반 애플리케이션 코드에서 리플렉션을 남용하는 것은 권장되지 않습니다.**
    
- 하지만 **프레임워크나 라이브러리 수준에서는 필수적**입니다. (예: 스프링 DI, Hibernate 엔티티 매핑)
    
- **보안적으로 민감한 객체(암호키, 인증정보 등)는 리플렉션 접근 방지를 위한 설계(예: SecurityManager 대체 수단, final 클래스, 모듈화)와 정책이 필요**합니다.
    
 **4. 결론**

> 리플렉션은 **강력하지만 위험할 수 있는 도구**입니다.  
> 보안적으로 민감한 시스템에서는 **모듈화, 접근 제어, 화이트리스트 검증, 권한 정책** 등을 조합하여 사용을 제한해야 합니다.
##### 리플렉션을 언제 활용할 수 있을까요?
리플렉션(Reflection)은 **일반적인 애플리케이션 코드에서 매번 사용하는 도구는 아니지만**, **동적인 동작**이나 **프레임워크/라이브러리 개발** 시 매우 유용하게 활용됩니다.

다음은 **리플렉션을 사용하기 적합한 주요 상황**입니다.

---
**1. 컴파일 시점에 타입을 알 수 없는 경우**

- 런타임에 클래스나 메서드 이름이 결정되는 경우 유용합니다.
    
```java
// 클래스 이름을 문자열로만 알고 있는 상황
Class<?> clazz = Class.forName("com.example.MyClass");
Object obj = clazz.getDeclaredConstructor().newInstance();
 
```
- **활용 예:**
    - 플러그인 시스템 (외부에서 로딩되는 모듈 실행)
    - 런타임에 입력받은 클래스명/메서드명을 기반으로 동적 호출
        

---
 **2. 프레임워크 및 라이브러리 내부**

- **Spring**, **Hibernate**, **JUnit**, **Jackson** 등 수많은 자바 프레임워크는 리플렉션을 핵심적으로 활용합니다.
    
    - **Spring DI (의존성 주입)**:  
        `@Autowired` 필드를 리플렉션으로 찾아서 객체를 주입.
        
    - **Hibernate/JPA**:  
        엔티티 클래스의 필드 정보를 리플렉션으로 읽어 DB 컬럼과 매핑.
        
    - **JUnit**:  
        테스트 메서드(`@Test`)를 런타임에 찾아 자동 실행.
        
    - **Jackson/Gson**:  
        클래스 필드/Getter를 리플렉션으로 찾아 JSON 직렬화/역직렬화.
        

---
 **3. 어노테이션(Annotation) 기반 처리**

- 어노테이션 정보를 런타임에 읽어 동작을 제어할 때 사용됩니다.
    
```java
Method method = clazz.getDeclaredMethod("myMethod");
if (method.isAnnotationPresent(MyCustomAnnotation.class)) {
    // 어노테이션이 붙은 메서드만 실행
    method.invoke(obj);
}

```

---
4. 직렬화/역직렬화 및 매핑**

- **객체 → JSON** 또는 **JSON → 객체** 변환 시 리플렉션으로 필드를 탐색하고 값 할당.
    
- **ORM(Object Relational Mapping)** 프레임워크가 DB 테이블과 클래스 필드를 매핑할 때 사용.
    

---
**5. 디버깅, 로깅, 테스트**

- 테스트 코드에서 **비공개 필드(`private`)에 접근**해 상태를 확인할 때.
    
- 런타임에 객체의 구조를 확인하여 **자동 로깅**이나 **디버깅 도구**를 만들 때.
    

---
**6. 유연한 API 설계**

- 클래스 구조가 변경되더라도, 리플렉션을 통해 **필드명/메서드명을 문자열로 참조**하면 코드 수정 없이 동작할 수 있습니다.
    
    - 예: **스프링 BeanFactory**가 Bean을 문자열 이름으로 찾아 인스턴스화.
        

 **정리**

리플렉션은 **정적 타입 시스템으로는 불가능한 동적 동작**을 가능하게 해주는 도구입니다.  
특히 **프레임워크, ORM, 어노테이션 기반 라이브러리**에서 핵심 역할을 하며, **런타임에 타입을 모르는 상황에서 객체를 생성하거나 메서드를 호출할 때** 유용합니다.
### 5. static class와 static method를 비교해 주세요.
##### 설명
`static class`와 `static method`는 **static 키워드를 클래스와 메서드에 적용한 것**이지만, 의미와 용도가 완전히 다릅니다.

---
1. static method (정적 메서드)**
**특징**

- **클래스 레벨에서 동작**하며, 인스턴스 생성 없이 호출 가능.
    
- `this` 키워드를 사용할 수 없음 (인스턴스 변수 접근 불가).
    
- 클래스 로딩 시 메모리에 올라가며, 공유 자원 역할을 함.
    
- **객체 상태와 관계없는 기능(유틸리티 메서드)**에 적합.
    
**예시**

```java
class MathUtil {
    public static int add(int a, int b) {
        return a + b;
    }
}

int sum = MathUtil.add(5, 10);  // 객체 생성 없이 호출

```
 **2. static class (정적 클래스)**

자바에서 **클래스 자체에 `static`을 붙일 수는 없습니다.**  
다만, **“static 중첩 클래스(Static Nested Class)”**를 만들 수 있습니다.

 **특징**

- 외부 클래스의 인스턴스에 **종속되지 않는 중첩 클래스**를 의미.
    
- 외부 클래스의 `static` 멤버만 접근 가능 (`non-static` 멤버 접근 불가).
    
- **독립적인 클래스처럼 사용 가능**하여, 외부 클래스 객체 없이 인스턴스화할 수 있습니다.
    
 **예시**

```java
class Outer {
    static class Inner {  // Static Nested Class
        void print() {
            System.out.println("Static nested class");
        }
    }
}

Outer.Inner inner = new Outer.Inner();  // Outer 객체 없이 생성 가능

```

---
**3. 비교 요약**

|구분|**static method**|**static class (중첩 클래스)**|
|---|---|---|
|**적용 대상**|메서드|중첩 클래스(Inner Class)|
|**호출/생성**|클래스 이름으로 직접 호출 가능 (`ClassName.method()`)|외부 클래스 객체 없이 `new Outer.Inner()` 로 생성 가능|
|**목적**|객체 상태와 무관한 **공통 동작 제공**|외부 클래스와 **논리적으로 묶인 클래스**를 독립적으로 사용|
|**this 사용**|불가능|자기 자신에 대한 `this`는 가능|
|**메모리 관리**|클래스 로딩 시 메서드가 메모리에 올라감|외부 클래스 인스턴스와 관계없이 별도로 로딩|

---
 **4. 결론**

- **`static method`는 클래스에 귀속된 함수**이며, 주로 **유틸리티성 메서드**에서 사용됩니다.
    
- **`static class`는 독립적으로 사용할 수 있는 중첩 클래스**로, 외부 클래스의 인스턴스와 무관하게 사용하고자 할 때 유용합니다.

##### static 을 사용하면 어떤 이점을 얻을 수 있나요? 어떤 제약이 걸릴까요?
`static` 키워드는 **클래스 레벨의 멤버(변수, 메서드, 내부 클래스)를 정의**할 때 사용됩니다.  
이는 **인스턴스와 독립적으로 동작**하게 만들며, **메모리 관리나 호출 방식에서 장점**을 제공합니다. 하지만 동시에 몇 가지 **제약**도 따릅니다.

---
1. static의 주요 이점**
**(1) 인스턴스 생성 없이 접근 가능**

- `static` 멤버는 클래스 로딩 시 메모리에 올라가므로 **객체를 생성하지 않아도 바로 접근**할 수 있습니다.
    
 **(2) 공용 데이터(Shared Data) 관리**

- 모든 인스턴스가 **같은 static 변수**를 공유하므로 **공용 상태를 유지**할 수 있습니다.
    
    `class Counter {     static int count = 0;     Counter() { count++; } } // 모든 Counter 객체가 count를 공유`
    

**(3) 유틸리티 클래스 구현에 유용**

- 상태가 필요 없는 메서드를 묶어서 제공할 때 적합합니다.
    
- 예: `Math`, `Collections`, `Arrays` 클래스.
    
 **(4) 메모리 절약**

- **인스턴스마다 복제되지 않고, 클래스당 하나만 로딩**되므로 메모리 사용량을 줄일 수 있습니다.
    

---
 **2. static의 주요 제약**
 **(1) 인스턴스 변수나 메서드에 접근 불가**

- `static` 메서드는 **객체(인스턴스)의 상태를 알 수 없으므로** `this` 키워드를 사용할 수 없습니다.
    
 **(2) 오버라이딩(Overriding) 불가**

- `static` 메서드는 클래스 레벨에 속하므로 **상속 시 재정의(Overriding)가 불가능**합니다.
    
    - 단, **"메서드 숨김(Method Hiding)"** 형태로 같은 시그니처의 static 메서드를 선언할 수는 있습니다.
        
 **(3) 다형성(Polymorphism) 활용 불가**

- 인스턴스 메서드는 런타임에 동적 바인딩되지만, `static` 메서드는 **컴파일 시점에 정적으로 바인딩**됩니다.
    
 **(4) 가비지 컬렉션(GC) 대상 아님**

- 클래스가 언로드될 때까지 메모리에 상주하므로, 메모리 누수가 발생할 가능성이 있습니다(특히 큰 객체를 static 변수로 유지할 때).
    
 **(5) 동시성 문제**

- `static` 변수는 모든 스레드가 공유하므로, **멀티스레드 환경에서 동기화 이슈**가 발생할 수 있습니다. (e.g., `static` 변수를 갱신하는 경우 `synchronized` 필요)
    

---
 **3. static을 사용하면 좋은 경우**

- **상태를 공유해야 하는 경우:** 예를 들어, 모든 객체가 공유하는 카운터 변수.
    
- **유틸리티성 메서드:** 객체 상태와 무관한 단순 기능 제공 (e.g., `Math`, `Arrays`).
    
- **싱글톤 패턴:** `private static` 인스턴스를 사용하여 전역 접근을 제공.
    

---
 **4. static을 남용하면 생길 문제**

- 객체지향적인 설계가 깨질 수 있음 (모든 상태가 전역화).
    
- 테스트 및 확장성에 불리.
    
- 멀티스레드 환경에서 예기치 못한 동기화 문제 발생 가능.
    

---
 **정리**

> **static의 장점:** 객체 생성 없이 접근 가능, 메모리 절약, 공용 상태 관리, 유틸리티성 메서드 구현.  
> **static의 제약:** 인스턴스 접근 불가, 오버라이딩 불가, 다형성 제한, GC 대상 아님, 동시성 문제.
##### 컴파일 과정에서 static 이 어떻게 처리되는지 설명해 주세요.
`static` 키워드는 **컴파일러와 JVM이 멤버를 클래스 단위로 관리**하도록 지시합니다.  
즉, **객체(인스턴스)와 분리된 메모리 공간에 로드되고 공유**되며, 호출 및 접근 방식에서도 **컴파일 시점부터 정적으로 처리(static binding)** 됩니다.

---
 **1. 컴파일 시 static 처리 방식**

 **(1) static 변수**

- 컴파일러는 `static` 변수를 **클래스 소속 변수(전역 변수와 유사)**로 인식합니다.
    
- `.class` 파일의 **메서드 영역(Method Area)**에 로딩되며, **클래스가 처음 로드될 때 1회만 메모리에 할당**됩니다.
    
- 각 인스턴스는 `static` 변수를 **공유**하며, `this.variable` 대신 **`ClassName.variable` 형태로 접근하도록 컴파일됩니다.**
    
- **바이트코드 예시 (javap -c)**
    
```java
class Test {
    static int count = 0;
    void inc() { count++; }
}

```
    
    디컴파일 시 `Test.count`로 직접 접근하는 코드가 생성됩니다.
    

---
 **(2) static 메서드**

- 컴파일러는 `static` 메서드를 **클래스 소속 함수로 처리**하고, **인스턴스 메서드와 달리 `this` 참조를 인자로 전달하지 않습니다.**
    
- 호출 시 **정적 바인딩(static binding)** 을 적용합니다.
    
    - 인스턴스 메서드는 **가상 메서드 테이블(v-table)**을 통해 런타임에 호출 대상을 결정하지만, `static` 메서드는 **컴파일 시점에 호출 메서드가 확정**됩니다.
        
- 예시:
    
    java
    
    복사편집
    
    `Test.print(); // 컴파일 시점에 직접 호출로 치환`
    

---
 **(3) static 초기화 블록**

- `static { ... }` 블록은 **클래스 로딩 시점(클래스가 처음 참조될 때)**에 단 한 번 실행됩니다.
    
- 컴파일 시 `.class` 파일의 `<clinit>` (Class Initializer) 메서드로 변환됩니다.
    
- 예시:
    
    java
    
    복사편집
    
    `class InitExample {     static int x;     static { x = 100; } }`
    
    디컴파일 시 `<clinit>` 메서드가 생성되어 `x` 값이 설정됩니다.
    

---

 **2. JVM 실행 시 static 처리**

1. **클래스 로더(ClassLoader)가 클래스 로딩**
    
    - `Test.class`가 처음 참조되면 JVM은 클래스 메타데이터와 static 멤버를 **메서드 영역(Method Area)**에 적재.
        
2. **static 변수 초기화 및 static 블록 실행**
    
    - 클래스가 로드될 때 **단 한 번** 수행됩니다.
        
3. **호출 시 클래스 이름으로 직접 접근**
    
    - 객체 인스턴스와 무관하게 `Test.print()`로 바로 실행.
        

---
 **3. static이 컴파일 시 주는 이점**

- **호출 최적화:**  
    `static` 메서드는 **다형성(virtual dispatch)** 검사를 거치지 않으므로 호출 비용이 적습니다.
    
- **메모리 절약:**  
    인스턴스마다 변수를 복사하지 않고, 하나의 static 메모리를 공유.
    
- **상수 처리:**  
    `static final` 상수는 **컴파일 타임 상수로 인라인 처리**되어 실행 속도가 빨라집니다.
    

---
 **4. 제약점 (컴파일 시 관점)**

- `static` 메서드는 **객체의 인스턴스 변수와 this 참조에 접근 불가** → 컴파일러가 이를 엄격히 체크.
    
- 오버라이딩 불가 → **컴파일 시점부터 메서드 바인딩 확정**.
    

---
 **정리**

> **컴파일러는 `static` 멤버를 객체와 독립된 “클래스 레벨 리소스”로 취급하고, 호출도 컴파일 타임에 정적으로 결정합니다.**  
> 실행 시 JVM은 해당 멤버를 **메서드 영역에 적재**하여 모든 인스턴스가 공유하도록 처리합니다.

### 6. Java의 Exception에 대해 설명해 주세요.
##### 설명
Java에서 **Exception(예외)**은 프로그램 실행 중 발생할 수 있는 **비정상적 상황이나 오류를 객체로 표현한 것**입니다.  
자바는 예외를 체계적으로 다루기 위해 **예외 처리(Exception Handling) 메커니즘**을 제공합니다.

---
1. Exception의 개념**

- 예외는 `Throwable` 클래스의 하위 클래스 객체로 표현됩니다.
    
- 예외가 발생하면 **JVM은 해당 예외를 던지고(`throw`)**, 이를 처리할 수 있는 **`catch` 블록을 찾습니다.**
    
- 예외가 처리되지 않으면 프로그램은 비정상 종료됩니다.
    

---
 **2. Exception 계층 구조**
```java
java.lang.Object
  └─ java.lang.Throwable
       ├─ java.lang.Error        // 시스템 레벨 오류
       └─ java.lang.Exception    // 애플리케이션 레벨 예외
            └─ java.lang.RuntimeException

```
 **(1) Error**

- JVM이나 시스템 레벨에서 발생하는 심각한 오류.
    
- 예: `OutOfMemoryError`, `StackOverflowError`.
    
- **애플리케이션에서 복구 불가능**하므로 일반적으로 `catch`하지 않습니다.
    

 **(2) Exception**

- 애플리케이션 실행 중 발생할 수 있는 예외 상황.
    
- 개발자가 적절히 처리할 수 있습니다.
    
    **Checked Exception**
    
    - **컴파일 시점**에 반드시 처리(try-catch 또는 throws)해야 하는 예외.
        
    - 예: `IOException`, `SQLException`, `ClassNotFoundException`.
        
    
    #### **Unchecked Exception (RuntimeException)**
    
    - **런타임 시점**에 발생하며, 명시적인 예외 처리를 강제하지 않음.
    - 예: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`.
        

 **3. Exception 처리 방법**

 **(1) try-catch-finally**

```java
try {
    int result = 10 / 0;
} catch (ArithmeticException e) {
    System.out.println("0으로 나눌 수 없습니다: " + e.getMessage());
} finally {
    System.out.println("항상 실행되는 블록");
}

```

- `try`: 예외 발생 가능 코드.
    
- `catch`: 특정 예외를 잡아서 처리.
    
- `finally`: 예외 발생 여부와 관계없이 항상 실행 (자원 해제 등).
    
 **(2) throws**

- 메서드에서 예외를 직접 처리하지 않고 **호출한 쪽으로 던짐**.
    
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");
}

```
 **(3) throw**

- 명시적으로 예외 객체를 생성하여 던짐.
    
```java
	if (value < 0) {
    throw new IllegalArgumentException("음수는 허용되지 않습니다.");
}

```

---
 **4. 사용자 정의 예외**

개발자는 `Exception` 또는 `RuntimeException`을 상속받아 사용자 정의 예외를 만들 수 있습니다.

```java
class MyCustomException extends Exception {
    public MyCustomException(String message) {
        super(message);
    }
}

```
---
 **5. Exception 처리의 장점**

- 예외를 **객체화**하여 **에러 정보(메시지, 스택 트레이스 등)를 구조적으로 제공**.
    
- 프로그램의 **안정성과 가독성**을 높이고, 비정상 종료를 방지.
    
- **예외 전파(throws)**를 통해 책임을 호출자에 위임 가능.
    

---
 **6. 주의할 점**

- 불필요하게 광범위한 예외(`catch Exception`)를 잡는 것은 디버깅을 어렵게 할 수 있음.
    
- Checked Exception은 코드 가독성을 떨어뜨릴 수 있어, 최근에는 **RuntimeException을 활용**하는 경우가 많음 (Spring, JPA도 이 접근 방식을 채택).
    
 **정리**

> **Exception은 프로그램 실행 중 발생하는 오류를 처리하기 위한 객체화된 메커니즘**으로,  
> Checked/Unchecked로 나뉘며, `try-catch-finally`와 `throws`를 통해 유연하게 처리할 수 있습니다.
##### 예외처리를 하는 세 방법에 대해 설명해 주세요.
**1. `try-catch-finally`로 처리 (직접 처리)**
 **개념**

- 예외가 발생할 수 있는 코드를 `try` 블록에 넣고, 예외 발생 시 `catch` 블록에서 해당 예외를 처리합니다.
    
- `finally` 블록은 예외 발생 여부와 관계없이 **항상 실행**됩니다. (주로 자원 해제에 사용)
 **특징**

- 예외를 **직접 잡아서 처리**할 수 있어 프로그램이 비정상 종료되지 않음.
    
- `finally` 블록은 자원 해제, 연결 종료, 로그 기록 등에 사용됩니다.
    

---
 **2. `throws`로 던지기 (호출자에게 예외 전파)**
 **개념**

- 메서드에서 발생한 예외를 **직접 처리하지 않고, 호출한 메서드에 예외를 던짐**.
    
- 메서드 선언부에 `throws 예외클래스명`을 명시해야 합니다.
    
 **예시**
```java
public void readFile() throws IOException {
    FileReader fr = new FileReader("test.txt");  // IOException 가능
}

public static void main(String[] args) {
    try {
        readFile();  // 호출한 쪽에서 처리
    } catch (IOException e) {
        e.printStackTrace();
    }
}

```
 **특징**

- **예외 처리를 상위 호출자에게 위임**할 수 있어 메서드 자체가 더 단순해짐.
    
- Checked Exception은 `throws`로 반드시 명시하거나 `try-catch`로 처리해야 컴파일이 가능.
    

 **3. `throw`로 명시적 예외 발생시키기**

 **개념**

- 코드에서 직접 예외 객체를 생성해 **강제로 예외를 발생시킴**.
    
- 주로 **입력값 검증**이나 **비정상 상태**를 알릴 때 사용.
    
 **예시**

```java
public void setAge(int age) {
    if (age < 0) {
        throw new IllegalArgumentException("나이는 음수가 될 수 없습니다.");
    }
    this.age = age;
}

```
**특징**

- 원하는 시점에서 예외를 발생시켜 **명확하게 에러 상황을 제어**할 수 있습니다.
    
- `throw`로 던진 예외는 **try-catch** 또는 **throws**로 반드시 처리해야 합니다.
    

---
 **정리**

1. **`try-catch-finally`**: 예외를 **직접 처리**한다.
    
2. **`throws`**: 예외를 **호출자에게 전달**한다.
    
3. **`throw`**: **명시적으로 예외를 발생**시킨다.
##### CheckedException, UncheckedException 의 차이에 대해 설명해 주세요.
Java의 예외(Exception)는 크게 **Checked Exception**과 **Unchecked Exception**으로 나뉘며, 이 둘의 차이는 **컴파일 시점에 예외 처리를 강제하는지 여부**와 **발생하는 상황**에 있습니다.

---
 **1. Checked Exception**

- **컴파일 타임에서 예외 처리(`try-catch` 또는 `throws`)가 강제되는 예외.**
    
- 발생 가능성이 있는 예외를 **개발자가 명시적으로 처리해야 한다**는 것이 특징.
    
- 주로 **외부 자원(I/O, 네트워크, DB 등)**과 관련된 상황에서 발생.
    
- `Exception` 클래스를 상속하지만 `RuntimeException`을 상속하지 않는 예외들이 이에 해당.
    
 **예시**

```java
public void readFile() throws IOException {
    FileReader reader = new FileReader("file.txt"); // IOException 가능
}

```
 **대표 예외**

- `IOException`
    
- `SQLException`
    
- `ClassNotFoundException`
    
- `FileNotFoundException`
    

---
 **2. Unchecked Exception**

- **컴파일 시점에 예외 처리를 강제하지 않는 예외.**
    
- 주로 **프로그래밍 오류(로직 에러)**로 인해 발생하는 경우가 많습니다.
    
- `RuntimeException`을 상속하는 예외들이 이에 해당.
    
- 개발자가 원하면 `try-catch`로 처리할 수 있지만, **필수는 아님**.
    
 **예시**

java

복사편집

`int[] arr = {1, 2, 3}; System.out.println(arr[5]);  // ArrayIndexOutOfBoundsException (Unchecked)`

- 이 예외는 **개발자가 코드 로직을 잘못 작성했기 때문에** 미리 처리하도록 강제하지 않습니다.
    
 **대표 예외**

- `NullPointerException`
    
- `ArrayIndexOutOfBoundsException`
    
- `IllegalArgumentException`
    
- `ArithmeticException`
    

---
 **3. 주요 차이점 정리**

|구분|**Checked Exception**|**Unchecked Exception**|
|---|---|---|
|**상속 관계**|`Exception` (단, `RuntimeException` 제외)|`RuntimeException` 및 하위 클래스|
|**컴파일 시점 처리**|반드시 처리 필요 (`try-catch` 또는 `throws`)|강제되지 않음|
|**발생 원인**|외부 환경 요인 (파일, 네트워크 등)|코드 로직 오류|
|**예시**|`IOException`, `SQLException`|`NullPointerException`, `ArithmeticException`|

---
 **4. 실무적 관점**

- **Checked Exception**: 외부 환경에 의존하는 부분(파일 읽기/쓰기, DB 연결 등)에 주로 사용.  
    _예:_ `Spring`의 `DataAccessException`은 RuntimeException으로 래핑하여 예외 처리를 단순화.
    
- **Unchecked Exception**: 프로그래머 실수로 발생하는 예외에 주로 사용. 보통 **코드 수정으로 해결**.
    

---
 **5. 정리**

> **Checked Exception**은 *"발생 가능성을 미리 대비하라"*는 의미로 컴파일러가 강제합니다.  
> **Unchecked Exception**은 *"로직 버그이므로 코드로 해결하라"*는 의미로, 강제하지 않습니다.
##### 예외처리가 성능에 큰 영향을 미치나요? 만약 그렇다면, 어떻게 하면 부하를 줄일 수 있을까요?
예외 처리는 **정상적인 흐름의 코드보다 성능에 더 많은 비용이 발생**합니다.  
하지만 **예외 발생 자체보다, 예외가 실제로 던져지고(Stack Trace 생성) 처리되는 과정이 느린 것**이 주요 원인입니다.

---
 **1. 예외 처리가 성능에 영향을 미치는 이유**

1. **스택 트레이스 생성 비용**
    
    - 예외가 발생하면 JVM은 현재 스레드의 호출 스택을 추적하여 `Throwable.fillInStackTrace()`를 호출합니다.
        
    - 이 과정에서 스택 프레임 정보를 캡처해야 하므로 **상당한 오버헤드**가 발생합니다.
        
2. **정상 흐름에서 예외를 남용할 경우**
    
    - 예외를 **제어 흐름(Control Flow)으로 사용하면 성능 저하가 큽니다.**  
        (예: 조건문으로 체크할 수 있는 상황을 `try-catch`로 해결하려는 경우)
        
3. **캐치 후 다시 던지는 예외**
    
    - `catch` 블록에서 처리하지 않고 다시 `throw`하면 추가적인 스택 트레이스 생성이 이루어집니다.
        

---
 **2. 어느 정도 느린가?**

- **일반 조건문 검사(`if`)**와 비교하면 **예외 발생은 수십~수백 배 느릴 수 있습니다.**
    
- 예를 들어, 예외를 1만 번 던지면 **수 밀리초에서 수십 밀리초 단위의 지연**이 발생할 수 있습니다.
    
- 하지만 **예외가 발생하지 않는 `try-catch` 자체는 거의 성능 영향을 주지 않습니다.**  
    (즉, "예외가 발생하는 순간"에만 성능 비용이 큼)
    

---
 **3. 성능 부하를 줄이는 방법**

 **(1) 예외를 로직 제어에 사용하지 않는다**

- **잘못된 방식:**
    
    java
    
    복사편집
    
    `try {     int value = Integer.parseInt("abc");  // NumberFormatException 발생 } catch (NumberFormatException e) {     // 예외로 흐름 제어 (비효율적) }`
    
- **개선된 방식:**
    
    java
    
    복사편집
    
    `if (isNumeric(str)) {  // 조건 체크     int value = Integer.parseInt(str); }`
    
 **(2) 예외는 “예외적인 상황”에서만 사용**

- 정상적인 흐름에서는 조건문, Optional, Validation 등으로 사전 체크.
    

 **(3) 스택 트레이스 생성을 줄이기**

- 커스텀 예외 클래스에서 `fillInStackTrace()`를 오버라이딩해 **스택 트레이스 생성 비용을 줄일 수 있습니다.**
    
    java
    
    복사편집
    
    `@Override public synchronized Throwable fillInStackTrace() {     return this;  // 스택 트레이스 생략 }`
    
 **(4) Checked Exception을 과도하게 사용하지 않기**

- Checked Exception은 `throws` 선언과 `try-catch`로 인한 불필요한 오버헤드가 생길 수 있습니다.  
    실무에서 Spring, JPA 등이 **Unchecked(Runtime) Exception** 중심으로 설계된 이유 중 하나입니다.
    

 **(5) Hot Path(빈번히 호출되는 코드)에서는 예외 최소화**

- 성능이 중요한 루프, API 엔드포인트 등에서는 **예외가 발생하지 않도록 사전 방어 로직을 작성**.
    

---

 **4. 결론**

- **예외 발생 자체는 일반 로직보다 훨씬 느립니다.**
    
- 하지만 **예외가 발생하지 않는 한, `try-catch` 문 자체는 거의 오버헤드가 없습니다.**
    
- 따라서 **예외는 진짜 “예외적 상황”에서만 사용하고, 사전 조건 검사로 방어 코드를 작성하는 것이 성능 최적화의 핵심**입니다.
### 7. Synchronized 키워드에 대해 설명해 주세요.
##### 설명
`synchronized` 키워드는 Java에서 **멀티스레드 환경에서의 동기화(synchronization)** 를 위해 사용됩니다. 하나의 자원(변수, 메서드 등)을 여러 스레드가 동시에 접근할 때, **경쟁 조건(race condition)** 을 방지하기 위해 사용됩니다.

---
🔹 1. 핵심 개념

- `synchronized`는 **임계 영역(Critical Section)** 에 **하나의 스레드만 접근하도록 락(lock)을 거는 기능**입니다.
    
- 자바에서 **객체마다 하나의 모니터 락(Monitor Lock)** 을 가지고 있으며, synchronized는 이 락을 기반으로 작동합니다.
    

---
🔹 2. 사용 방법

✅ 1. 메서드 전체 동기화

```java
public synchronized void increment() {
    count++;
}

```
- 인스턴스 메서드의 경우: **해당 객체(this)** 를 락으로 사용
    
- 동시에 여러 스레드가 `increment()`를 호출해도 **한 스레드만 락을 얻고 실행**됨
    

---
✅ 2. 블록 단위 동기화

```java
public void increment() {
    synchronized(this) {
        count++;
    }
}

```
- `this`는 락의 대상입니다. 더 정밀한 제어가 가능하며, 일부 코드만 동기화할 때 사용합니다.
    

---
✅ 3. static 메서드 동기화

```java
public static synchronized void printLog() {
    // ...
}

```
- `static` 메서드는 **클래스 수준의 락 (`ClassName.class`)** 을 사용합니다.
    
🔹 3. 작동 원리

`synchronized` 블록에 진입하면:

1. 대상 객체의 **모니터 락을 획득**합니다.
    
2. 락을 획득한 스레드만 블록을 실행할 수 있습니다.
    
3. 실행이 끝나면 락을 **반환(해제)** 합니다.
    
4. 다른 스레드는 락이 반환될 때까지 **대기 상태(BLOCKED)** 가 됩니다. 

---
🔹 4. 장점과 단점

|항목|설명|
|---|---|
|✅ 장점|Race condition 방지, 스레드 안전성 보장|
|⚠ 단점|성능 저하, 데드락 가능성 있음, 락 경쟁으로 병렬성 감소|

---
🔹 5. 관련 개념

- `ReentrantLock`: `synchronized`보다 정교한 락 제어가 가능 (timeout, tryLock, interruptible 등)
    
- `volatile`: 메모리 가시성을 보장하지만 동기화는 아님
    
- `wait()`, `notify()`: `synchronized` 블록 내에서만 사용 가능 (Object의 모니터를 이용)
    
##### Synchronized 키워드가 어디에 붙는지에 따라 의미가 약간씩 변화하는데, 각각 어떤 의미를 갖게 되는지 설명해 주세요.
✅ 1. 인스턴스 메서드에 붙을 때

```java
`public synchronized void instanceMethod() {     // ... }`
```


✔ 의미

- **this 객체의 모니터(lock)** 를 사용합니다.
    
- 즉, 같은 객체에 대해 여러 스레드가 `instanceMethod()`를 호출하면 **동시에 접근할 수 없습니다.**
    
❗하지만 서로 다른 인스턴스라면 동시 접근 가능합니다.

---
✅ 2. static 메서드에 붙을 때
```java
public static synchronized void staticMethod() {
    // ...
}

```
 의미

- **해당 클래스의 Class 객체 (`ClassName.class`)의 모니터(lock)** 를 사용합니다.
    
- 모든 인스턴스가 공유하는 클래스 수준의 락입니다.
    
➕ 실전 예

- 싱글턴에서 전역 설정 변경 같은 작업을 synchronized static으로 제어할 수 있음.
    

---
✅ 3. 블록에 붙을 때
```java
public void method() {
    synchronized(this) {
        // ...
    }
}

```
 ✔ 의미

- **명시한 객체의 모니터(lock)** 를 사용합니다.
- `synchronized(obj)` → obj가 락의 대상입니다.
    
➕ 실전 예

- 블록 단위로 최소한의 영역만 동기화하고 싶을 때, 또는
- 객체에 따라 락을 분리하고 싶을 때 (예: `userId`마다 락 다르게 하기)
    

---
✅ 4. 예시 비교

```java
class Example {
    public synchronized void methodA() { }      // this 객체에 락
    public static synchronized void methodB() { } // Class 객체에 락
    public void methodC() {
        synchronized(this) { }                  // this 객체에 락
    }
    public void methodD() {
        synchronized(Example.class) { }         // Class 객체에 락
    }
}

```

|메서드 이름|락 대상|
|---|---|
|methodA|this (인스턴스)|
|methodB|Example.class (클래스)|
|methodC|this (인스턴스)|
|methodD|Example.class (클래스)|

---
✅ 요약 정리

|위치|락 대상|설명|
|---|---|---|
|`synchronized` 인스턴스 메서드|`this`|해당 객체 단위의 동기화|
|`synchronized` static 메서드|`ClassName.class`|클래스 단위의 동기화|
|`synchronized(this)`|`this`|블록 단위로 인스턴스 락 사용|
|`synchronized(obj)`|`obj`|원하는 객체로 락 분리 가능|
##### 효율적인 코드 작성 측면에서, Synchronized는 좋은 키워드일까요?
`synchronized`는 **멀티스레드 환경에서 안전성을 보장하는 데 필수적인 도구**이지만, **효율적인 코드 작성을 위한 도구는 아닙니다**. 오히려 잘못 사용하면 성능 저하나 병목을 유발할 수 있습니다.

따라서 효율적인 코드 작성을 목표로 할 때는 `synchronized`의 **장점과 단점**을 명확히 이해하고 **필요한 최소한의 범위에서 신중하게 사용하는 것**이 중요합니다.

---
 ✅ synchronized의 장점

| 장점                | 설명                                                        |
| ----------------- | --------------------------------------------------------- |
| **간단한 문법**        | 락/언락을 명시적으로 하지 않아도 됨 (`try-finally` 불필요)                  |
| **스레드 안전성 보장**    | 공유 자원에 대한 동시에 접근할 경우, 레이스 컨디션 방지                          |
| **JVM 최적화 적용 대상** | JDK 1.6 이상에서는 biased lock, lightweight lock 등 최적화 기법이 적용됨 |

---
 ❌ synchronized의 단점 (비효율적일 수 있는 이유)

| 단점            | 설명                                               |
| ------------- | ------------------------------------------------ |
| **성능 저하**     | 스레드 간 lock 경쟁 발생 시, context switching 비용 증가      |
| **병목 발생 가능성** | 락 범위를 넓게 설정하면 하나의 스레드 때문에 전체가 대기할 수 있음           |
| **데드락 위험**    | 여러 락을 중첩해서 사용할 경우 발생 가능                          |
| **유연성 부족**    | 락의 조건, 시간 제한, 중단 제어 등을 못 함 (`ReentrantLock`은 가능) |

---
💡 효율적인 대안 또는 개선 방법

| 방법                      | 설명                                                                 |
| ----------------------- | ------------------------------------------------------------------ |
| **락 범위를 줄이기**           | 전체 메서드 대신 필요한 코드 블록만 synchronized 처리                               |
| **`ReentrantLock` 사용**  | 명시적 락 제어, 타임아웃, 락 중단, 공정성 설정 등 가능                                  |
| **`Concurrent` 컬렉션 사용** | `ConcurrentHashMap`, `CopyOnWriteArrayList` 등은 내부적으로 적절히 락을 나눠서 처리 |
| **비동기 처리/락 분리**         | 독립적인 리소스는 서로 다른 락을 사용해서 병렬성 향상 가능                                  |
| **원자 클래스 사용**           | `AtomicInteger`, `AtomicLong` 등은 락 없이도 thread-safe 연산 가능           |

---
 📌 결론

> **“안전성 확보에는 유용하지만, 효율적인 코드 작성만을 고려하면 신중하게 사용해야 할 키워드입니다.”**

- 성능이 중요한 영역에서는 `synchronized` 보다는 더 정밀한 제어가 가능한 도구를 사용하는 것이 좋습니다.
    
- 단, 초기 개발이나 구조가 단순할 때는 빠르게 스레드 안전성을 확보하는 데 좋은 선택이 될 수 있습니다.
##### Synchronized 를 대체할 수 있는 자바의 다른 동기화 기법에 대해 설명해 주세요.
✅ 1. `ReentrantLock` (java.util.concurrent.locks)

✔ 특징

- `synchronized`보다 유연하고 기능이 풍부한 락
    
- 명시적으로 lock()/unlock() 호출 필요
    

✔ 주요 기능

|기능|설명|
|---|---|
|`tryLock()`|락이 사용 중이면 대기하지 않고 바로 실패|
|`tryLock(timeout)`|일정 시간만 기다렸다가 실패|
|`lockInterruptibly()`|대기 중인 스레드를 interrupt로 중단 가능|
|`isHeldByCurrentThread()`|락 보유 여부 확인|
|`getHoldCount()`|재진입 횟수 확인|
✔ 예시
```java
ReentrantLock lock = new ReentrantLock();

void update() {
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock(); // 반드시 해제
    }
}

```
---
 ✅ 2. `ReadWriteLock` (`ReentrantReadWriteLock`)

✔ 특징

- 읽기 작업은 동시에 허용, 쓰기 작업은 단독 실행
    
- 읽기 많은 시스템에서 성능 향상 가능
    

✔ 예시
```java
ReentrantLock lock = new ReentrantLock();

void update() {
    lock.lock();
    try {
        // critical section
    } finally {
        lock.unlock(); // 반드시 해제
    }
}

```
---
✅ 3. `StampedLock` (Java 8+)
✔ 특징

- `ReadWriteLock`의 개선 버전
    
- 낙관적 읽기(optimistic read)를 제공하여 **락 없는 읽기** 가능
    
- 더 복잡하지만 **고성능 읽기 시나리오**에 적합
    

---
✅ 4. `Atomic` 클래스 (java.util.concurrent.atomic)
✔ 특징

- 락 없이 CAS(Compare-And-Swap) 기반 원자 연산 제공
    
- 단일 변수 동기화에 매우 효과적
    
✔ 대표 클래스

- `AtomicInteger`, `AtomicLong`
    
- `AtomicReference`, `AtomicBoolean`
    
- `AtomicIntegerArray`, `AtomicReferenceArray`
    
✔ 예시
```java
AtomicInteger count = new AtomicInteger(0);

void increment() {
    count.incrementAndGet(); // thread-safe
}

```
✅ 5. `volatile` 키워드

✔ 특징

- **변수의 변경 내용을 모든 스레드에 즉시 반영** (메모리 가시성 보장)
    
- 락을 사용하지 않으므로 성능은 뛰어나지만 **복잡한 연산에는 불안정**
    
✔ 한계

- 원자성(atomicity)은 보장하지 않음
    
- 단독 사용보다는 다른 구조와 함께 써야 안전함
    

---
✅ 6. `synchronized`와의 비교 요약

| 기법              | 장점          | 단점               |
| --------------- | ----------- | ---------------- |
| `synchronized`  | 간편하고 안정적    | 성능 저하, 데드락 위험    |
| `ReentrantLock` | 고급 제어 가능    | 락 해제 실수 위험       |
| `ReadWriteLock` | 읽기 병렬성      | 쓰기 많으면 오히려 성능 저하 |
| `StampedLock`   | 낙관적 락으로 고성능 | 사용 복잡            |
| `Atomic` 클래스    | 빠르고 가볍다     | 복잡한 연산에는 부적합     |
| `volatile`      | 가시성 확보      | 원자성 미보장          |

---
🧠 결론

- `synchronized`는 단순한 동기화에는 충분하지만, **성능/유연성/복잡성** 요구에 따라 다른 대체 수단을 선택하는 것이 바람직합니다.
    
- **간단한 락** → `synchronized`
    
- **정밀 제어** → `ReentrantLock`, `ReadWriteLock`
    
- **낮은 지연, 높은 성능** → `StampedLock`, `Atomic`
    
- **값 교체만 필요한 경우** → `volatile`, `AtomicReference`
##### Thread Local에 대해 설명해 주세요.
`ThreadLocal`은 **스레드마다 독립적인 변수를 가질 수 있게 해주는 클래스**입니다. 멀티스레드 환경에서 **공유 자원을 피하고**, 각 스레드가 **자기만의 데이터를 보관**하고 사용할 수 있도록 도와줍니다.

---
✅ 1. ThreadLocal의 정의

> `ThreadLocal<T>`은 **각 스레드마다 고유한 변수 값을 저장**할 수 있도록 해주는 Java 클래스입니다.

즉, 하나의 `ThreadLocal` 인스턴스를 여러 스레드가 공유하더라도, **스레드마다 각각의 값**을 따로 저장하고 사용합니다.

---
✅ 2. 기본 사용법

```java
ThreadLocal<Integer> threadLocal = new ThreadLocal<>();

// 값 설정
threadLocal.set(100);

// 값 가져오기
int value = threadLocal.get();

// 값 제거 (메모리 누수 방지)
threadLocal.remove();

```
- `set(value)` → 현재 스레드에 값을 저장
    
- `get()` → 현재 스레드의 값을 조회
    
- `remove()` → 현재 스레드의 값 제거 (메모리 누수 방지)
    

---
✅ 3. ThreadLocal 동작 방식

- 내부적으로 `ThreadLocalMap`이라는 자료구조를 사용하여  
    **`Thread` 객체마다 고유한 Map이 존재**합니다.
    
- 이 Map의 key는 `ThreadLocal` 객체, value는 저장한 데이터입니다.
    
```
Thread A
 └─ ThreadLocalMap
      └─ [ThreadLocal@1a2b3c] -> 100

Thread B
 └─ ThreadLocalMap
      └─ [ThreadLocal@1a2b3c] -> 200

```
→ 같은 ThreadLocal 객체여도, 스레드마다 독립적인 값을 저장합니다.

---
✅ 4. 활용 예시

💡 예: 날짜 포맷 객체 공유 문제 해결

```java
ThreadLocal<DateFormat> dateFormat = ThreadLocal.withInitial(() ->
    new SimpleDateFormat("yyyy-MM-dd")
);

// 스레드마다 안전하게 사용 가능
String today = dateFormat.get().format(new Date());

```
- `SimpleDateFormat`은 **스레드에 안전하지 않음**.
    
- `ThreadLocal`을 이용하면 각 스레드마다 별도의 객체를 사용하므로 동기화 없이도 안전하게 사용 가능.
    

---
✅ 5. 장점과 단점

| 장점                           | 단점                             |
| ---------------------------- | ------------------------------ |
| 락 없이 스레드별 독립 데이터 제공          | **메모리 누수 위험** (remove 누락 시)    |
| 코드 복잡도 감소 (공유 없이도 데이터 유지 가능) | 스레드 수 많을 경우 메모리 사용 증가          |
| 특정 스레드에서만 유효한 값 저장 가능        | 논리적 흐름 따라가기 어려움 (숨겨진 상태 발생 가능) |

---
✅ 6. 실전 활용 사례

|분야|활용 예|
|---|---|
|Spring Security|현재 로그인한 사용자 정보 저장 (`SecurityContextHolder`)|
|DB Connection Pool|트랜잭션 단위로 같은 커넥션 유지 (`DataSourceTransactionManager`)|
|로그 트레이싱|요청 ID를 스레드에 저장해 로그에 일관되게 출력 (e.g. MDC)|

---
🧠 결론

- `ThreadLocal`은 **스레드별로 독립된 변수**가 필요한 경우 유용합니다.
    
- 다만, `remove()`를 반드시 호출하지 않으면 **메모리 누수**가 발생할 수 있으므로 **ThreadPool 사용 시 특히 주의**해야 합니다.
### 8. Java Stream에 대해 설명해 주세요.
##### 설명
Java Stream은 Java 8에서 도입된 기능으로, **데이터를 선언형(Declarative) 방식으로 처리**할 수 있게 해주는 API입니다. **컬렉션 또는 배열의 요소들을 필터링, 변환, 정렬, 집계** 등의 작업을 간결하고 효율적으로 수행할 수 있도록 설계되었습니다.

---
 ✅ Stream의 주요 특징

1. **선언형 처리 방식**
    
    - 반복문 없이 `filter`, `map`, `reduce` 등의 메서드로 데이터를 처리합니다.
        
    - 코드가 간결하고 가독성이 좋습니다.
        
2. **중간 연산과 최종 연산**
    
    - **중간 연산**: `filter`, `map`, `sorted` 등 → Stream을 반환
        
    - **최종 연산**: `collect`, `forEach`, `count`, `reduce` 등 → 결과를 반환하거나 처리 종료
        
3. **지연(Lazy) 연산**
    
    - 중간 연산은 실제로 결과를 필요로 할 때(최종 연산 시점) 실행됩니다.
        
4. **병렬 처리 지원**
    
    - `.parallelStream()`을 사용하면 멀티코어 CPU에서 병렬로 처리할 수 있습니다.
        

---
✅ 예제

```java
List<String> names = Arrays.asList("Alice", "Bob", "Charlie");

List<String> result = names.stream()
    .filter(name -> name.length() > 3)
    .map(String::toUpperCase)
    .collect(Collectors.toList());

System.out.println(result); // [ALICE, CHARLIE]

```
 ✅ 주요 메서드 설명

| 메서드                    | 설명                |
| ---------------------- | ----------------- |
| `filter(Predicate)`    | 조건에 맞는 요소만 남김     |
| `map(Function)`        | 요소를 다른 형태로 변환     |
| `sorted()`             | 정렬                |
| `distinct()`           | 중복 제거             |
| `limit(n)` / `skip(n)` | 앞에서 n개 가져오거나 건너뜀  |
| `collect()`            | 결과를 리스트, 셋 등으로 수집 |
| `reduce()`             | 모든 요소를 하나의 값으로 축약 |
 ✅ 주의점

- **Stream은 일회용**이며, 한 번 소비하면 다시 사용할 수 없습니다.
    
- 내부 반복 방식이므로 **디버깅이 어렵거나 성능 튜닝이 필요한 경우 주의**가 필요합니다.
    
- **null을 포함한 컬렉션 처리 시 NPE 주의**가 필요합니다.
    

 

##### Stream과 for ~ loop의 성능 차이를 비교해 주세요,
`Java Stream`과 `for-loop`의 성능 차이는 **상황에 따라 달라지며**, 다음과 같은 측면을 기준으로 비교할 수 있습니다.

---
✅ 1. **기본 성능 비교**

| 항목         | for-loop                   | Stream                      |
| ---------- | -------------------------- | --------------------------- |
| **처리 방식**  | 외부 반복 (External Iteration) | 내부 반복 (Internal Iteration)  |
| **오버헤드**   | 없음 또는 적음                   | 상대적으로 있음                    |
| **속도**     | 일반적으로 더 빠름                 | 약간 느릴 수 있음 (특히 작은 데이터)      |
| **코드 가독성** | 명령형(Imperative) 스타일        | 선언형(Declarative) 스타일 (더 깔끔) |
```java
List<Integer> list = IntStream.range(0, 1_000_000).boxed().collect(Collectors.toList());

// for-loop
long sum1 = 0;
for (int n : list) {
    sum1 += n;
}

// Stream
long sum2 = list.stream().mapToLong(i -> i).sum();

```

- 위 경우 일반적으로 **for-loop가 더 빠릅니다**.
    
- Stream은 람다 표현식, 내부 반복 등으로 **약간의 오버헤드**가 발생합니다.
    
 ✅ 2. **병렬 처리 측면**

|항목|for-loop|Stream (parallel)|
|---|---|---|
|**멀티코어 활용**|수동으로 스레드 작성 필요|`.parallelStream()`으로 간단히 가능|
|**대용량 데이터**|직접 병렬 처리 코드 작성|자동 병렬화로 성능 향상 가능|
|**병렬 안전성**|직접 제어 가능|상태 공유 없이 사용해야 안정적|

`long parallelSum = list.parallelStream()     .mapToLong(i -> i)     .sum();`

- 데이터가 **충분히 크고**, **연산이 독립적**이라면 `parallelStream()`이 **for-loop보다 빠를 수 있습니다**.
    

---
✅ 3. **성능 비교 정리**

|조건|더 적합한 방식|
|---|---|
|작은 데이터셋 / 성능 중요|`for-loop` (낮은 오버헤드)|
|복잡한 변환 / 필터링 / 가독성|`Stream` (선언적이고 간결)|
|병렬 처리 필요|`parallelStream` (멀티코어 활용)|
|디버깅이나 세밀한 제어 필요|`for-loop` (유연한 흐름 제어)|

---
✅ 결론

- **Stream은 가독성과 유지보수에 강점**이 있으나, **성능 면에서는 for-loop보다 느릴 수 있습니다.**
    
- 단, **데이터가 크고 병렬성이 높은 작업**에서는 `parallelStream`이 **for-loop보다 빠를 수 있습니다**.
    
- **성능이 중요한 핵심 로직에서는 반드시 성능 테스트 후 선택**하는 것이 좋습니다. (`JMH` 추천)
##### Stream은 병렬처리 할 수 있나요?
네, **Java Stream은 병렬 처리(parallel processing)를 지원합니다.**  
바로 `.parallelStream()` 또는 `.parallel()` 메서드를 사용하면 여러 CPU 코어를 활용한 병렬 연산을 수행할 수 있습니다.

---
✅ 병렬 스트림 사용법
```java
List<Integer> list = IntStream.rangeClosed(1, 1_000_000).boxed().toList();

// 병렬 처리: sum
long sum = list.parallelStream()
    .mapToLong(i -> i)
    .sum();

```

- 위 코드는 리스트를 여러 스레드로 나눠 병렬로 `sum()` 연산을 수행합니다.
    
- 내부적으로는 **Fork/Join 프레임워크**를 사용합니다.
    

---
✅ 병렬 스트림의 특징

| 항목              | 설명                                              |
| --------------- | ----------------------------------------------- |
| **자동 스레드 분할**   | Stream이 알아서 적절한 스레드 수와 작업 분할 수행                 |
| **멀티코어 CPU 활용** | 작업을 여러 코어에 분산 실행                                |
| **비결정적 순서**     | 연산 순서가 보장되지 않음 (단 `forEachOrdered()`는 순서 보장)    |
| **상태 공유 금지**    | 상태 변경이 있는 연산은 병렬 스트림에서 안전하지 않음 (side-effect 지양) |

---
✅ 주의사항

- **작은 데이터**나 **단순한 연산**에서는 오히려 `.parallelStream()`이 느릴 수 있습니다.  
    → 스레드 분할/병합 비용이 더 클 수 있음
    
- **상태 공유(stateful)** 연산은 주의 필요  
    → 예: `forEach()` 내에서 외부 리스트에 `add()`하면 race condition 발생 가능
    
- `Collectors.toList()` 등 수집 작업도 병렬 안전하게 설계되어 있어야 함
    

---
✅ 병렬 Stream 예시
```java
List<String> names = List.of("Alice", "Bob", "Charlie", "Dave");

names.parallelStream()
     .map(String::toUpperCase)
     .forEach(System.out::println); // 순서 보장 안됨

names.parallelStream()
     .map(String::toUpperCase)
     .forEachOrdered(System.out::println); // 순서 보장

```
 ✅ 요약

|질문|답변|
|---|---|
|**Stream에서 병렬 처리 가능?**|✅ 예, `.parallelStream()` 또는 `.parallel()` 사용|
|**성능 이점?**|✅ 데이터가 크고 독립적 연산이면 성능 향상|
|**주의할 점?**|⚠️ 상태 공유 금지, 순서 비결정성, 작은 데이터는 오히려 느릴 수 있음|
##### Stream에서 사용할 수 있는 함수형 인터페이스에 대해 설명해 주세요.
Java Stream API는 **함수형 인터페이스(Functional Interface)**를 기반으로 동작합니다. 이 인터페이스들은 **람다 표현식**이나 **메서드 참조**와 함께 사용되며, `Stream`에서 각 요소를 처리하는 역할을 합니다.

다음은 **Stream에서 자주 사용되는 함수형 인터페이스 4가지**입니다:

---
✅ 1. `Predicate<T>`

- **역할**: `boolean` 값을 반환하는 **조건 검사 함수**
    
- **사용처**: `filter()`, `allMatch()`, `anyMatch()` 등에서 사용
    
- **함수형 메서드**: `boolean test(T t)`
    
 예시
```java
Stream.of("apple", "banana", "carrot")
    .filter(s -> s.startsWith("a")) // Predicate<String>
    .forEach(System.out::println);  // 출력: apple

```
✅ 2. `Function<T, R>`

- **역할**: `T` 타입을 받아서 `R` 타입으로 **변환하는 함수**
    
- **사용처**: `map()`, `flatMap()` 등에서 사용
    
- **함수형 메서드**: `R apply(T t)`
    

예시
```java
Stream.of("apple", "banana")
    .map(s -> s.length()) // Function<String, Integer>
    .forEach(System.out::println); // 출력: 5, 6

```
✅ 3. `Consumer<T>`

- **역할**: 입력 값을 받아서 **소비만 하고 반환값이 없는 함수**
    
- **사용처**: `forEach()`, `peek()` 등에서 사용
    
- **함수형 메서드**: `void accept(T t)`
    
예시

```java
Stream.of(1, 2, 3)
    .forEach(n -> System.out.println(n)); // Consumer<Integer>

```
✅ 4. `Supplier<T>`

- **역할**: 입력 없이 **값을 제공하는 함수**
    
- **사용처**: `Stream.generate()`, lazy 초기화 등에서 사용
    
- **함수형 메서드**: `T get()`
    

예시
```java
Stream.of(1, 2, 3)
    .forEach(n -> System.out.println(n)); // Consumer<Integer>

```
✅ 그 외 자주 쓰이는 확장 인터페이스

|인터페이스|설명|
|---|---|
|`UnaryOperator<T>`|`Function<T, T>`의 특수한 형태 (입출력 타입 동일)|
|`BinaryOperator<T>`|`BiFunction<T, T, T>`의 특수한 형태 (두 입력 → 하나의 같은 타입 결과)|
|`BiFunction<T, U, R>`|두 개의 입력을 받아 하나의 결과 생성|
|`BiPredicate<T, U>`|두 개의 입력을 받아 `boolean` 반환|
|`ToIntFunction<T>` 등|`int`, `long`, `double` 특화 함수 (기본형 지원)|

---
✅ 요약

| 인터페이스            | 설명            | 사용 메서드 예                 |
| ---------------- | ------------- | ------------------------ |
| `Predicate<T>`   | 조건 검사         | `filter()`, `allMatch()` |
| `Function<T, R>` | 변환            | `map()`, `flatMap()`     |
| `Consumer<T>`    | 소비 (출력, 저장 등) | `forEach()`, `peek()`    |
| `Supplier<T>`    | 값 공급          | `generate()`             |

---

Stream API의 핵심은 **함수형 인터페이스를 조합해 선언적으로 데이터를 처리하는 것**입니다.
##### 가끔 외부 변수를 사용할 때, final 키워드를 붙여서 사용하는데 왜 그럴까요? 꼭 그래야 할까요?
좋은 질문입니다. Java에서 람다식이나 익명 클래스 내부에서 외부 변수를 사용할 때 `final` 또는 **사실상 final (effectively final)**이어야 하는 이유는 다음과 같습니다.

---
✅ 왜 `final` 또는 effectively final이어야 할까?

🔸 이유: **스레드 안전성과 일관성 확보를 위해서**

람다식은 내부적으로 **익명 클래스 또는 내부 클래스로 변환**되며, 외부 변수에 접근할 때 **그 값의 복사본을 캡처**합니다.  
이때, 변수의 값이 **변하지 않아야 예측 가능한 결과를 보장**할 수 있으므로 `final` 또는 변경되지 않는 값만 허용합니다.

 ✅ 예시로 살펴보기

```java
int x = 10;

Runnable r = () -> {
    System.out.println(x); // OK: x는 effectively final
};

x = 20; // ❌ 컴파일 에러: x는 더 이상 final이 아님

```
위 코드에서 `x`를 변경하려 하면 컴파일 오류가 발생합니다. 이유는:

- 람다는 `x`의 값을 복사해서 내부에 저장
    
- 그런데 외부에서 `x`를 변경하면 **복사본과 실제 값이 달라질 위험**이 있음
    
- 이를 방지하기 위해 Java는 **변경 가능한 외부 변수는 캡처하지 못하게 막음**
    
✅ 꼭 `final`이어야 하나요?

- **아니요.** Java 8부터는 꼭 `final` 키워드를 명시하지 않아도 됩니다.
    
- 단, 그 변수는 **사실상 final (변경되지 않아야 함)**이어야 합니다.
    
```java
`String name = "Alice"; list.forEach(s -> System.out.println(name)); // OK: name은 변경되지 않음`

```

---
✅ 그럼 값을 바꾸고 싶을 때는?

값을 바꾸고 싶다면, **배열, 리스트, AtomicInteger** 같은 **참조형을 사용**해 내부 값을 변경해야 합니다.

```java
`int[] sum = {0}; list.forEach(n -> sum[0] += n); // 배열은 final이지만 내부 값은 변경 가능`

```
```java
`AtomicInteger sum = new AtomicInteger(0); list.forEach(n -> sum.addAndGet(n));`
```

---
✅ 요약

| 질문                      | 답변                                                         |
| ----------------------- | ---------------------------------------------------------- |
| 외부 변수에 왜 `final`이 필요할까? | 람다/익명 클래스가 **복사본을 캡처**하기 때문에, 값 변경 시 **혼란이나 오류**가 생길 수 있음  |
| 꼭 `final` 붙여야 하나요?      | ❌ Java 8부터는 안 붙여도 되지만, **변경은 금지되어야 함** (effectively final) |
| 변경하려면 어떻게 하나요?          | 배열, 리스트, `AtomicInteger` 등 **참조형 객체 사용**                   |

### 9. Java의 GC에 대해 설명해 주세요.
##### 설명
Java의 **GC(Garbage Collector)**는 **더 이상 사용되지 않는 메모리(객체)를 자동으로 해제**해주는 JVM의 기능입니다. 개발자가 메모리를 직접 해제하지 않아도 되도록 하여 **메모리 누수 방지**와 **안정성 향상**을 돕습니다.

---
✅ 1. GC란 무엇인가?

- **Garbage Collection**: 더 이상 참조되지 않는 객체를 **자동으로 탐지하고 제거**하는 과정
    
- GC의 목적:
    
    - 사용하지 않는 객체 제거
        
    - 메모리 회수 (heap 공간 확보)
        
    - OutOfMemoryError 방지
        

---
✅ 2. 객체는 어디에 저장되나?

Java 객체는 대부분 **힙(Heap)** 메모리에 저장되며, GC는 이 **힙 메모리 영역**을 관리합니다.  
JVM의 힙 영역은 다음과 같이 나뉩니다:

```java
Heap
├── Young Generation (Eden + Survivor)
└── Old Generation (Tenured)


```

---
✅ 3. 주요 개념

| 개념                   | 설명                                      |
| -------------------- | --------------------------------------- |
| **Young Generation** | 새로 생성된 객체가 저장됨. 대부분 금방 사라지므로 빠르게 수집     |
| **Old Generation**   | 오래 살아남은 객체가 저장됨. 크고 무거운 GC가 수행됨         |
| **Eden**             | 새 객체가 처음 할당되는 공간                        |
| **Survivor**         | Eden에서 살아남은 객체가 옮겨가는 공간 (S0, S1 두 개 존재) |
| **Tenuring**         | Survivor 영역에서 일정 횟수 이상 살아남으면 Old로 이동    |

---
✅ 4. GC의 종류 (JVM별 정책)

|GC 종류|특징|적합한 환경|
|---|---|---|
|**Serial GC**|단일 스레드, 정지 시간이 김|단일 CPU, 작은 앱|
|**Parallel GC**|멀티 스레드, Throughput 중심|병렬 처리 가능, 일반적인 서버|
|**CMS (Concurrent Mark & Sweep)**|짧은 정지 시간, 일부 병행 처리|사용자 응답 중요|
|**G1 GC**|영역을 나눠 병렬 처리 + 예측 가능한 정지 시간|대형 서비스, JVM 9+ 기본|
|**ZGC / Shenandoah**|초저지연 GC, 대부분 병렬/비동기 수행|실시간 응답이 중요한 시스템 (JDK 11+)|

---
✅ 5. GC 동작 과정 (Mark-Sweep-Compact)

1. **Mark**: 참조 가능한 객체를 모두 표시
    
2. **Sweep**: 표시되지 않은 객체 제거
    
3. **Compact**: 메모리 조각화를 줄이기 위해 객체들을 한쪽으로 압축
    

---
✅ 6. GC 튜닝의 핵심 지표

|지표|의미|
|---|---|
|**GC Pause Time**|GC로 인한 정지 시간|
|**Throughput**|GC 외 작업 수행 비율|
|**Heap Usage**|GC 빈도와 메모리 효율|
|**Object Allocation Rate**|객체 생성 속도|

→ GC 로그, `jstat`, VisualVM, GCViewer 등을 통해 분석 가능

---
✅ 요약

| 항목         | 내용                                |
| ---------- | --------------------------------- |
| **GC의 목적** | 불필요한 객체 제거로 메모리 누수 방지             |
| **관리 대상**  | 주로 힙 메모리 (Young/Old Generation)   |
| **GC 종류**  | Serial, Parallel, CMS, G1, ZGC 등  |
| **기본 방식**  | Mark → Sweep → Compact            |
| **튜닝 요소**  | Pause time, Heap size, GC 로그 분석 등 |
##### finalize() 를 수동으로 호출하는 것은 왜 문제가 될 수 있을까요?
✅ 1. `finalize()`의 원래 목적

- `Object` 클래스에 정의된 메서드로, 객체가 **GC 대상이 되기 직전**에 호출되어 **정리(clean-up) 작업**을 할 수 있게 합니다.
    
- 보통 **자원 해제**, 예: 파일 닫기, 소켓 정리 등의 목적
    
```java
@Override
protected void finalize() throws Throwable {
    try {
        // 자원 해제 코드
    } finally {
        super.finalize();
    }
}

```


> ✅ 하지만, **GC가 객체를 수거할 때만** JVM이 자동으로 호출해야 합니다.

---
❌ 수동 호출이 문제가 되는 이유

1. **객체가 GC되지 않았는데 finalize()가 호출됨**

- `finalize()`는 **객체가 더 이상 사용되지 않을 때** 호출되어야 의미가 있음.
    
- 수동 호출하면 아직 살아있는 객체를 **잘못된 상태로 만듦** (예: 자원을 닫았는데 여전히 사용 중일 수 있음).
    
2. **중복 호출 가능성**

- `finalize()`는 JVM에 의해 한 번만 호출됩니다.
    
- 수동으로 호출하면 **예상치 못한 시점에 두 번 실행**될 수 있어 예측 불가능한 동작 발생.
    
3. **자원 관리에 혼란**

- 수동 호출로 인해, 자원이 **정상적으로 해제된 것인지**, **GC에 의해 해제될 것인지** 구분이 안됨.
    
- 결과적으로 **메모리 누수** 또는 **자원 충돌**이 발생할 수 있음.
    
4. **finalize()는 deprecated**

- Java 9부터 **Deprecated**
    
- Java 18부터는 **기본적으로 제거됨**
    
- 더 안전한 방식인 `try-with-resources`나 `AutoCloseable` 인터페이스 사용 권장
    

---
✅ 권장되는 자원 정리 방법
```java
try (FileInputStream fis = new FileInputStream("test.txt")) {
    // 파일 처리
} catch (IOException e) {
    // 예외 처리
}
// 자원 자동 해제 (close 호출됨)

```

> → `Closeable` 또는 `AutoCloseable` 구현 클래스는 `try-with-resources`로 안전하게 자원을 해제할 수 있습니다.

---
✅ 요약

|항목|설명|
|---|---|
|`finalize()`는 언제 호출됨?|GC 직전에 JVM이 자동 호출|
|수동 호출의 문제점|생명주기 혼란, 중복 호출, 자원 충돌 위험|
|Java에서의 권장 방법|`AutoCloseable` + `try-with-resources` 사용|
|현재 상태|Java 9부터 deprecated, Java 18에서 제거됨|
##### 어떤 변수의 값이 null이 되었다면, 이 값은 GC가 될 가능성이 있을까요?
네, **그 변수의 값이 `null`이 되었다면**, 해당 객체는 **GC(가비지 컬렉션)의 대상이 될 가능성이 있습니다.**

단, 그 객체가 **다른 어떤 곳에서도 참조되지 않고 있어야만** 실제로 GC의 대상이 됩니다.

---
✅ 왜 `null` 할당이 GC와 관련이 있을까?

Java의 GC는 **더 이상 "참조되지 않는" 객체**를 찾아서 메모리에서 제거합니다.  
즉, 어떤 객체를 가리키던 변수가 `null`이 되면, **그 객체에 대한 참조가 하나 줄어드는 것**이고,  
그 객체를 참조하는 **모든 참조가 사라지면** GC는 이를 **쓸모없는 객체로 판단하고 수거**할 수 있습니다.

---
✅ 예시로 이해하기

```java
public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass(); // obj가 MyClass 객체를 참조
        obj = null; // 참조 해제 → GC 대상이 될 수 있음
    }
}

```
- 위 코드에서 `obj = null`로 설정한 순간,
    
- `MyClass` 객체는 **다른 참조가 없다면** → **GC 대상**이 됩니다.
    

---
✅ 주의: null로 만들어도 GC되지 않을 수 있는 경우

1. **다른 곳에서 여전히 참조 중인 경우**
    
```java
MyClass obj1 = new MyClass();
MyClass obj2 = obj1;
obj1 = null; // obj2가 여전히 참조 중 → GC 불가

```
2. **static 변수에 저장된 경우**
    
```java
static MyClass global = new MyClass(); // 프로그램 끝까지 참조됨

```

3. **ThreadLocal, WeakReference 등으로 우회 참조되는 경우**
    

---
✅ 요약

|조건|GC 대상 여부|
|---|---|
|참조가 모두 사라짐 (`null` 포함)|✅ 가능함 (GC 대상)|
|다른 참조가 남아 있음|❌ 대상 아님|
|`null`을 명시적으로 할당하면?|✅ GC 대상이 될 가능성은 높아짐, 단 반드시 그런 건 아님|

---
 🔍 참고

Java에서 `null`을 명시적으로 할당하는 것은 **GC 대상이 될 수 있도록 힌트를 주는 것**이지,  
**즉시 GC가 발생하거나 보장되는 것은 아닙니다.**  
GC는 JVM이 **적절한 시점**에 실행합니다.

### 10. equals()와 hashcode()에 대해 설명해 주세요.
##### 설명
`equals()`와 `hashCode()`는 Java의 모든 객체가 상속받는 `Object` 클래스에 정의된 **핵심 메서드**로,  
**객체 비교**와 **해시 기반 컬렉션(HashMap, HashSet 등)**의 동작에 **직접적인 영향을 미칩니다.**

---
✅ 1. `equals()` 메서드

📌 역할:

- 두 객체가 **논리적으로 동일한지 비교**
    
- 기본 구현은 `==` (즉, **주소 비교**)와 동일
    

📌 보통은 오버라이딩해서 사용

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return age == person.age && name.equals(person.name);
}

```

---
✅ 2. `hashCode()` 메서드

📌 역할:

- 객체의 **해시 값을 반환** (정수값)
    
- **HashMap, HashSet, Hashtable** 등에서 **객체를 저장하거나 조회할 때 사용하는 키 값 계산**
    
```java
@Override
public int hashCode() {
    return Objects.hash(name, age);
}

```
✅ 3. `equals()`와 `hashCode()`의 관계

> **"equals()가 true면, hashCode()는 반드시 같아야 한다."**

📌 규칙

- `x.equals(y) == true` → `x.hashCode() == y.hashCode()` ✅ 반드시 만족해야 함
    
- 하지만 `x.hashCode() == y.hashCode()` → `x.equals(y)`는 ❌ 반드시 true일 필요는 없음 (충돌 가능)
    

---
✅ 4. 왜 중요할까?

해시 기반 컬렉션(`HashMap`, `HashSet`)에서 **정확한 동작을 위해 반드시 함께 오버라이드**해야 함.

예시:
```java
Set<User> users = new HashSet<>();
users.add(new User("Alice", 20));
System.out.println(users.contains(new User("Alice", 20))); // equals, hashCode 오버라이드 안 하면 false!

```
---
 ✅ 5. 오버라이드 시 주의사항

- `equals()`에서는 `null`과 `instanceof` 체크 반드시 포함
    
- `hashCode()`는 `equals()`에서 비교하는 필드를 기준으로 생성해야 함
    
- `hashCode()`는 가능한 한 **충돌이 적도록 설계**
    

---
✅ 요약

|항목|설명|
|---|---|
|`equals()`|객체의 **논리적 동등성** 비교|
|`hashCode()`|해시 기반 자료구조를 위한 **정수값 식별자**|
|함께 오버라이딩 이유|`HashSet`, `HashMap`의 일관성 보장|
|규칙|`equals() == true → hashCode() == 같음` 반드시 만족|

##### 본인이 hashcode() 를 정의해야 한다면, 어떤 점을 염두에 두고 구현할 것 같으세요?
좋은 질문입니다. `hashCode()`를 직접 정의해야 한다면, 다음과 같은 **원칙과 실용적 고려사항**을 반드시 염두에 두고 구현할 것입니다.

---
✅ 1. **equals()와 일관성 유지 (가장 중요)**

> "두 객체가 `equals()`로 같다면, `hashCode()`도 같아야 한다."

- 비교 대상이 되는 필드(예: `id`, `name`, `email` 등)를 기준으로 `hashCode()`도 계산해야 합니다.
    
- 그렇지 않으면 `HashMap`, `HashSet` 등의 컬렉션에서 의도대로 동작하지 않습니다.
    

---
 ✅ 2. **불변성 보장**

- 객체가 컬렉션에 저장된 후 `hashCode()` 값이 바뀌면, 해당 객체를 **찾을 수 없게 됩니다.**
    
- 따라서, `hashCode()` 계산에 사용하는 필드는 **불변(immutable)** 필드로 선택합니다.
    
예: `ID`, 생성 시 설정되는 `UUID`, 혹은 `final` 필드 등

---
 ✅ 3. **충돌 최소화 (균등한 분포)**

- 다른 객체끼리는 **가능하면 서로 다른 hashCode 값을** 갖도록 설계해야 합니다.
    
- 충돌이 많아지면 해시 테이블의 성능이 **선형 탐색 수준으로 저하**될 수 있습니다.
    

✅ 4. **적절한 해시 조합 공식 사용**

- 자주 사용하는 방식: `Objects.hash(...)`, 또는 `31 * result + field.hashCode()` 패턴
    
```java
@Override
public int hashCode() {
    return Objects.hash(name, age); // Java 7+
}
@Override
public int hashCode() {
    int result = name != null ? name.hashCode() : 0;
    result = 31 * result + age;
    return result;
}

```

> `31`은 소수이고 곱셈 연산에서 좋은 분산을 만들어내는 상수로 널리 사용됩니다.

---
✅ 5. null 안전성 고려

- `null` 필드는 `0` 또는 별도의 처리 필요

 ✅ 요약: 내가 `hashCode()`를 정의할 때 고려할 점

| 고려 항목           | 설명                              |
| --------------- | ------------------------------- |
| `equals()`와 일관성 | 같다고 판단되는 객체는 같은 해시값             |
| 불변 필드 사용        | 해시값이 바뀌지 않도록                    |
| 충돌 최소화          | 다른 객체는 다른 해시값                   |
| null 처리         | NPE 방지                          |
| 성능과 가독성         | `Objects.hash()` 또는 31 곱셈 패턴 사용 |
##### 그렇다면 equals() 를 재정의 해야 할 때, 어떤 점을 염두에 두어야 하는지 설명해 주세요.
좋은 질문입니다. `equals()` 메서드를 재정의해야 할 때는, 단순히 두 객체가 "같다"는 의미를 넘어 **일관성 있고 신뢰할 수 있는 동작을 보장**해야 합니다. 아래는 재정의 시 반드시 염두에 두어야 할 핵심 사항들입니다.

---
 ✅ 1. **`equals()` 메서드의 기본 규약 (Contract)**

Java의 `Object` 클래스가 요구하는 5가지 규칙은 다음과 같습니다:

| 규칙                   | 설명                                                  |
| -------------------- | --------------------------------------------------- |
| **반사성 (Reflexive)**  | `x.equals(x)`는 항상 true                              |
| **대칭성 (Symmetric)**  | `x.equals(y)`이면 `y.equals(x)`도 true                 |
| **추이성 (Transitive)** | `x.equals(y)`이고 `y.equals(z)`이면 `x.equals(z)`도 true |
| **일관성 (Consistent)** | 여러 번 호출해도 결과가 항상 같아야 함 (값이 변하지 않는 한)                |
| **null에 대한 비대칭성**    | `x.equals(null)`은 항상 false                          |

> 이 규약을 지키지 않으면, `HashMap`, `HashSet`, `List.contains()` 등의 동작이 예측 불가능해집니다.

---
✅ 2. **비교 기준이 되는 필드 일관성 유지**

- `equals()`는 **논리적으로 객체가 같은지 비교하는 메서드**이므로, 비교에 사용할 필드를 신중하게 선택해야 합니다.
    
- 보통 **식별자(id)**, **불변 필드**, **주요 속성** 등을 기준으로 합니다.
    

✅ 3. **`hashCode()`와 항상 함께 재정의**

> `equals()`를 재정의하면 반드시 `hashCode()`도 재정의해야 합니다.

그렇지 않으면 `equals()`는 true인데 `hashCode()`가 다르게 되어,  
`HashSet`, `HashMap` 등에선 **정상적으로 동작하지 않습니다.**

---
✅ 4. **클래스 타입 비교 방법**

- 안전한 방식: `getClass()` 사용 (같은 클래스일 때만 equal)
    
- 유연한 방식: `instanceof` 사용 (상속 관계 포함 가능)
    
```java
// getClass 방식: 대칭성 보장에 안전
if (getClass() != o.getClass()) return false;

```
✅ 5. **성능과 null 안전성 고려**

- `Objects.equals(a, b)`를 사용하면 `null` 비교도 안전하게 처리됩니다.
    


`Objects.equals(this.name, other.name);`

---
✅ 요약: equals() 재정의 시 체크리스트

|항목|설명|
|---|---|
|✅ 반사성/대칭성/추이성 등 규약 준수|Java가 보장하는 동작의 전제|
|✅ 주요 필드를 기준으로 비교|주로 식별자, 불변 필드|
|✅ `hashCode()`도 함께 재정의|컬렉션에서 일관된 동작 보장|
|✅ 클래스 타입 비교 명확히|`getClass()` 또는 `instanceof` 선택|
|✅ null 안전성 고려|`Objects.equals()` 활용 권장|

### 11. IoC와 DI에 대해 설명해 주세요.
##### 설명
IoC와 DI는 객체 지향 프로그래밍과 스프링(Spring) 같은 프레임워크에서 매우 중요한 개념입니다. 두 개념은 밀접하게 관련되어 있으나 의미는 다릅니다. 아래에서 개념과 차이, 예시를 통해 명확히 설명하겠습니다.

---
✅ 1. IoC (Inversion of Control, 제어의 역전)

📌 개념:

- **객체 생성과 의존성 관리의 주도권(제어권)을 개발자 → 프레임워크로 넘기는 것**
    
- 즉, **누가 무엇을 제어하느냐가 바뀌는 것**입니다.
    

📌 예전 방식 (제어권: 개발자)

`UserService service = new UserService(new UserRepository());`

📌 IoC 적용 (제어권: 프레임워크)

> 프레임워크가 객체를 생성하고 필요한 의존성을 주입하며, 객체 간의 관계를 설정함

---
 ✅ 2. DI (Dependency Injection, 의존성 주입)
 📌 개념:

- IoC의 **구현 방법 중 하나**
    
- 어떤 객체가 필요로 하는 **의존 객체를 외부에서 주입**받는 방식
    
 📌 DI 종류

| 방법         | 설명                              |
| ---------- | ------------------------------- |
| **생성자 주입** | 생성자를 통해 의존성 전달 (불변성 보장, 테스트 용이) |
| **세터 주입**  | 세터 메서드로 주입 (선택적 의존성)            |
| **필드 주입**  | 필드에 직접 주입 (`@Autowired`, 권장 X)  |


---
 ✅ 3. IoC vs DI

| 구분     | IoC                   | DI                           |
| ------ | --------------------- | ---------------------------- |
| **의미** | 제어권을 프레임워크로 넘기는 개념    | 의존성을 외부에서 주입하는 방식            |
| **범위** | 포괄적인 설계 철학            | IoC를 구현하는 구체적 수단             |
| **예시** | 객체 생성/초기화를 Spring이 담당 | `@Autowired`, 생성자, 세터 등으로 주입 |

---
 ✅ 4. 예시 (Spring 기반)

 📌 일반적인 DI 코드
```java
@Component
public class UserService {

    private final UserRepository userRepository;

    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}

```
- `UserService`는 `UserRepository`에 의존
    
- 프레임워크(Spring)가 `UserRepository`를 생성해서 `UserService`에 **주입**해줌
    
- 이 전체 과정은 **IoC 컨테이너가 제어권을 가지며**, DI는 **구체적인 주입 행위**
    

---
✅ 요약

| 개념               | 설명                                            |
| ---------------- | --------------------------------------------- |
| **IoC**          | 객체 생성 및 제어권을 프레임워크가 갖는 구조                     |
| **DI**           | 외부에서 필요한 의존 객체를 주입하는 방법                       |
| **관계**           | DI는 IoC의 구현 방식 중 하나                           |
| **Spring에서의 구현** | `@Component`, `@Autowired`, `@Bean`, 생성자 주입 등 |

##### 후보 없이 특정 기능을 하는 클래스가 딱 한 개하면, 구체 클래스를 그냥 사용해도 되지 않나요? 그럼에도 불구하고 왜 Spring에선 Bean을 사용 할까요?
그럼에도 불구하고 **Spring에서 Bean으로 등록해서 사용하는 이유**는 단순히 “대체 가능성” 때문만이 아니라, **아키텍처적 유연성과 핵심 기능 활용** 때문입니다. 아래에서 차근차근 설명드리겠습니다.

---
 ✅ 1. 지금은 하나지만, 나중엔 바뀔 수 있기 때문

- 현재는 구현체가 하나뿐이지만, 시간이 지나면서 요구사항이 늘어나고 다양한 구현이 필요해질 수 있습니다.
    
    - 예: `EmailNotificationService` → 나중엔 `SmsNotificationService`, `PushNotificationService` 추가될 수 있음
        
- 이때 **DI로 설계되어 있다면 구조 변경이 최소화**됩니다.
    

 ✅ 2. Spring의 핵심 기능을 쓰기 위해서 (프레임워크 통합)

Bean으로 등록하면 다음과 같은 **Spring의 기능**들을 사용할 수 있습니다:

| 기능               | 설명                        |
| ---------------- | ------------------------- |
| `@Transactional` | 트랜잭션 자동 관리                |
| `@Async`         | 비동기 실행                    |
| `@Scheduled`     | 스케줄링                      |
| AOP              | 로깅, 보안, 성능 측정 등 횡단 관심사 처리 |
| 프록시 기반 확장        | 실제 구현체를 감싸서 기능 추가 가능      |

→ 일반 클래스 직접 사용하면 이 기능들을 **적용할 수 없습니다.**

---
 ✅ 3. 테스트 용이성

- DI 구조에서는 **Mock 또는 Stub을 쉽게 주입할 수 있습니다.**
    
- 반면 직접 생성하면 테스트가 어렵고, **결합도가 높아집니다.**
    
```java
// 나중에 쉽게 바꿀 수 있음
@Autowired
NotificationService notificationService;

```
 ✅ 4. 생명주기 및 리소스 관리

- Spring은 Bean의 **생성, 초기화, 소멸까지 생명주기를 관리**합니다.
    
- 예: DB 커넥션 풀, 쓰레드풀, 캐시 초기화 등 → 일반 객체로 만들면 수동 관리해야 함
    

---
 ✅ 5. 의존성 자동 주입 및 설정 분리

- Bean을 사용하면 설정을 외부로 분리하고, 구성요소를 동적으로 바꿀 수 있습니다.
    
- `@Profile`, `@Conditional`, `@Value` 등을 이용해 **환경에 따라 유연한 설정** 가능
    

---
 ✅ 요약: 왜 Spring에서는 Bean으로 관리할까?

| 이유                  | 설명                     |
| ------------------- | ---------------------- |
| 확장성                 | 나중에 구현체가 늘어나도 쉽게 대체 가능 |
| AOP/트랜잭션 등 핵심 기능 사용 | Spring이 내부적으로 프록시로 감쌈  |
| 테스트 용이성             | Mock 주입 가능 (DI)        |
| 생명주기 관리             | 객체의 생성~소멸까지 통제         |
| 환경 유연성              | 설정 기반으로 동적으로 선택 가능     |

---
 🔎 결론

> **“지금 하나니까 그냥 쓰자”는 단기적 판단이고, Bean으로 관리하면 ‘유연한 설계’와 ‘Spring의 기능’을 제대로 활용할 수 있는 구조가 됩니다.**

즉, Bean 등록은 단순한 기술적인 선택이 아니라, **좋은 아키텍처를 위한 기반 설계**라고 볼 수 있습니다.
##### Spring의 Bean 생성 주기에 대해 설명해 주세요.
Spring의 Bean 생성 주기(생명주기, Bean Lifecycle)는 **Bean이 컨테이너에 등록되고 소멸되기까지 거치는 단계들**을 의미합니다. 이 과정은 Spring이 **의존성 주입과 초기화, 정리 작업을 자동으로 관리**할 수 있게 해줍니다.

---
 ✅ Spring Bean 생성 주기 (Lifecycle)

1. **Bean 정의 확인 (BeanDefinition 생성)**
    
    - `@Component`, `@Bean`, XML 설정 등에서 Bean 정의를 읽어들임
        
2. **Bean 인스턴스 생성** (`new`)
    
    - 객체 생성 (리플렉션으로 생성자 호출)
        
3. **의존성 주입 (Dependency Injection)**
    
    - `@Autowired`, 생성자, 세터 등을 통해 필요한 의존 객체 주입
        
4. **Aware 인터페이스 호출 (선택적)**
    
    - `BeanNameAware`, `BeanFactoryAware`, `ApplicationContextAware` 등
        
    - 자신이 컨테이너 안에서 어떤 Bean인지, 어떤 환경인지 알 수 있음
        
5. **초기화 콜백 호출 (초기화 작업)**
    
    - `@PostConstruct`
        
    - `InitializingBean.afterPropertiesSet()`
        
    - `@Bean(initMethod="...")` 지정 등
        
6. **Bean 사용 (애플리케이션에서 동작)**
    
    - 컨테이너에서 getBean하거나 주입되어 실제 사용됨
        
7. **소멸 콜백 호출 (컨테이너 종료 시)**
    
    - `@PreDestroy`
        
    - `DisposableBean.destroy()`
        
    - `@Bean(destroyMethod="...")` 지정 등
        

---
 ✅ 시각화

`[정의 → 생성 → 주입 → 초기화 → 사용 → 소멸]`

---
 ✅ Bean 초기화 & 소멸 방법 요약

|방식|초기화|소멸|
|---|---|---|
|애노테이션|`@PostConstruct`|`@PreDestroy`|
|인터페이스|`InitializingBean`|`DisposableBean`|
|XML/Java 설정|`initMethod`|`destroyMethod`|

---
 ✅ 예시 코드

```java
@Component
public class MyService implements InitializingBean, DisposableBean {

    @PostConstruct
    public void postConstruct() {
        System.out.println("PostConstruct 초기화");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("InitializingBean 초기화");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("PreDestroy 정리");
    }

    @Override
    public void destroy() {
        System.out.println("DisposableBean 정리");
    }
}

```
✅ 요약

|단계|설명|
|---|---|
|정의|어떤 클래스를 Bean으로 쓸지 인식 (`@Component`, `@Bean`)|
|생성|객체를 인스턴스화|
|의존성 주입|필요한 다른 Bean 주입|
|초기화|`@PostConstruct`, `afterPropertiesSet()`|
|사용|애플리케이션이 사용|
|소멸|`@PreDestroy`, `destroy()`|

---

##### 프로토타입 빈은 무엇인가요?
Spring에서 **프로토타입(Prototype) 빈**은 **요청할 때마다 새로운 인스턴스를 생성하는 Bean 범위(scope)**입니다.  
기본적으로 Spring Bean은 **싱글톤(Singleton)**으로 관리되지만, 필요에 따라 프로토타입 스코프로 설정할 수 있습니다.

---
 ✅ 1. 프로토타입(Prototype) 빈이란?

- **싱글톤 빈**: 컨테이너 시작 시 1개만 생성, 모든 요청에 동일 객체 반환
    
- **프로토타입 빈**: **`getBean()` 호출 시마다 새 객체 생성**
    
```java
@Component
@Scope("prototype")  // 또는 @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
public class MyPrototypeBean {
    ...
}

```
 ✅ 2. 특징

| 항목         | 설명                                      |
| ---------- | --------------------------------------- |
| **생성 시점**  | `getBean()` 호출할 때마다 새 인스턴스 생성           |
| **관리 범위**  | 생성 및 의존성 주입까지만 Spring이 관리 (소멸은 직접 해야 함) |
| **재사용 여부** | ❌ 항상 새로 생성됨                             |
| **대표 예시**  | 상태가 독립적인 객체, 임시 계산기, 사용자 세션 단위 객체 등     |

---
✅ 3. 사용 예시

```java
@Component
@Scope("prototype")
public class SessionData {
    private final UUID id = UUID.randomUUID();

    public UUID getId() {
        return id;
    }
}

ApplicationContext context = ...
SessionData s1 = context.getBean(SessionData.class);
SessionData s2 = context.getBean(SessionData.class);
System.out.println(s1 == s2); // false (다른 인스턴스)

```
 ✅ 4. 주의사항

❗ 의존성 주입 시 주의 (싱글톤 → 프로토타입)

- 프로토타입 빈을 싱글톤 빈에서 주입받으면 **초기 1회만 생성됨** (즉, 계속 같은 객체)
    
🔧 해결 방법

1. **`ObjectProvider<T>` 또는 `Provider<T>` 사용**
    
```java
@Component
public class SingletonBean {
    @Autowired
    private ObjectProvider<MyPrototypeBean> provider;

    public void logic() {
        MyPrototypeBean prototype = provider.getObject();
    }
}

```
1. **`@Lookup` 애노테이션**
```java
@Component
public class SingletonBean {
    @Lookup
    public MyPrototypeBean getPrototypeBean() {
        return null; // 런타임에 오버라이딩됨
    }
}

```
✅ 5. 프로토타입 빈의 소멸 처리 주의

- Spring은 **생성까지만 관리**하고 `@PreDestroy` 같은 **소멸 콜백을 호출하지 않습니다.**
    
- 필요한 경우 **직접 종료 처리**해야 함.
    

---
 ✅ 요약

|항목|설명|
|---|---|
|스코프 이름|`"prototype"`|
|생성 시점|매번 요청 시 새 인스턴스|
|용도|상태를 가지는 독립적인 객체 필요할 때|
|단점|소멸 관리 책임이 사용자에게 있음|
|싱글톤과 함께 사용할 때|`ObjectProvider`, `@Lookup` 등으로 해결|

### 12. AOP에 대해 설명해 주세요.
##### 설명
AOP(Aspect-Oriented Programming, 관점 지향 프로그래밍)는  
**공통 관심사(Cross-Cutting Concerns)**를 **핵심 로직과 분리하여 모듈화하는 프로그래밍 패러다임**입니다.  
주로 **로깅, 보안, 트랜잭션, 성능 측정, 예외 처리** 같은 기능을 핵심 비즈니스 코드와 분리하기 위해 사용됩니다.

---
 ✅ 왜 AOP가 필요한가요?

**기존 OOP만으로는 공통 기능을 여러 클래스에 반복적으로 작성해야 함**

 ❌ OOP만 사용하는 경우 (중복 발생)

```java
public void placeOrder() {
    log.info("주문 시작"); // 공통 관심사
    ... // 주문 처리 로직
    log.info("주문 완료");
}

```

 ✅ AOP를 사용하는 경우

```java
@Around("execution(* com.myapp.service.*.*(..))")
public Object logExecutionTime(ProceedingJoinPoint joinPoint) throws Throwable {
    log.info("메서드 시작");
    Object result = joinPoint.proceed();
    log.info("메서드 끝");
    return result;
}

```
→ 핵심 로직은 그대로 유지되며, **공통 기능은 분리된 AOP 모듈로 관리**

---
 ✅ 핵심 개념

| 용어             | 설명                                           |
| -------------- | -------------------------------------------- |
| **Aspect**     | 공통 관심사를 모듈화한 클래스 (`@Aspect`)                 |
| **Join Point** | Aspect가 적용 가능한 지점 (ex. 메서드 호출 시점)            |
| **Advice**     | Join Point에서 수행될 코드 (실제 실행 로직)               |
| **Pointcut**   | Advice를 적용할 Join Point를 선정하는 표현식             |
| **Weaving**    | Aspect를 실제 코드에 적용하는 과정 (컴파일/런타임/클래스 로딩 시점 등) |

---
 ✅ Advice 종류

|타입|설명|
|---|---|
|`@Before`|메서드 실행 **전** 실행|
|`@After`|메서드 실행 **후(무조건)** 실행|
|`@AfterReturning`|메서드가 **정상 종료**되었을 때 실행|
|`@AfterThrowing`|**예외 발생** 시 실행|
|`@Around`|메서드 **전후** 모두 처리 가능 (`joinPoint.proceed()`로 핵심 로직 호출)|

---
 ✅ Spring AOP vs AspectJ

|구분|설명|
|---|---|
|**Spring AOP**|프록시 기반, 메서드 단위만 지원, DI 환경에 통합|
|**AspectJ**|바이트코드 조작 기반, 더 정밀한 weaving 가능, 독립 사용 가능|

 ✅ 요약

|항목|설명|
|---|---|
|정의|공통 관심사를 모듈화하여 핵심 로직과 분리하는 기법|
|장점|코드 중복 제거, 관심사 분리, 유지보수 용이|
|사용 사례|트랜잭션, 로깅, 보안, 캐싱, 예외 처리|
|핵심 개념|Aspect, JoinPoint, Advice, Pointcut, Weaving|
|Spring AOP|프록시 기반, 런타임에 적용됨|
##### @Aspect는 어떻게 동작하나요?
좋은 질문입니다.  
`@Aspect`는 **Spring AOP에서 공통 관심사를 구현하는 핵심 어노테이션**입니다.  
이 어노테이션이 어떻게 동작하는지 이해하려면, **프록시 기반의 AOP 처리 방식**과 **스프링 컨테이너 내부 처리 흐름**을 함께 살펴봐야 합니다.

---
✅ 핵심 요약:

`@Aspect`가 붙은 클래스는 **Spring이 자동으로 프록시 객체를 만들어**,  
**지정한 Pointcut에 Advice를 삽입**하는 방식으로 동작합니다.

---
 ✅ 동작 흐름 요약 (Spring AOP)

1. **`@Aspect` 클래스 스캔**
    
    - `@EnableAspectJAutoProxy` 또는 Spring Boot의 자동 설정에 의해,
        
    - `@Aspect`가 붙은 클래스를 **빈으로 등록**하고 AOP 대상으로 인식함
        
2. **Pointcut 분석**
    
    - `execution(...)`, `within(...)`, `@annotation(...)` 등의 표현식을 분석해,
        
    - 어떤 **JoinPoint(=대상 메서드)**에 Advice를 적용할지 결정
        
3. **프록시 생성**
    
    - 대상 객체(Bean)에 대한 **프록시(Proxy) 객체**를 생성
        
        - **인터페이스 기반**이면 → JDK 동적 프록시
            
        - **클래스 기반**이면 → CGLIB 프록시
            
4. **Advice 연결**
    
    - 프록시 객체의 메서드가 호출되면,
        
    - 설정한 Pointcut 조건에 맞는 Advice(`@Before`, `@After`, `@Around` 등)가 **실행 순서에 따라 호출**됨
        
    - 이후 **원래 메서드 호출** (`joinPoint.proceed()`)
        

---
 ✅ 그림으로 이해 (예시: `@Around`)
```
[Client Code] 
    ↓
[프록시 객체]
    ↓  (1) @Before
    ↓  (2) @Around (joinPoint.proceed())
    ↓  (3) 원래 Bean의 메서드 실행
    ↑  (4) @AfterReturning 또는 @AfterThrowing
    ↑  (5) @After

```
 ✅ 예제 코드
```java
@Aspect
@Component
public class LoggingAspect {
 
    @Around("execution(* com.example.service.*.*(..))")
    public Object log(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("Before: " + joinPoint.getSignature());
        Object result = joinPoint.proceed(); // 실제 메서드 호출
        System.out.println("After: " + joinPoint.getSignature());
        return result;
    }
}

```
 ✅ 주의할 점

| 항목                       | 주의 내용                           |
| ------------------------ | ------------------------------- |
| **private 메서드에는 적용 안 됨** | 프록시 기반이므로 public 메서드만 가능        |
| **자기 자신 내부 호출에는 적용 안 됨** | this 내부 호출은 프록시 우회 → AOP 안 먹힘   |
| **final 클래스/메서드는 제한 있음** | CGLIB은 final 메서드 오버라이딩 불가       |
| **빈으로 등록되어야 동작**         | `@Component` 또는 `@Bean`으로 등록 필요 |

---
 ✅ 요약

| 항목          | 설명                                            |
| ----------- | --------------------------------------------- |
| `@Aspect`란? | 공통 관심사를 모듈화한 클래스 정의용 어노테이션                    |
| 동작 방식       | Spring이 프록시 객체를 만들어 Advice를 삽입                |
| 핵심 기술       | JDK Proxy 또는 CGLIB, `@EnableAspectJAutoProxy` |
| 트리거 시점      | Pointcut으로 지정한 JoinPoint가 호출될 때               |
| 주의사항        | 프록시 기반 특성: 자기 호출, private, final 등 제한         |


### 13. Spring 에서 Interceptor와 Servlet Filter에 대해 설명해 주세요.
##### 설명
Spring에서 **Interceptor**와 **Servlet Filter**는 모두 HTTP 요청/응답의 흐름을 가로채서 공통 처리를 할 수 있는 기능이지만, 동작 시점과 적용 범위, 사용 목적에서 차이가 있습니다.

---
1. Servlet Filter

**(서블릿 스펙의 기능, Spring 프레임워크 밖에서 동작)**

특징

- **Servlet API**에 정의된 표준 기능 → `javax.servlet.Filter` 구현.
    
- **DispatcherServlet** 실행 전/후에 동작 (즉, 스프링 MVC 전 단계에서 요청과 응답을 가로챔).
    
- Spring뿐 아니라 모든 서블릿 기반 애플리케이션에서 동작.
    
- **주요 용도**
    
    - 요청/응답 로깅
        
    - 인코딩 설정 (`CharacterEncodingFilter`)
        
    - CORS 처리 (`CorsFilter`)
        
    - 보안 관련 체크 (XSS 방지, 인증 토큰 검증 등)
        
    - 요청 래핑/변환
        
- **동작 구조**
    
    sql
    
    복사편집
    
    `클라이언트 → Filter → DispatcherServlet → Controller → View → Filter → 클라이언트`
    
구현 예시
```java
@WebFilter(urlPatterns = "/*")
public class MyFilter implements Filter {
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        System.out.println("Filter: Before request");
        chain.doFilter(request, response);
        System.out.println("Filter: After response");
    }
}

```

---
2. Spring Interceptor

**(Spring MVC 기능, DispatcherServlet 이후 동작)**

특징

- Spring MVC 전용 기능 → `HandlerInterceptor` 인터페이스 구현.
    
- **Handler(Controller)** 호출 전/후, View 렌더링 전 단계에서 동작.
    
- Spring 컨텍스트 내부에서 동작하므로 **Spring Bean** 의존성 주입 가능.
    
- **주요 용도**
    
    - 로그인 여부 체크
        
    - 권한(Authorization) 검사
        
    - 컨트롤러에 전달될 데이터 가공
        
    - Controller 실행 전후 로깅
        
    - 특정 URI 접근 제한
        
- **동작 구조**
    
    scss
    
    복사편집
    
    `클라이언트 → Filter → DispatcherServlet    → Interceptor preHandle() → Controller   → Interceptor postHandle() → View   → Interceptor afterCompletion() → Filter → 클라이언트`
    
구현 예시
```java
public class MyInterceptor implements HandlerInterceptor {
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        System.out.println("Interceptor: Before Controller");
        return true; // false 반환 시 이후 흐름 중단
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response,
                           Object handler, ModelAndView modelAndView) {
        System.out.println("Interceptor: After Controller, before View");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response,
                                Object handler, Exception ex) {
        System.out.println("Interceptor: After View rendering");
    }
}

```

---
3. 주요 차이점 정리

| 구분                 | Servlet Filter                           | Spring Interceptor                       |
| ------------------ | ---------------------------------------- | ---------------------------------------- |
| **소속**             | Servlet 표준 스펙                            | Spring MVC                               |
| **실행 시점**          | DispatcherServlet **전/후**                | DispatcherServlet 내부, Controller **전/후** |
| **적용 범위**          | 모든 요청(정적 리소스 포함)                         | Spring MVC Handler(Controller) 요청만       |
| **Spring Bean 사용** | 불가능(직접 DI 불가)                            | 가능                                       |
| **대표 예시**          | 인코딩 필터, CORS 필터, XSS 필터                  | 인증 체크, 로깅, Controller 파라미터 가공            |
| **등록 방법**          | `@WebFilter` 또는 `FilterRegistrationBean` | `WebMvcConfigurer.addInterceptors()`     |
|                    |                                          |                                          |

---

📌 **정리**

- **전역적·저수준 처리**가 필요하면 → **Filter**
    
- **Spring MVC Handler 전후 로직**이 필요하면 → **Interceptor**

##### 설명만 들어보면 인터셉터만 쓰는게 나아보이는데, 아닌가요? 필터는 어떤 상황에 사용 해야 하나요?
겉으로 보면 Interceptor가 더 편리해 보이지만, **필터(Filter)만이 적합한 경우**가 분명히 있습니다.  
이유는 **동작 범위와 위치**가 다르기 때문입니다.

---
1. 인터셉터만 쓰면 안 되는 경우

Interceptor는 **Spring MVC의 DispatcherServlet 이후**에 동작합니다.  
즉, **다음과 같은 요청은 아예 Interceptor를 거치지 않습니다**:

- 정적 리소스 (이미지, CSS, JS 파일)
    
- DispatcherServlet 매핑 범위 밖의 요청 (예: `/error`, 서블릿 직접 호출)
    
- 필터 단계에서 차단해야 하는 저수준 보안 처리
    

따라서, 이런 경우에는 Interceptor가 아닌 Filter를 써야 합니다.

---
2. 필터가 꼭 필요한 대표 상황
(1) **서블릿 단 레벨의 전역 처리**

- 요청 인코딩 강제 설정 (`CharacterEncodingFilter`)
    
- 요청·응답 Wrapping (예: XSS 방지 필터, 파라미터 변조 방지)
    
- 모든 HTTP 요청/응답에 대한 로깅 (정적 리소스 포함)
    
- 특정 HTTP Header 강제 추가/수정
    

➡️ **이유:** Interceptor는 Spring MVC 요청만 가로채므로 이런 범위의 처리는 Filter가 유리합니다.

---

(2) **Spring 컨텍스트 로딩 전 단계에서 처리해야 하는 경우**

- 애플리케이션 보안 초기화 (`DelegatingFilterProxy` 기반 Spring Security 필터 체인)
    
- 요청 차단 (화이트리스트, 블랙리스트)  
    → Spring MVC에 도달시키지 않고 응답을 끝내야 하는 경우
    
- 압축/디컴프레션(Gzip) 처리
    

➡️ **이유:** Interceptor는 이미 DispatcherServlet이 요청 객체를 만든 이후에 동작하므로, 그 전에 처리해야 하는 로직은 Filter에서만 가능.

---
(3) **프레임워크 통합**

- Spring Security, CORS, Sitemesh, Shiro 같은 보안/뷰 레이아웃 프레임워크 대부분이 필터 기반.
    
- 이유는 Servlet 스펙에 의존해야 하고, Spring 외부에서도 동작 가능해야 하기 때문.
    

---
3. 비교 관점 요약

| 구분             | Filter                           | Interceptor                           |
| -------------- | -------------------------------- | ------------------------------------- |
| **위치**         | DispatcherServlet **전/후** (더 바깥) | DispatcherServlet 내부 (Controller 전/후) |
| **적용 대상**      | 모든 요청 (정적 리소스 포함)                | Spring MVC Handler 요청만                |
| **사용 목적**      | 전역·저수준 처리                        | 컨트롤러 전후 로직                            |
| **Spring 의존성** | 없음                               | 있음                                    |
| **차단 가능 시점**   | 서블릿 진입 전                         | Handler 실행 전                          |

---

💡 **결론**

- **전역적인 보안, 인코딩, 로깅, 전처리** → **Filter**
    
- **Spring MVC Controller 전/후 로직** → **Interceptor**
    
- 보통 실무에서는 **Filter + Interceptor를 함께** 사용합니다.  
    예: Filter로 인코딩·보안 프레임워크 적용 → Interceptor로 로그인 체크, 파라미터 가공.

### 14. DispatcherServlet 의 역할에 대해 설명해 주세요.
##### 설명
**DispatcherServlet**은 Spring MVC에서 **중앙 제어(Front Controller)** 역할을 하는 핵심 서블릿입니다.  
클라이언트로부터 들어온 HTTP 요청을 받고, 알맞은 컨트롤러로 분배(dispatch)한 뒤, 처리 결과를 적절한 뷰(View)에 연결해 응답을 반환합니다.

---
 1. **DispatcherServlet의 위치와 흐름**

Spring MVC의 전형적인 요청 처리 순서:
```
클라이언트 → (필터) → DispatcherServlet
    → HandlerMapping
    → HandlerAdapter
    → Controller (Handler)
    → ModelAndView 반환
    → ViewResolver
    → View
    → 응답 반환 → (필터) → 클라이언트

```
---
2. **DispatcherServlet의 주요 역할**
(1) **요청 수신과 분배 (Dispatch)**

- 클라이언트 요청을 받아 **HandlerMapping**을 사용해 어떤 컨트롤러(Handler)가 처리할지 결정.
    
- 예: `/users` 요청 → `UserController` 매핑.
    

---
(2) **Handler 실행**

- 결정된 컨트롤러를 실행할 수 있는 **HandlerAdapter**를 찾아 실행.
    
- HandlerAdapter는 다양한 형태의 컨트롤러를 호출 가능 (예: `@Controller`, `HttpRequestHandler`, `SimpleControllerHandlerAdapter` 등).
    

---
 (3) **결과(ModelAndView) 수집**

- 컨트롤러 실행 결과로 **Model(데이터)**와 **View 이름**을 함께 받음.
    
- 예: `ModelAndView("userList", model)`.
    

---
 (4) **뷰(View) 선택과 렌더링**

- **ViewResolver**를 사용해 뷰 이름을 실제 뷰 객체(예: JSP, Thymeleaf)로 변환.
    
- 변환된 뷰 객체에 Model 데이터를 전달하고 렌더링.
    

---
(5) **예외 처리**

- 컨트롤러나 뷰 처리 중 예외가 발생하면 **HandlerExceptionResolver**를 통해 예외 처리 로직 실행.
    
- 예: 특정 예외 시 에러 페이지로 이동.
    

---
(6) **전역 부가기능 연동**

- Spring MVC에서 제공하는 Interceptor, LocaleResolver, MultipartResolver 등의 부가기능과 연동.
    

---
3. **DispatcherServlet 초기화 과정**

- 애플리케이션 시작 시 `DispatcherServlet`이 로드되면, 내부적으로 Spring MVC 관련 빈을 초기화.
    
- **기본 전략 클래스**들을 로드 (`DispatcherServlet.properties`)
    - HandlerMapping
    - HandlerAdapter
    - ViewResolver
    - LocaleResolver
    - ThemeResolver
    - MultipartResolver
    - ExceptionResolver
---
4. **한 줄로 요약**

> DispatcherServlet = **요청과 응답을 총괄 지휘하는 Spring MVC의 Front Controller**  
> 요청 → 컨트롤러 실행 → 모델+뷰 결합 → 뷰 렌더링 → 응답 반환
##### 여러 요청이 들어온다고 가정할 때, DispatcherServlet은 한번에 여러 요청을 모두 받을 수 있나요?
1. 왜 동시에 처리할 수 있는가

- **DispatcherServlet**은 서블릿 표준을 구현한 클래스(`HttpServlet` 상속).
    
- 서블릿 컨테이너(예: Tomcat, Jetty, Undertow)는 **요청마다 별도의 스레드**를 만들어 `service()` → `doGet()` / `doPost()` 메서드를 호출.
    
- 하나의 DispatcherServlet 인스턴스가 애플리케이션에 단 하나만 존재하지만,  
    요청이 오면 각 요청은 **서로 다른 스레드**에서 같은 인스턴스의 메서드를 호출합니다.
    

즉, 구조상 **싱글 인스턴스 + 멀티스레드 처리**입니다.

---

2. 동작 예시



`클라이언트1 → Thread-1 → DispatcherServlet → Controller 클라이언트2 → Thread-2 → DispatcherServlet → Controller 클라이언트3 → Thread-3 → DispatcherServlet → Controller ...`

- 각 요청은 **독립적인 HttpServletRequest / HttpServletResponse 객체**를 가집니다.
    
- 스레드끼리 요청 데이터가 섞이지 않음.
    

---
3. 주의할 점

멀티스레드 환경이므로 **DispatcherServlet 내부에서 사용하는 객체의 상태 관리**에 주의해야 합니다.

- **스레드 안전성(Thread-safety)** 보장 필요.
    
- 필드(인스턴스 변수)에 요청별 데이터를 저장하면 **데이터 섞임(경쟁 상태)** 발생 가능.
    
- 요청별 상태는 **지역변수** 또는 **ThreadLocal**을 사용.
    

---
4. 결론

- **DispatcherServlet은 동시에 여러 요청을 받을 수 있다.**
    
- 이는 서블릿 컨테이너가 스레드를 요청별로 할당해 주기 때문.
    
- 따라서 Controller, Service 계층에서도 **상태를 공유하는 필드**를 두면 안 되고, **무상태(stateless)**로 설계하는 것이 원칙.
##### 수많은 @Controller 를 DispatcherServlet은 어떻게 구분 할까요?
DispatcherServlet이 여러 개의 `@Controller` 중에서 **어떤 컨트롤러를 실행할지 구분**하는 핵심 비밀은 **HandlerMapping** 덕분입니다.

---
1. 요청이 들어왔을 때의 기본 흐름


`클라이언트 요청  → DispatcherServlet    → HandlerMapping(매핑 조회)    → HandlerAdapter(호출 방식 결정)    → 해당 @Controller 메서드 실행`

---
2. HandlerMapping의 역할

- Spring MVC에서 **HandlerMapping**은  
    _"이 URL 요청은 어느 핸들러(Controller 메서드)가 처리해야 하는가?"_  
    를 찾아주는 컴포넌트입니다.
    
- DispatcherServlet은 요청을 받자마자 **여러 HandlerMapping 구현체**를 순서대로 조회합니다.
    

---
3. @Controller 매핑이 등록되는 방식

Spring은 애플리케이션 시작 시 다음 과정을 거칩니다:

1. **`@Controller` 빈 스캔**
    
    - `@Controller`, `@RequestMapping`이 붙은 클래스와 메서드를 찾음.
        
2. **RequestMappingHandlerMapping에 등록**
    
    - 각 메서드의 URL 패턴, HTTP 메서드(GET, POST 등), 파라미터 조건 등을 키로 해서 매핑 테이블 생성.
        
        
        `"/users" + GET  → UserController.listUsers() "/users/{id}" + GET → UserController.getUser() "/users" + POST → UserController.createUser()`
        
3. 요청이 들어오면 RequestMappingHandlerMapping이 이 테이블에서 해당하는 메서드를 찾아서 반환.
    

---
4. 예시

```java
@Controller
@RequestMapping("/users")
public class UserController {

    @GetMapping
    public String listUsers() { ... }

    @GetMapping("/{id}")
    public String getUser(@PathVariable Long id) { ... }

    @PostMapping
    public String createUser(UserDto dto) { ... }
}

```
서버 시작 시 매핑 테이블:

|URL 패턴|HTTP Method|핸들러 메서드|
|---|---|---|
|`/users`|GET|listUsers()|
|`/users/{id}`|GET|getUser()|
|`/users`|POST|createUser()|

---
5. DispatcherServlet이 구분하는 핵심 로직

	1. **요청 URL**과 **HTTP Method**를 기준으로  
    `RequestMappingHandlerMapping`이 알맞은 컨트롤러 메서드를 찾음.
    
	2. 매칭된 메서드와 컨트롤러 객체를 `HandlerExecutionChain` 형태로 DispatcherServlet에 반환.
    
	3. DispatcherServlet은 해당 Handler를 **HandlerAdapter**를 통해 실행.
    

---
 6. 한 줄 요약

> DispatcherServlet이 여러 @Controller를 구분할 수 있는 이유는  
> **HandlerMapping(특히 RequestMappingHandlerMapping)이 URL, HTTP 메서드, 조건을 기준으로 미리 매핑 테이블을 만들어두기 때문**입니다.

### 15. JPA와 같은 ORM을 사용하는 이유가 무엇인가요?
##### 설명
JPA 같은 **ORM(Object-Relational Mapping)**을 사용하는 이유는 단순히 “SQL을 대신 작성해주기 때문”이 아니라, **객체 지향 애플리케이션과 관계형 데이터베이스 사이의 불일치를 해결하고 생산성을 높이기 위해서**입니다.

아래에 이유를 정리하겠습니다.

---
1. 객체-관계 불일치(패러다임 불일치) 해결

- **문제:**
    
    - 자바는 객체 지향 언어 → 객체, 상속, 연관관계, 캡슐화 등을 사용
        
    - DB는 관계형 모델 → 테이블, 외래키, 조인 사용
        
    - 양쪽의 데이터 구조와 표현 방식이 다름.
        
- **JPA 역할:**
    
    - 자바 객체와 DB 테이블 간의 매핑을 자동화해 개발자가 SQL을 직접 매번 작성하지 않아도 됨.
        
    - 예: 객체 필드 ↔ 테이블 컬럼, 객체 관계 ↔ 외래키·조인 자동 처리
        
---
 2. 생산성 향상

- **JPA 사용 전**
```java
    String sql = "SELECT * FROM member WHERE id = ?";
PreparedStatement ps = conn.prepareStatement(sql);
ps.setLong(1, id);
ResultSet rs = ps.executeQuery();

```
- **JPA 사용 후**
    
```java
    Member member = em.find(Member.class, id);

```
    
- SQL, JDBC API, ResultSet 매핑 작업을 대폭 줄여 코드량과 개발 시간이 단축.
    

---
 3. 유지보수성 향상

- SQL이 코드에 직접 섞여 있으면, 테이블 구조가 바뀔 때 관련된 SQL을 모두 찾아 수정해야 함.
    
- JPA는 매핑 설정만 변경하면 대부분의 CRUD 로직은 그대로 동작 → **변경에 유연**.
    

---
4. 객체 지향적인 데이터 접근 가능

- **지연 로딩(Lazy Loading)**, **즉시 로딩(Eager Loading)** 설정으로 필요한 시점에 데이터를 가져옴.
    
- 객체 그래프 탐색 가능:
    
    java
    
    복사편집
    
    `member.getOrders().get(0).getProduct();`
    
    → 객체처럼 참조를 타고 데이터 접근 가능.
    

---
5. 벤더 종속성 줄이기

- 순수 JDBC나 MyBatis는 DBMS에 따라 SQL 문법이 달라지면 수정해야 함.
    
- JPA는 표준 스펙이므로 구현체(Hibernate, EclipseLink 등)를 바꾸거나 DB를 변경해도 매핑 설정만 조금 조정하면 재사용 가능.
    

---
6. 캐싱과 성능 최적화 기능

- 1차 캐시, 변경 감지(Dirty Checking), 쓰기 지연(SQL batching) 등 JDBC에서 직접 구현하려면 복잡한 기능들을 제공.
    
- 복잡한 N+1 문제, 벌크 연산, 페이징 처리 같은 것도 API로 제공.
    

---
7. 트랜잭션과 일관성 유지

- 엔티티 변경을 트랜잭션 범위에서 자동으로 감지하고, 커밋 시점에 변경 사항을 DB에 반영(Flush).
    
- 개발자가 직접 update 문을 작성하지 않아도 데이터 일관성 유지 가능.
    

---
📌 한 줄 결론

> JPA 같은 ORM은 **객체 지향과 관계형 DB 사이의 패러다임 불일치를 해결**하고,  
> **생산성과 유지보수성, 성능, 이식성을 향상**시키기 위해 사용합니다.  
> 단, 내부 동작 원리를 모르면 성능 문제(N+1, 불필요한 쿼리)나 복잡한 쿼리 작성에서 한계가 있으므로 학습이 필수입니다.
##### 영속성은 어떤 기능을 하나요? 이게 진짜 성능 향상에 큰 도움이 되나요?
네, JPA에서 말하는 **영속성(Persistence)** 기능은 단순히 데이터를 오래 저장하는 의미가 아니라, **엔티티를 “영속성 컨텍스트”라는 1차 캐시에 저장하고 관리하는 것**을 뜻합니다.  
이게 성능에도 꽤 도움이 되고, 데이터 일관성 유지에도 핵심 역할을 합니다.

---
1. 영속성 컨텍스트의 역할

영속성 컨텍스트(Persistence Context)는 **엔티티와 DB 사이에서 엔티티를 관리하는 가상의 저장소(1차 캐시)**입니다.  
`EntityManager`가 관리하며, 트랜잭션 범위 안에서 동작합니다.

주요 기능은 다음과 같습니다:

---
(1) 1차 캐시 (First-level Cache)

- 한 트랜잭션 안에서 같은 엔티티를 여러 번 조회하면, DB를 매번 접근하지 않고 **메모리에 있는 엔티티를 재사용**합니다.
    

java

복사편집

`Member m1 = em.find(Member.class, 1L); // DB 조회 Member m2 = em.find(Member.class, 1L); // 1차 캐시에서 반환 (쿼리 안 날림)`

➡️ 장점: **불필요한 DB 쿼리 제거** → 성능 향상.

---
(2) 동일성 보장 (Identity Guarantee)

- 같은 영속성 컨텍스트 안에서 조회한 엔티티는 **동일한 객체 인스턴스**를 반환.
    


`em.find(Member.class, 1L) == em.find(Member.class, 1L) // true`

➡️ 비즈니스 로직에서 객체 비교 시 예기치 않은 버그 방지.

---
 (3) 쓰기 지연(Write-behind)

- `persist()` 호출 시 바로 insert 쿼리를 DB에 날리지 않고, **SQL 저장소에 모아두었다가** 트랜잭션 커밋 시점에 한 번에 실행(batch).
    

java

복사편집

`em.persist(m1); em.persist(m2); // 커밋 시점에 INSERT 2개를 모아서 실행`

➡️ 장점: DB I/O 횟수 줄어듦, 배치 최적화 가능.

---
(4) 변경 감지(Dirty Checking)

- 영속 상태 엔티티의 필드를 변경하면, 트랜잭션 커밋 시점에 **변경된 부분만 update 쿼리로 자동 반영**.
    

java

복사편집

`Member m = em.find(Member.class, 1L); m.setName("newName"); // update 안 해도 됨`

➡️ 장점: 개발자가 update SQL을 직접 작성하지 않아도 됨, 데이터 일관성 유지.

---
(5) 지연 로딩(Lazy Loading) 지원

- 연관된 엔티티를 필요할 때만 SELECT 쿼리로 불러옴 → 초기 로딩 부담 감소.
    

java

복사편집

`member.getOrders(); // 접근 시점에 쿼리 실행`

---
2. 성능 향상 효과

영속성 컨텍스트의 성능 이점은 주로 **DB 접근 최소화**에서 옵니다.

- 같은 트랜잭션에서 같은 데이터 재조회 → DB I/O 제거 (1차 캐시)
    
- INSERT/UPDATE 모아서 실행 → 네트워크 왕복 횟수 줄임
    
- Lazy Loading으로 불필요한 데이터 미조회
    

하지만 **주의점**도 있습니다:

- 1차 캐시는 **트랜잭션 단위 캐시**이므로, 대규모 반복 조회에는 큰 도움 안 됨 (그 경우 2차 캐시 필요).
    
- 너무 많은 엔티티를 영속성 컨텍스트에 올리면 메모리 사용량 증가 → 성능 저하 가능.
    

---
3. 결론

> 영속성 컨텍스트는 **JPA 성능 최적화의 핵심 기능**입니다.  
> 특히 1차 캐시, 쓰기 지연, 변경 감지 덕분에 불필요한 SQL 실행을 줄이고, 개발 편의성과 일관성을 동시에 확보할 수 있습니다.  
> 다만 무조건 성능이 좋아지는 건 아니며, 대규모 데이터 처리 시 캐시 관리 전략이 필요합니다.
##### N + 1 문제에 대해 설명해 주세요.
**N+1 문제**는 JPA 같은 ORM을 사용할 때 자주 발생하는 **성능 문제**로,  
"한 번의 쿼리로 끝낼 수 있는 작업이 N+1번의 쿼리로 쪼개져 실행되는 현상"을 말합니다.

---
1. 상황 예시

예를 들어 **회원(Member)**과 **주문(Order)**이 1:N 관계라고 합시다.

java

복사편집

`List<Member> members = em.createQuery("SELECT m FROM Member m", Member.class)                          .getResultList();  for (Member m : members) {     System.out.println(m.getOrders().size()); }`

쿼리 실행 흐름

1. **첫 번째 쿼리 (1번)**
    
    sql
    
    복사편집
    
    `SELECT * FROM member;`
    
    → 모든 회원 목록 조회
    
2. **반복문 돌 때마다 N번의 쿼리**
    
    sql
    
    복사편집
    
    `SELECT * FROM orders WHERE member_id = 1; SELECT * FROM orders WHERE member_id = 2; ...`
    
    → 회원이 100명이면 100번 실행
    

➡ 총 쿼리 수 = **1 + N** → 이게 바로 **N+1 문제**

---
 2. 왜 발생하나?

- JPA에서 `@OneToMany`, `@ManyToOne` 같은 연관관계는 **기본이 Lazy Loading**.
    
- Lazy Loading은 연관 데이터를 처음 접근하는 시점에 SELECT 쿼리를 날림.
    
- 결과적으로 첫 조회 후, 컬렉션이나 연관 엔티티에 접근할 때마다 새로운 쿼리가 발생.
    

---
 3. 문제점

- 쿼리 수가 데이터 개수에 비례해 폭발적으로 증가.
    
- DB 부하 + 네트워크 왕복 비용 증가.
    
- 대량 데이터 조회 시 심각한 성능 저하.
    

---
4. 해결 방법
(1) **Fetch Join** 사용

- 연관 엔티티를 한 번의 조인 쿼리로 함께 조회.
    

java

복사편집

`SELECT m FROM Member m JOIN FETCH m.orders;`

➡ 회원과 주문을 한 번에 가져와 N+1 방지.

---
(2) **Entity Graph** 사용

- `@EntityGraph` 애너테이션을 활용해 fetch join 효과를 선언적으로 적용.
    

java

복사편집

`@EntityGraph(attributePaths = {"orders"}) @Query("SELECT m FROM Member m") List<Member> findAllWithOrders();`

---
(3) **Batch Size 설정**

- 컬렉션이나 프록시 초기화 시 한 번에 여러 건을 IN 쿼리로 가져오도록 설정.
    

java

복사편집

`@OneToMany(mappedBy = "member") @BatchSize(size = 100) private List<Order> orders;`

또는 `hibernate.default_batch_fetch_size` 전역 설정.

---
 5. 결론

> N+1 문제는 **ORM의 지연 로딩 전략이 잘못 적용될 때 발생하는 대표적인 성능 이슈**입니다.  
> 해결을 위해서는 **fetch join, entity graph, batch size 조정** 등을 상황에 맞게 사용해야 하며,  
> 쿼리 로그를 항상 확인하는 습관이 중요합니다.

### 16. @Transactional 은 어떤 기능을 하나요?
##### 설명
`@Transactional`은 **Spring에서 메서드나 클래스에 트랜잭션 경계를 선언적으로 지정**하는 애너테이션입니다.  
이걸 붙이면 해당 코드가 실행될 때 **트랜잭션 시작 → 커밋(또는 롤백)** 과정을 스프링이 자동으로 처리해 줍니다.

---
 1. 기본 동작

`@Transactional`이 붙은 메서드가 호출되면 스프링이 다음과 같이 동작합니다.

1. **트랜잭션 시작**
    
    - DB 커넥션을 가져오고 `setAutoCommit(false)`로 설정.
        
    - 이후 실행되는 모든 JDBC 작업이 하나의 트랜잭션 안에서 수행됨.
        
2. **비즈니스 로직 실행**
    
    - DAO, JPA repository 등에서 SQL 실행.
        
3. **정상 종료 → 커밋**
    
    - 예외 없이 메서드가 끝나면 `commit()` 호출.
        
4. **예외 발생 → 롤백**
    
    - 기본적으로 **런타임 예외(언체크 예외)** 발생 시 rollback.
        
    - 체크 예외는 rollback하지 않지만 `rollbackFor` 옵션으로 변경 가능.
        

---
 2. 주요 기능
 (1) **트랜잭션 경계 자동 관리**

- 수동으로 커넥션, 커밋, 롤백 처리할 필요 없이 애너테이션으로 지정.
    
 (2) **트랜잭션 전파(Propagation)**

- 이미 진행 중인 트랜잭션이 있으면 합류할지, 새로운 트랜잭션을 만들지 결정.
    
- 예: `REQUIRED`(기본) → 기존 트랜잭션 있으면 합류, 없으면 새로 생성.
    
 (3) **격리 수준(Isolation Level) 설정**

- Dirty Read, Non-repeatable Read, Phantom Read 같은 문제 방지 수준 지정 가능.
    

java

복사편집

`@Transactional(isolation = Isolation.READ_COMMITTED)`

 (4) **읽기 전용 모드**

- `readOnly = true` 설정 시 Hibernate나 JPA가 플러시를 생략해 성능 최적화 가능.
    

java

복사편집

`@Transactional(readOnly = true)`

 (5) **롤백 조건 지정**

- 기본은 RuntimeException, Error 롤백.
    
- 체크 예외나 특정 예외에 대해서도 롤백 가능.
    

java

복사편집

`@Transactional(rollbackFor = SQLException.class)`

---
 3. 예시

java

복사편집

`@Service public class OrderService {      @Transactional     public void placeOrder(Order order) {         orderRepository.save(order); // INSERT         paymentService.pay(order);   // UPDATE/INSERT         // 예외 발생 시 위 두 작업 모두 롤백     } }`

---
 4. 핵심 포인트

- **트랜잭션을 선언적으로 관리** → 코드 단순화.
    
- DB 일관성과 원자성을 보장.
    
- Spring AOP 기반으로 프록시가 메서드 호출 전후에 트랜잭션 처리 로직을 넣어줌.
    
- **주의:** 같은 클래스 안의 메서드끼리 `@Transactional` 호출하면 적용 안 될 수 있음(프록시 우회).
    

---

📌 **한 줄 요약**

> `@Transactional`은 메서드나 클래스에 붙여서 **트랜잭션의 시작, 커밋, 롤백을 자동으로 관리**하는 선언적 트랜잭션 처리 도구입니다.  
> 덕분에 개발자는 트랜잭션 경계와 JDBC API를 직접 다루지 않아도 되고, 일관성과 무결성을 쉽게 유지할 수 있습니다.
##### @Transactional(readonly=true) 는 어떤 기능인가요? 이게 도움이 되나요?
`@Transactional(readOnly = true)`는 **트랜잭션을 읽기 전용 모드로 실행하겠다**는 선언입니다.  
단순히 “쓰기 금지”라는 의미가 아니라, **성능 최적화와 의도 전달** 두 가지 목적이 있습니다.

---
 1. 동작 방식

 (1) **JPA/Hibernate 관점**

- 기본 트랜잭션(`readOnly=false`)에서는 JPA가 **변경 감지(Dirty Checking)**를 수행합니다.
    
    - 엔티티 필드 변경 여부를 추적하기 위해 **스냅샷(snapshot)**을 생성.
        
    - 트랜잭션 종료 시점(`flush()`)에 변경 사항이 있으면 UPDATE SQL 실행.
        
- `readOnly=true`로 설정하면:
    
    - 하이버네이트가 스냅샷 생성을 생략 → 변경 감지 로직 비활성화.
        
    - flush 시점에 쓰기 작업을 하지 않음.
        

➡ 불필요한 메모리 사용과 SQL 생성을 줄임 → 조회 전용 로직에서 성능 최적화 가능.

---
 (2) **JDBC/DB 관점**

- 일부 데이터베이스와 JDBC 드라이버는 `readOnly=true` 트랜잭션에 대해 **DB 차원에서 최적화**를 수행.
    
    - 예: Oracle은 읽기 전용 트랜잭션에 대해 undo 로그 최소화.
        
    - MySQL InnoDB는 큰 최적화는 없지만 의도를 명확히 전달.
        
- 하지만 DB 엔진별로 지원 여부와 최적화 수준은 다름.
    

---
 (3) **Spring 관점**

- Spring이 트랜잭션을 시작할 때 `Connection.setReadOnly(true)`를 호출.
    
- 하위 레벨(JPA, JDBC, MyBatis 등)에 읽기 전용 힌트를 전달.
    

---
 2. 사용 시 이점
 (1) 성능 최적화

- JPA의 Dirty Checking 비활성화로 메모리·CPU 사용량 감소.
    
- flush 과정 생략 → DB I/O 감소.
    

 (2) 의도 명시

- 해당 메서드가 **데이터 조회 전용임을 명확히 표현**.
    
- 나중에 유지보수 시 의도 파악이 쉽고, 실수로 엔티티 변경을 하는 경우 잡아낼 수 있음.
    
 (3) 실수 방지

- 일부 DB에서는 readOnly 트랜잭션에서 쓰기 시도 시 예외 발생 → 의도치 않은 데이터 변경 방지.
    

---
 3. 주의사항

- `readOnly=true`라도 엔티티 값을 변경하면 **자바 객체 값은 바뀝니다**.  
    단지 JPA가 이를 DB에 반영하지 않을 뿐입니다.
    
- DB에서의 동작은 벤더별로 다르므로 “성능 향상 폭”은 환경에 따라 차이 있음.
    
- 읽기와 쓰기가 섞여 있는 메서드에 `readOnly=true`를 붙이면 쓰기 로직이 무시되어 **데이터가 저장되지 않을 수 있음**.
    

---
 4. 결론

> `@Transactional(readOnly = true)`는 **조회 전용 트랜잭션에서 불필요한 변경 감지와 flush를 생략해 성능을 최적화**하고,  
> **코드 의도를 명확히 드러내는** 도구입니다.  
> 특히 조회 전용 API, 리포트 생성, 페이징 처리 같은 경우 성능 이점이 있습니다.

---
##### 그런데, 읽기에 트랜잭션을 걸 필요가 있나요? @Transactional을 안 붙이면 되는거 아닐까요?
언제 읽기에도 @Transactional(readOnly = true)가 ‘필요’한가?

1. **일관된 스냅샷이 필요한 읽기**  
    서비스 메서드 안에서 여러 SELECT가 실행된다면, 트랜잭션 경계를 잡아야 **하나의 격리 수준**(예: READ COMMITTED/REPEATABLE READ) 아래서 **일관된 뷰**를 보장할 수 있습니다.  
    트랜잭션이 없으면 각 쿼리가 **서로 다른 자동 커밋 트랜잭션**으로 실행되어, 중간에 데이터가 바뀌면 **non-repeatable read / phantom**이 발생할 수 있습니다.
    
2. **지연 로딩(Lazy Loading)을 사용할 때**  
    `@Transactional` 경계 밖에서는 영속성 컨텍스트가 닫혀 `LazyInitializationException`이 발생하기 쉽습니다.  
    읽기 전용 트랜잭션을 걸면 **세션(영속성 컨텍스트)** 이 메서드 범위에서 열려 있어 안전하게 지연 로딩을 사용할 수 있습니다.
    
3. **반복 조회·캐시·배치 페치 최적화**  
    트랜잭션이 있으면 **1차 캐시**가 유효해 같은 엔티티 재조회 시 DB를 다시 치지 않습니다.  
    또한 JPA/Hibernate의 **batch fetch** 최적화도 한 세션 안에서 이득을 봅니다.
    
4. **의도와 안전성**  
    `readOnly = true`는 하이버네이트의 **변경 감지/flush 최소화**로 오버헤드를 줄이고, 일부 DB에 **읽기 전용 힌트**를 전달합니다.  
    또한 “이 메서드는 쓰지 않는다”는 선언이 되어 **우발적인 업데이트**를 방지합니다.
    
 언제 굳이 없어도 되는가?

- **단일 쿼리로 끝나는 간단한 조회**(특히 **DTO/프로젝션**으로 바로 매핑하고, 지연 로딩이 전혀 없을 때)
    
- 컨트롤러 → 리포지토리 한 번 호출로 결과를 반환하고, 추가적인 컬렉션 탐색이나 연관 접근이 전혀 없는 경우
    

이런 경우 @Transactional(readOnly = true)를 생략해도 기능적으로 문제는 없습니다. 다만 붙여도 **거의 무해하고 의도가 명확**해지는 이점이 있습니다.

 권장 실무 기준

- **서비스 레이어의 조회 메서드에는 기본적으로 `@Transactional(readOnly = true)`**
    
    - 여러 SELECT, 지연 로딩, 캐시/배치 페치 이점, 스냅샷 일관성 확보
        
- **쓰기 메서드에는 `@Transactional`(기본)**
    
- **단일 간단 조회 + DTO 반환**만 하는 메서드는 선택사항 (붙여도 무방)
    
 간단 예시

```java
@Service
public class OrderQueryService {

    // 여러 SELECT와 지연 로딩을 사용할 수 있는 복합 조회
    @Transactional(readOnly = true)
    public OrderDetailView getOrderDetail(Long orderId) {
        Order order = orderRepository.findById(orderId)
                .orElseThrow();
        // 지연 로딩 안전 (same transaction/session)
        List<OrderItem> items = order.getItems();
        // 1차 캐시로 동일 엔티티 재조회 시 DB hit 없음
        Customer customer = order.getCustomer();
        return OrderDetailView.of(order, items, customer);
    }

    // 단일 쿼리로 DTO만 뽑는 경우: 선택적으로 생략 가능
    public SimpleOrderDto getSimple(Long orderId) {
        return orderRepository.findSimpleDtoById(orderId);
    }
}

```

결론

- “읽기니까 트랜잭션 필요 없다”는 **절반만 맞는 말**입니다.
    
- **여러 조회를 하나의 일관된 시점으로 묶고**, **지연 로딩/캐시/배치 페치 최적화**를 활용하려면 `@Transactional(readOnly = true)`가 **실질적 도움**이 됩니다.
    
- 매우 단순한 단일 조회 + DTO 반환에는 필수가 아니지만, **붙이는 쪽이 의도 명확성과 안전성 면에서 더 낫다**가 일반적 실무 기준입니다.

### 17. Java 에서 Annotation 은 어떤 기능을 하나요?
##### 설명
Java에서 **Annotation**은

> 코드에 **메타데이터(metadata)**를 부여해서, **컴파일러나 런타임에 추가적인 정보나 동작을 제공**하는 기능  
> 입니다.

즉, **“이 코드에 이런 의미/설정을 부여한다”** 라고 표시하는 주석과 비슷하지만,  
단순 주석과 달리 **프로그램이 실행되거나 컴파일될 때 실제로 활용**될 수 있습니다.

---
1. Annotation의 주요 역할
 (1) **컴파일러 지시**

- 컴파일러에게 경고를 무시하게 하거나, 특정 검사를 하도록 지시.
    
- 예:
    
    java
    
    복사편집
    
    `@Override  // 부모 메서드를 정확히 오버라이드하는지 컴파일러가 검사 public String toString() { ... }  @SuppressWarnings("unchecked")  // 경고 무시`
    

---
(2) **코드 분석 도구에 정보 제공**

- IDE, 빌드 도구, 린트(lint) 도구가 코드 분석 시 활용.
    
- 예: `@Deprecated` → 해당 API가 더 이상 사용되지 않음을 알림.
    

---
(3) **런타임 동작 변경**

- 리플렉션(Reflection)으로 애노테이션을 읽어서 실행 로직에 반영.
    
- 프레임워크(Spring, JPA 등)에서 광범위하게 사용:
    
    java
    
    복사편집
    
    `@Controller  // 스프링이 이 클래스를 웹 컨트롤러로 인식 @Transactional // 메서드 실행 시 트랜잭션 시작/커밋/롤백 관리`
    

---
(4) **코드 생성·변환**

- 애노테이션 프로세서(Annotation Processor)를 사용해 컴파일 시 코드 생성/수정.
    
- 예: Lombok의 `@Getter`, `@Builder` → getter 메서드나 빌더 코드 자동 생성.
    

---
2. Annotation의 구성 요소
선언 방법

java

복사편집

`public @interface MyAnnotation {     String value();      // 필수 속성     int count() default 1; // 기본값 속성 }`

메타 애노테이션 (Meta-Annotation)

애노테이션 자체의 동작을 정의하는 애노테이션:

- `@Target` → 적용 가능한 위치 지정 (클래스, 메서드, 필드 등)
    
- `@Retention` → 유지 범위 지정
    
    - `SOURCE` (컴파일 후 버려짐)
        
    - `CLASS` (클래스 파일에 남지만 런타임에는 사용 불가)
        
    - `RUNTIME` (런타임에도 유지, 리플렉션 가능)
        
- `@Documented` → Javadoc에 포함
    
- `@Inherited` → 하위 클래스에 상속 가능
    

---
 3. 예시
```java
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface LogExecutionTime {
}

public class MyService {

    @LogExecutionTime
    public void process() {
        // 실행 시간 측정 대상
    }
}

```

- 프레임워크나 AOP 설정에서 `@LogExecutionTime`이 붙은 메서드를 찾아 실행 시간을 로깅할 수 있음.
    

---
4. 한 줄 정리

> **Java의 Annotation은 코드에 의미와 설정을 부여하는 메타데이터**로,  
> 컴파일러, 빌드 도구, 프레임워크가 이 정보를 읽어 **검사·코드 생성·실행 동작 변경**을 할 수 있게 해 줍니다.

##### 별 기능이 없는 것 같은데, 어떻게 Spring 에서는 Annotation 이 그렇게 많은 기능을 하는 걸까요?
좋은 질문입니다.  
겉으로 보면 Java 애노테이션은 **그냥 붙여 놓는 “메모” 정도**처럼 보이는데,  
Spring 같은 프레임워크에서는 `@Controller`, `@Transactional`, `@Autowired` 같은 애노테이션이  
**동작 자체를 바꾸는 핵심 기능**이 되죠.

이게 가능한 이유는, **Spring이 애노테이션을 적극적으로 “읽고” 동작을 연결하는 구조를 만들었기 때문**입니다.  
즉, 애노테이션 자체가 기능을 하는 게 아니라,  
**프레임워크가 애노테이션을 해석해서 동작을 붙이는 것**입니다.

---
 1. 애노테이션 자체는 “메타데이터”일 뿐

Java 애노테이션은 실행 로직이 없습니다.  
그저 **"이 코드에 이런 의미가 있다"**를 붙여놓는 표식일 뿐입니다.  
예:

java

복사편집

`@Controller public class MyController { ... }`

→ `@Controller` 자체는 아무 일도 안 합니다.

---
 2. Spring이 기능을 부여하는 방식
(1) **런타임 리플렉션(Reflection)**

- Spring이 애플리케이션 시작 시 **클래스와 메서드를 스캔**하면서,  
    특정 애노테이션이 붙은 대상에 특별한 처리를 함.
    
- 예:
    
    - `@Controller` → Spring MVC의 RequestMappingHandlerMapping이 이 클래스를 컨트롤러로 등록.
        
    - `@Autowired` → 의존성 주입 단계에서 해당 필드/생성자에 Bean 주입.
        
```java
for (Class<?> clazz : scannedClasses) {
    if (clazz.isAnnotationPresent(Controller.class)) {
        registerAsController(clazz);
    }
}

```
---

(2) **빈 후처리기(BeanPostProcessor)**

- Spring의 **BeanPostProcessor** 인터페이스 구현체들이 Bean 생성 전/후에 애노테이션을 해석.
    
- 예:
    
    - `@Autowired` → `AutowiredAnnotationBeanPostProcessor`
        
    - `@Transactional` → `TransactionalAnnotationBeanPostProcessor` + 프록시 생성
        

---
 (3) **AOP(Aspect-Oriented Programming)**

- `@Transactional`, `@Cacheable` 같은 애노테이션은 프록시 객체를 생성해서  
    **메서드 호출 전/후에 부가 로직**을 자동 실행.
    
- 예:
    
    1. `@Transactional`이 붙은 메서드 호출
        
    2. 프록시가 가로채서 트랜잭션 시작
        
    3. 실제 메서드 실행
        
    4. 성공 시 커밋, 실패 시 롤백
        

---

(4) **애노테이션 기반 설정(Annotation-Driven Configuration)**

- XML 대신 애노테이션으로 Bean 정의, 스캔, 의존성 주입, 설정 가능.
    
- 예:
    
    java
    
    복사편집
    
    `@Configuration @ComponentScan(basePackages = "com.example") public class AppConfig { }`
    

---
 3. 요약하면

- **애노테이션은 그 자체로 기능을 수행하지 않는다.**
    
- Spring이 **시작 시 애노테이션을 스캔하고**,  
    **BeanPostProcessor + Reflection + AOP**로  
    → 애노테이션이 붙은 곳에 **특정 동작**을 자동으로 주입하는 구조를 만들었기 때문에  
    → 마치 애노테이션이 “기능”을 하는 것처럼 보인다.
    

---
4. 비유

- 애노테이션 = “여기 중요한 표시 있음”이라는 포스트잇
    
- Spring = 포스트잇을 읽고 “아, 여기는 트랜잭션 붙여야지”, “여기는 HTTP 요청 매핑해야지” 하고 동작을 구현하는 사람
##### Lombok의 @Data를 잘 사용하지 않는 이유는 무엇일까요?
`@Data`는 Lombok에서 한 번에 **`@Getter` + `@Setter` + `@RequiredArgsConstructor` + `@ToString` + `@EqualsAndHashCode`**를 만들어주는 “올인원” 애너테이션입니다.  
편리하지만, **실무에서는 잘 안 쓰이거나 조심해서 쓰는 경향**이 있습니다.

이유를 하나씩 보면 다음과 같습니다.

---
 1. **불필요한 Setter 생성 → 불변성(immutability) 깨짐**

- `@Data`는 **모든 필드에 public Setter**를 만들어줍니다.
    
- 도메인 객체(Entity, VO 등)는 **한 번 생성 후 변경 불가능**해야 하는 경우가 많습니다.
    
- Setter를 남발하면 객체 상태가 아무 데서나 바뀌어 **버그 추적이 어려워지고, 동시성 문제**가 생길 수 있습니다.
    

`@Data public class User {     private String name; }`

→ 나중에 아무 곳에서나 `user.setName("...")` 가능  
→ 객체의 무결성과 의도를 해칠 위험

---
 2. **Equals/HashCode 자동 생성 문제**

- `@Data`는 모든 필드를 기반으로 `equals()`와 `hashCode()`를 생성합니다.
    
- 컬렉션, 연관 객체(특히 JPA Entity의 양방향 연관관계)가 포함되면 **무한 루프**나 **성능 저하** 가능.
    
- JPA Entity에서는 ID 값이 영속화 전후로 바뀌므로, equals/hashCode가 잘못 동작해 **HashSet/HashMap 문제**가 발생할 수 있음.
    

---
 3. **의도치 않은 ToString 위험**

- 모든 필드를 포함한 `toString()` 생성 → 민감한 데이터(비밀번호 등)가 로그에 노출될 수 있음.
    
- 연관관계가 순환 구조일 경우 `StackOverflowError` 발생.
    

---
 4. **너무 많은 책임을 한 번에 부여**

- `@Data`는 Getter/Setter/ToString/Equals/HashCode/Constructor를 **모두 생성**하므로,  
    필요한 것만 선택적으로 쓰는 제어가 어렵습니다.
    
- 명시적으로 `@Getter`, `@Setter`, `@ToString`, `@EqualsAndHashCode`를 필요한 곳에만 붙이는 것이 **더 안전하고 유지보수에 유리**.
    

---
 5. **특히 JPA Entity와 궁합이 좋지 않음**

- JPA에서는 다음 이유로 `@Data`가 권장되지 않습니다:
    
    - 무분별한 Setter → 무결성 약화
        
    - equals/hashCode/toString 자동 생성 → 지연 로딩 프록시 접근 시 문제 발생
        
    - 필드 변경 시 flush 타이밍에서 의도치 않은 update 발생 가능
        

---
 6. **실무에서 권장되는 대안**

- **DTO**: `@Data` 사용 가능 (순수 데이터 전달 객체이고 불변성 중요하지 않을 때)
    
- **Entity/Domain 객체**:
    
    - `@Getter`만 사용 + 생성자를 통한 값 설정
        
    - 불변 객체라면 `@Value` (Lombok)
        
    - 필요한 경우에만 Setter 메서드 직접 작성 (비즈니스 의미 부여)
        

---

✅ **정리**

> `@Data`는 편리하지만, **모든 필드에 Getter/Setter를 열어버리고, equals/hashCode/toString을 무분별하게 생성**하는 위험이 있습니다.  
> 특히 **도메인 객체나 JPA Entity**에서는 객체 불변성과 무결성을 해치기 쉬워서 실무에서는 잘 사용하지 않습니다.  
> 대신 필요한 Lombok 애너테이션을 **개별적으로 조합**하는 방식이 안전합니다.

---

### 18. Tomcat이 정확히 어떤 역할을 하는 도구인가요?
##### 설명
Tomcat은 한마디로 **Java 기반 웹 애플리케이션을 실행시키기 위한 서버(서블릿 컨테이너)**입니다.  
정확히는 **HTTP 서버 + Servlet/JSP 컨테이너** 역할을 하는 오픈소스 소프트웨어입니다.

---
 1. Tomcat의 핵심 역할

 (1) **Servlet 컨테이너**

- Java EE(현 Jakarta EE) 스펙 중 **Servlet**과 **JSP**를 구현한 서버입니다.
    
- Servlet 클래스의 생명주기 관리  
    → 생성, 초기화(`init()`), 요청 처리(`service()`), 소멸(`destroy()`)
    
- 클라이언트 HTTP 요청을 **Servlet 객체에 전달**하고, 응답을 만들어 클라이언트에 반환.
    

---
 (2) **HTTP 서버 기능**

- HTTP 프로토콜을 이해하고, 소켓 통신을 통해 요청/응답 처리.
    
- Apache HTTP Server 같은 별도 웹 서버 없이도 정적 리소스(HTML, CSS, JS, 이미지) 제공 가능.
    

---
 (3) **웹 애플리케이션 관리**

- `webapps` 폴더에 `.war` 파일이나 디렉토리 형태로 배포된 웹 애플리케이션을 로드/관리.
    
- 애플리케이션별로 **서블릿, 필터, 리스너, JSP** 등을 실행 환경에 맞게 초기화.
    

---
 (4) **서블릿 매핑과 요청 분배**

- web.xml, 애노테이션(`@WebServlet`) 설정을 기반으로 요청 URL → 해당 서블릿 매핑.
    
- 예:
    
    bash
    
    복사편집
    
    `/user → UserServlet /product → ProductServlet`
    

---

 2. Tomcat 요청 처리 흐름
```
[클라이언트 브라우저]
        ↓ (HTTP 요청)
   [Tomcat HTTP Connector] ← (8080 포트 대기)
        ↓
   [Servlet Container]
        ↓  (URL 매핑)
  해당 Servlet 실행 → doGet()/doPost()
        ↓
   [Servlet Container]
        ↓
   [HTTP Connector]
        ↓
[클라이언트 브라우저로 HTTP 응답 전송]

```
 3. Tomcat과 다른 서버의 관계

- **Tomcat** = Servlet 컨테이너 + 기본 HTTP 서버
    
- **Apache HTTP Server, Nginx** = 정적 리소스 제공 + 리버스 프록시 역할 가능
    
- Spring Boot 내장 Tomcat → Spring MVC 앱을 배포 없이 `main()` 실행만으로 구동 가능.
    

---
 4. 한 줄로 정리

> **Tomcat은 Java 웹 애플리케이션을 실행시키기 위해 HTTP 요청을 받아 서블릿/JSP로 처리하고, 응답을 반환하는 서버(서블릿 컨테이너)입니다.**
##### 혹시 Netty에 대해 들어보셨나요? 왜 이런 것을 사용할까요?
네, Netty는 꽤 유명한 **비동기 이벤트 기반 네트워크 애플리케이션 프레임워크**입니다.  
간단히 말해, **TCP/UDP 같은 네트워크 프로토콜 위에서 고성능·비동기 서버를 쉽게 만들 수 있게 해주는 Java 라이브러리**입니다.

---
 1. Netty란 무엇인가

- Java NIO(Non-blocking I/O) 기반으로 만든 네트워크 통신 프레임워크.
    
- TCP/UDP, HTTP, WebSocket 등 다양한 프로토콜을 처리할 수 있음.
    
- 멀티스레드, 이벤트 루프 기반의 설계로 **고성능, 고확장성** 네트워크 서버·클라이언트 구현 가능.
    
- 예: 채팅 서버, 게임 서버, 스트리밍 서버, 메시지 브로커(Kafka의 내부 통신도 Netty 기반) 등.
    

---
 2. 왜 Netty를 사용하는가?

 (1) **Java NIO의 복잡성을 추상화**

- 순수 Java NIO API는 Selector, Channel, Buffer를 직접 관리해야 하고 코드가 복잡.
    
- Netty는 이를 추상화해 **이벤트 기반 파이프라인** 형태로 쉽게 작성 가능.
    

---

 (2) **비동기·논블로킹 처리로 높은 성능**

- 동기/블로킹 방식은 요청 하나당 스레드를 점유 → 동시 연결 수가 많아지면 스레드 부하.
    
- Netty는 이벤트 루프(EventLoop) 모델을 사용해 소수의 스레드로 수많은 연결을 동시에 처리.
    
- → **적은 리소스로 높은 동시성** 지원.
    

---

 (3) **다양한 프로토콜 지원과 확장성**

- HTTP, WebSocket, FTP, MQTT 등 여러 프로토콜 코덱(Codec) 제공.
    
- 커스텀 프로토콜도 쉽게 구현 가능.
    

---

 (4) **안정성과 실무 검증**

- Hadoop, Elasticsearch, gRPC, Apache Cassandra, Kafka, Spark 같은 대형 프로젝트에서도 사용.
    
- 검증된 성능과 안정성.
    

---
 3. 동작 구조 예시

Netty는 **ChannelPipeline**이라는 구조로 동작합니다.

복사편집

`클라이언트 요청  → ChannelInboundHandler 1  → ChannelInboundHandler 2  → 비즈니스 로직 처리  → ChannelOutboundHandler 1  → 응답 전송`

- 각 Handler는 이벤트(데이터 수신, 연결 생성, 예외 발생 등)에 반응해 동작.
    
- 파이프라인 방식이라 유지보수·확장이 용이.
    

---
 4. Tomcat과 Netty의 차이

|구분|Tomcat|Netty|
|---|---|---|
|주 용도|서블릿/JSP 기반 웹 애플리케이션 실행|네트워크 애플리케이션(HTTP 포함) 전반|
|I/O 모델|(기본) 스레드 풀 기반 블로킹 I/O + 일부 NIO|완전한 비동기 논블로킹 I/O|
|특징|Servlet 스펙 준수, Spring MVC와 바로 호환|HTTP뿐 아니라 TCP/UDP/WebSocket 등 자유롭게|
|사용 예|Spring MVC, JSP 기반 서버|게임 서버, 채팅 서버, gRPC, IoT, 메시지 브로커|

---
5. 한 줄 요약

> **Netty는 Java NIO 기반의 고성능, 비동기 네트워크 프레임워크**로,  
> 수많은 동시 연결을 효율적으로 처리해야 하는 서버(HTTP, TCP, WebSocket 등)에 적합합니다.
