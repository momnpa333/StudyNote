### 1. 시간복잡도와 공간복잡도에 대해 설명해 주세요.
##### 설명
시간복잡도 (Time Complexity)

시간복잡도는 알고리즘이 문제를 해결하는데 **걸리는 시간**을 입력 크기에 따라 나타낸 것입니다. 주로 Big-O 표기법으로 나타냅니다.

**주요 특징:**
- 알고리즘의 **연산 횟수**를 기준으로 측정합니다
- 입력 크기 n이 커질 때 실행 시간이 어떻게 증가하는지 나타냅니다
- 최선, 평균, 최악의 경우로 나눌 수 있으며, 보통 **최악의 경우**를 기준으로 합니다

**대표적인 시간복잡도:**

- O(1): 상수 시간 - 배열의 인덱스 접근
- O(log n): 로그 시간 - 이진 탐색
- O(n): 선형 시간 - 단순 반복문
- O(n log n): - 효율적인 정렬 (병합 정렬, 퀵 정렬)
- O(n²): 이차 시간 - 이중 반복문 (버블 정렬, 선택 정렬)
- O(2ⁿ): 지수 시간 - 피보나치 재귀

공간복잡도 (Space Complexity)

공간복잡도는 알고리즘이 실행되는 동안 사용하는 **메모리 공간**의 양을 입력 크기에 따라 나타낸 것입니다.

**주요 특징:**

- **고정 공간**: 코드 저장 공간, 상수, 변수 등
- **가변 공간**: 입력 크기에 따라 달라지는 동적 메모리 (배열, 재귀 호출 스택 등)
- 일반적으로 가변 공간만을 고려합니다

**예시:**

- O(1): 추가 메모리를 사용하지 않는 경우 (제자리 정렬)
- O(n): 입력 크기만큼의 추가 배열 사용
- O(log n): 재귀 호출의 깊이가 log n인 경우
- O(n²): 2차원 배열 사용

**시간복잡도와 공간복잡도의 트레이드오프:** 종종 시간을 줄이기 위해 더 많은 메모리를 사용하거나, 메모리를 절약하기 위해 더 많은 시간이 걸리는 상황이 발생합니다. 예를 들어 동적 프로그래밍은 중복 계산을 피하기 위해 메모리에 결과를 저장하여 시간을 단축시킵니다.

##### Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.
##### 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?
##### O(1)은 O(N^2) 보다 무조건적으로 빠른가요?
### 2. 링크드 리스트에 대해 설명해 주세요.
- 일반 배열과, 링크드 리스트를 비교해 주세요.
- 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.
### 3. 스택과 큐에 대해서 설명해 주세요.

- 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.
- 시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?
- Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.
- Deque는 어떻게 구현할 수 있을까요?
- (C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?

### 4. 해시 자료구조에 대해 설명해 주세요.

- 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
- 해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?
- 본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?
- Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.
- Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?
- 다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.

### 5. 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.

- 그래프와 트리의 차이가 무엇인가요?
- 이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?
- 이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.
- 이진탐색트리의 한계점에 대해 설명해주세요.
- 이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?
- 이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.

### 6. 힙에 대해 설명해 주세요.

- 힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?
- 힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.
- 힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?

### 7. BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.
- Red Black Tree는 어떻게 균형을 유지할 수 있을까요?
- Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.
- 2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?

### 8. 정렬 알고리즘에 대해 설명해 주세요.
- Quick Sort와 Merge Sort를 비교해 주세요.
- Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.
- Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.
- Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?
- Radix Sort에 대해 설명해 주세요.
- Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.
- 값이 **거의** 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?
- 본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?
- 정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?