### 1. 시간복잡도와 공간복잡도에 대해 설명해 주세요.
##### 설명
시간복잡도 (Time Complexity)

시간복잡도는 알고리즘이 문제를 해결하는데 **걸리는 시간**을 입력 크기에 따라 나타낸 것입니다. 주로 Big-O 표기법으로 나타냅니다.

**주요 특징:**
- 알고리즘의 **연산 횟수**를 기준으로 측정합니다
- 입력 크기 n이 커질 때 실행 시간이 어떻게 증가하는지 나타냅니다
- 최선, 평균, 최악의 경우로 나눌 수 있으며, 보통 **최악의 경우**를 기준으로 합니다

**대표적인 시간복잡도:**

- O(1): 상수 시간 - 배열의 인덱스 접근
- O(log n): 로그 시간 - 이진 탐색
- O(n): 선형 시간 - 단순 반복문
- O(n log n): - 효율적인 정렬 (병합 정렬, 퀵 정렬)
- O(n²): 이차 시간 - 이중 반복문 (버블 정렬, 선택 정렬)
- O(2ⁿ): 지수 시간 - 피보나치 재귀

공간복잡도 (Space Complexity)

공간복잡도는 알고리즘이 실행되는 동안 사용하는 **메모리 공간**의 양을 입력 크기에 따라 나타낸 것입니다.

**주요 특징:**

- **고정 공간**: 코드 저장 공간, 상수, 변수 등
- **가변 공간**: 입력 크기에 따라 달라지는 동적 메모리 (배열, 재귀 호출 스택 등)
- 일반적으로 가변 공간만을 고려합니다

**예시:**

- O(1): 추가 메모리를 사용하지 않는 경우 (제자리 정렬)
- O(n): 입력 크기만큼의 추가 배열 사용
- O(log n): 재귀 호출의 깊이가 log n인 경우
- O(n²): 2차원 배열 사용

**시간복잡도와 공간복잡도의 트레이드오프:** 종종 시간을 줄이기 위해 더 많은 메모리를 사용하거나, 메모리를 절약하기 위해 더 많은 시간이 걸리는 상황이 발생합니다. 예를 들어 동적 프로그래밍은 중복 계산을 피하기 위해 메모리에 결과를 저장하여 시간을 단축시킵니다.

##### Big-O, Big-Theta, Big-Omega 에 대해 설명해 주세요.
##### 다른 것을 사용하지 않고, Big-O를 사용하는 이유가 있을까요?
##### O(1)은 O(N^2) 보다 무조건적으로 빠른가요?
### 2. 링크드 리스트에 대해 설명해 주세요.
링크드 리스트 (Linked List)

링크드 리스트는 데이터를 저장하는 선형 자료구조로, 각 데이터 요소(노드)가 **데이터와 다음 노드를 가리키는 포인터**로 구성되어 있습니다.

구조

**노드(Node) 구성:**

- **데이터(Data)**: 실제 저장할 값
- **포인터(Next)**: 다음 노드의 주소를 저장

```
[Data | Next] -> [Data | Next] -> [Data | Next] -> null
```
종류

**1. 단일 연결 리스트 (Singly Linked List)**

- 각 노드가 다음 노드만 가리킵니다
- 한 방향으로만 순회 가능합니다

**2. 이중 연결 리스트 (Doubly Linked List)**

- 각 노드가 이전 노드와 다음 노드를 모두 가리킵니다
- 양방향 순회가 가능합니다

**3. 원형 연결 리스트 (Circular Linked List)**

- 마지막 노드가 첫 번째 노드를 가리킵니다
- 순환 구조를 가집니다

배열과의 비교

**링크드 리스트의 장점:**

- **동적 크기**: 크기를 미리 정할 필요가 없습니다
- **삽입/삭제 효율적**: O(1) - 중간에 데이터를 삽입하거나 삭제할 때 다른 데이터를 이동시킬 필요가 없습니다 (해당 위치를 찾은 후)

**링크드 리스트의 단점:**

- **임의 접근 불가**: 특정 인덱스 접근 시 O(n) - 처음부터 순차적으로 탐색해야 합니다
- **추가 메모리**: 각 노드마다 포인터를 저장해야 하므로 추가 메모리가 필요합니다
- **캐시 효율성 낮음**: 메모리상에 연속적으로 배치되지 않아 캐시 활용도가 낮습니다

시간복잡도

- **접근(Access)**: O(n) - 인덱스로 직접 접근 불가
- **검색(Search)**: O(n) - 순차 탐색 필요
- **삽입(Insert)**: O(1) - 삽입 위치를 알고 있을 때
- **삭제(Delete)**: O(1) - 삭제 위치를 알고 있을 때

공간복잡도

- O(n) - n개의 노드와 각 노드의 포인터

활용 사례

- 크기를 예측할 수 없는 데이터 저장
- 잦은 삽입/삭제가 필요한 경우
- 스택, 큐 구현
- 그래프의 인접 리스트 표현

##### 일반 배열과, 링크드 리스트를 비교해 주세요.
##### 링크드 리스트를 사용해서 구현할 수 있는 다른 자료구조에 대해 설명해 주세요.
링크드 리스트로 구현 가능한 자료구조

링크드 리스트는 다양한 자료구조의 기반이 됩니다. 주요 자료구조들을 살펴보겠습니다.

1. 스택 (Stack)

**특징:**

- LIFO (Last In First Out) 구조
- 마지막에 들어온 데이터가 먼저 나갑니다

**링크드 리스트 구현:**

- 리스트의 head를 스택의 top으로 사용
- push: head에 새 노드 추가 - O(1)
- pop: head 노드 제거 - O(1)
- peek: head 노드 확인 - O(1)

**활용:**

- 함수 호출 스택
- 괄호 검사
- 실행 취소(Undo) 기능

2. 큐 (Queue)

**특징:**

- FIFO (First In First Out) 구조
- 먼저 들어온 데이터가 먼저 나갑니다

**링크드 리스트 구현:**

- head(front)와 tail(rear) 포인터 사용
- enqueue: tail에 새 노드 추가 - O(1)
- dequeue: head 노드 제거 - O(1)

**활용:**

- 프로세스 스케줄링
- BFS(너비 우선 탐색)
- 프린터 대기열

3. 덱 (Deque, Double-ended Queue)

**특징:**

- 양쪽 끝에서 삽입/삭제가 가능한 큐

**링크드 리스트 구현:**

- 이중 연결 리스트로 구현하면 효율적
- 앞/뒤 모두에서 O(1)에 삽입/삭제 가능

**활용:**

- 스택과 큐의 기능을 모두 필요로 할 때
- 슬라이딩 윈도우 문제

4. 해시 테이블 (Hash Table) - 체이닝 방식

**특징:**

- 충돌 해결을 위해 각 버킷에 링크드 리스트 사용

**링크드 리스트 구현:**

- 각 해시 버킷이 링크드 리스트
- 같은 해시값을 가진 데이터들을 연결

**장점:**

- 동적 크기 조정
- 삭제 연산이 간단

5. 그래프 (Graph) - 인접 리스트

**특징:**

- 각 정점의 인접한 정점들을 링크드 리스트로 표현

**링크드 리스트 구현:**

- 각 정점마다 연결된 정점들의 리스트 유지
- 공간복잡도: O(V + E) - V: 정점 수, E: 간선 수

**장점:**

- 희소 그래프(sparse graph)에서 메모리 효율적
- 간선 추가/삭제가 용이

6. LRU 캐시 (Least Recently Used Cache)

**특징:**

- 가장 오래 사용되지 않은 데이터를 제거

**링크드 리스트 구현:**

- 이중 연결 리스트 + 해시맵 조합
- 최근 사용된 데이터를 head로 이동
- tail의 데이터를 제거

**시간복잡도:**

- 조회, 삽입, 삭제 모두 O(1)

7. 우선순위 큐 (Priority Queue) - 비효율적

**특징:**

- 우선순위가 높은 데이터가 먼저 나옵니다

**링크드 리스트 구현:**

- 정렬된 상태로 유지
- 삽입: O(n) - 적절한 위치 찾아야 함
- 삭제: O(1) - head 제거

**단점:**

- 힙(Heap)으로 구현하는 것이 더 효율적 (삽입/삭제 O(log n))

8. 다항식 (Polynomial)

**특징:**

- 각 항을 노드로 표현 (계수, 지수)

**링크드 리스트 구현:**

- 0이 아닌 항만 저장하여 메모리 절약
- 다항식 덧셈, 곱셈 구현 가능

**예시:**

```
3x² + 5x + 2 → [3,2] -> [5,1] -> [2,0]
```
요약

링크드 리스트는 **동적 크기 조정**과 **효율적인 삽입/삭제**가 필요한 자료구조의 기반으로 널리 사용됩니다. 특히 스택, 큐, 그래프의 인접 리스트, 해시 테이블의 체이닝에서 핵심적인 역할을 합니다.
### 3. 스택과 큐에 대해서 설명해 주세요.
##### 스택 2개로 큐를, 큐 2개로 스택을 만드는 방법과, 그 시간복잡도에 대해 설명해 주세요.
스택 2개로 큐 만들기

스택 2개를 사용하면 큐의 FIFO 동작을 구현할 수 있습니다.

기본 아이디어

**두 개의 스택 사용:**

- **Stack1 (input)**: enqueue 연산용
- **Stack2 (output)**: dequeue 연산용

**핵심 원리:** 스택은 LIFO이므로, 데이터를 한 스택에서 다른 스택으로 옮기면 순서가 뒤집힙니다. 두 번 뒤집으면 원래 순서(FIFO)가 됩니다.

구현 방법

**1. Enqueue (삽입)**

- Stack1에 push
- 시간복잡도: O(1)

**2. Dequeue (삭제)**

- Stack2가 비어있으면, Stack1의 모든 요소를 Stack2로 이동
- Stack2에서 pop
- 시간복잡도:
    - 최악: O(n) - Stack1을 모두 옮길 때
    - 평균(amortized): O(1)


##### 시간복잡도를 유지하면서, 배열로 스택과 큐를 구현할 수 있을까요?
안된다. 공간이 차는게 아니라면 가능하다. 그래서 안된다. 
##### Prefix, Infix, Postfix 에 대해 설명하고, 이를 스택을 활용해서 계산/하는 방법에 대해 설명해 주세요.
##### Deque는 어떻게 구현할 수 있을까요?

##### (C++ 한정) Deque의 Random Access 시간복잡도는 O(1) 입니다. 이게 어떻게 가능한걸까요?

### 4. 해시 자료구조에 대해 설명해 주세요.
특정 키로 특정한 값을 바로 찾을수 있게 해주는 자료구조

##### 값이 주어졌을 때, 어떻게 하면 충돌이 최대한 적은 해시 함수를 설계할 수 있을까요?
충돌이 적은 해시 함수 설계 방법

좋은 해시 함수는 충돌을 최소화하고 데이터를 균등하게 분산시켜야 합니다. 다양한 설계 원칙과 기법들을 살펴보겠습니다.

1. 좋은 해시 함수의 조건

**핵심 원칙:**

- **균등 분산(Uniform Distribution)**: 모든 해시값이 거의 동일한 확률로 나와야 함
- **결정성(Deterministic)**: 같은 입력은 항상 같은 해시값
- **효율성**: 계산이 빠를 것
- **눈사태 효과(Avalanche Effect)**: 입력의 작은 변화가 해시값을 크게 변화시킴

2. 데이터 특성 분석

**입력 데이터 파악:**

```
- 데이터 타입: 정수, 문자열, 객체?
- 데이터 범위: 작은 범위? 큰 범위?
- 데이터 분포: 균등? 편향?
- 패턴 유무: 연속적? 규칙적?
```

**예시:**

- 학번(2024001~2024999): 연속적, 패턴 있음
- 전화번호: 앞자리 중복 많음
- 이름: 특정 문자 빈도 높음

 3. 주요 해시 함수 기법

(1) Division Method (나눗셈법)

java

```java
int hash(int key, int tableSize) {
    return key % tableSize;
}
```

**최적화 방법:**

- 테이블 크기를 **소수(prime number)**로 선택
- 2의 거듭제곱은 피할 것 (하위 비트만 사용되어 충돌 증가)

**좋은 예:** tableSize = 97, 101, 211 **나쁜 예:** tableSize = 100, 128, 256

(2) Multiplication Method (곱셈법)

java

```java
int hash(int key, int tableSize) {
    double A = 0.6180339887; // 황금비 (√5 - 1) / 2
    double temp = key * A;
    double fractional = temp - Math.floor(temp);
    return (int)(tableSize * fractional);
}
```

**장점:**

- 테이블 크기에 덜 민감
- A = 0.6180339887 (황금비)가 일반적으로 좋은 성능

(3) Universal Hashing

java

```java
int hash(int key, int tableSize) {
    int a = random_prime(); // 무작위 소수
    int b = random_number(); // 무작위 수
    int p = large_prime;     // 큰 소수
    
    return ((a * key + b) % p) % tableSize;
}
```

**장점:**

- 최악의 경우를 평균적으로 만듦
- 악의적인 입력에 강함

4. 문자열 해시 함수

(1) Polynomial Rolling Hash

java

```java
int hashString(String s, int tableSize) {
    int hash = 0;
    int prime = 31; // 또는 37, 53 등 작은 소수
    
    for (int i = 0; i < s.length(); i++) {
        hash = hash * prime + s.charAt(i);
    }
    
    return Math.abs(hash % tableSize);
}
```

**왜 31을 사용?**

- 작은 소수로 오버플로우 관리 용이
- 31 * x = (x << 5) - x (비트 연산으로 최적화 가능)
- Java String의 hashCode()가 사용

(2) Horner's Method 개선

java

```java
long hashString(String s, int tableSize) {
    long hash = 0;
    long prime = 31;
    long mod = 1_000_000_007; // 큰 소수
    
    for (int i = 0; i < s.length(); i++) {
        hash = (hash * prime + s.charAt(i)) % mod;
    }
    
    return (int)(hash % tableSize);
}
```
5. 복합 키 해시 함수

java

```java
class Person {
    String name;
    int age;
    String city;
    
    @Override
    public int hashCode() {
        int result = 17; // 0이 아닌 초기값
        
        // 각 필드에 다른 소수 곱하기
        result = 31 * result + (name != null ? name.hashCode() : 0);
        result = 31 * result + age;
        result = 31 * result + (city != null ? city.hashCode() : 0);
        
        return result;
    }
}
```

**원칙:**

- 0이 아닌 초기값 사용
- 각 필드마다 소수 곱하기
- null 처리

##### 해시값이 충돌했을 때, 어떤 방식으로 처리할 수 있을까요?
- 본인이 사용하는 언어에서는, 어떤 방식으로 해시 충돌을 처리하나요?
- Double Hashing 의 장점과 단점에 대해서 설명하고, 단점을 어떻게 해결할 수 있을지 설명해 주세요.
- Load Factor에 대해 설명해 주세요. 본인이 사용하는 언어에서의 해시 자료구조는 Load Factor에 관련한 정책이 어떻게 구성되어 있나요?
- 다른 자료구조와 비교하여, 해시 테이블은 멀티스레드 환경에서 심각한 수준의 Race Condition 문제에 빠질 위험이 있습니다. 성능 감소를 최소화 한 채로 해당 문제를 해결할 수 있는 방법을 설계해 보세요.

### 5. 트리와 이진트리, 이진탐색트리에 대해 설명해 주세요.

- 그래프와 트리의 차이가 무엇인가요?
- 이진탐색트리에서 중위 탐색을 하게 되면, 그 결과는 어떤 의미를 가지나요?
- 이진탐색트리의 주요 연산에 대한 시간복잡도를 설명하고, 왜 그런 시간복잡도가 도출되는지 설명해 주세요.
- 이진탐색트리의 한계점에 대해 설명해주세요.
- 이진탐색트리의 값 삽입, 삭제 방법에 대해 설명하고, 어떤식으로 값을 삽입하면 편향이 발생할까요?
- 이진탐색트리와 동일한 로직을 사용하면, 삼진탐색트리도 정의할 수 있을까요? 안 된다면, 그 이유에 대해 설명해 주세요.

### 6. 힙에 대해 설명해 주세요.

- 힙을 배열로 구현한다고 가정하면, 어떻게 값을 저장할 수 있을까요?
- 힙의 삽입, 삭제 방식에 대해 설명하고, 왜 이진탐색트리와 달리 편향이 발생하지 않는지 설명해 주세요.
- 힙 정렬의 시간복잡도는 어떻게 되나요? Stable 한가요?

### 7. BBST (Balanced Binary Search Tree) 와, 그 종류에 대해 설명해 주세요.
- Red Black Tree는 어떻게 균형을 유지할 수 있을까요?
- Red Black Tree의 주요 성질 4가지에 대해 설명해 주세요.
- 2-3-4 Tree, AVL Tree 등의 다른 BBST 가 있음에도, 왜 Red Black Tree가 많이 사용될까요?

### 8. 정렬 알고리즘에 대해 설명해 주세요.
- Quick Sort와 Merge Sort를 비교해 주세요.
- Quick Sort에서 O(N^2)이 걸리는 예시를 들고, 이를 개선할 수 있는 방법에 대해 설명해 주세요.
- Stable Sort가 무엇이고, 어떤 정렬 알고리즘이 Stable 한지 설명해 주세요.
- Merge Sort를 재귀를 사용하지 않고 구현할 수 있을까요?
- Radix Sort에 대해 설명해 주세요.
- Bubble, Selection, Insertion Sort의 속도를 비교해 주세요.
- 값이 **거의** 정렬되어 있거나, 아예 정렬되어 있다면, 위 세 알고리즘의 성능 비교 결과는 달라질까요?
- 본인이 사용하고 있는 언어에선, 어떤 정렬 알고리즘을 사용하여 정렬 함수를 제공하고 있을까요?
- 정렬해야 하는 데이터는 50G 인데, 메모리가 4G라면, 어떤 방식으로 정렬을 진행할 수 있을까요?