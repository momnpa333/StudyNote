## 기술 및 설계 관련 질문
### 1. @Async와 Redis INCR 활용 성능 개선 
##### 1. @Async를 쓰게된 이유에 대해 설명해 주세요
특정 유저의 프로필 페이지에 트래픽이 몰리면서 응답 지연 현상이 발생했습니다.  
분석 결과, 조회수 증가 로직이 트랜잭션 안에서 동기적으로 실행되면서 전체 응답 속도에 영향을 주고 있었고, Redis에 접근하여 값을 조회하고 다시 덮어쓰는 방식이었기 때문에 I/O 부하도 컸습니다.

이 문제를 해결하기 위해 `@Async`를 도입해 **조회수 증가 로직을 비동기 이벤트로 분리**했습니다.  
이렇게 함으로써 클라이언트는 실제로 필요한 응답을 빠르게 받을 수 있고, 조회수 처리는 별도로 처리되기 때문에 전체 응답 시간이 단축되었습니다.

특히, `@Async`와 함께 `Redisson Lock` 범위를 최소화하여 동시성 문제도 방지했습니다.  
그 결과 TPS가 약 580 → 1117로, 약 **192% 성능 개선**을 확인할 수 있었습니다.
##### 보충 설명 팁 (면접에서 추가 질문 대비):
> - `@Async`는 Spring에서 기본적으로 `TaskExecutor`를 사용해 별도의 쓰레드에서 작업을 수행하게 합니다.
> - 트랜잭션 안에서 비동기 메서드를 호출하면 새로운 트랜잭션 컨텍스트에서 실행되기 때문에, **비동기 메서드가 트랜잭션 범위에 포함되지 않도록 설계**하는 것이 중요합니다.

1. `@Async`를 사용할 때 트랜잭션 전파는 어떻게 되나요?
**모범 답변 예시:**
> `@Async`는 별도의 스레드에서 비동기적으로 실행되기 때문에, 기본적으로 호출한 쪽의 트랜잭션 컨텍스트를 **공유하지 않습니다.**  
> 즉, 호출한 서비스가 트랜잭션 범위 안에 있더라도, `@Async` 메서드는 **별도의 트랜잭션**에서 실행되며,  
> 트랜잭션 전파 속성(propagation)은 명시적으로 지정해주지 않으면 반영되지 않습니다.
> 
> 이로 인해, `@Async` 메서드에서 DB 작업을 할 경우 트랜잭션이 분리되어 의도하지 않은 결과가 발생할 수 있습니다.  
> 따라서 저는 조회수 증가처럼 **주 트랜잭션과 독립적으로 처리 가능한 작업**에만 `@Async`를 사용하고,  
> 데이터 정합성이 중요한 작업은 `@Async`를 피하고 있습니다.

---
 ✅ 2. 왜 Kafka나 메시지 큐가 아닌 `@Async`를 선택했나요?
**모범 답변 예시:**
> Kafka와 같은 메시지 큐는 대규모 시스템에서 비동기 이벤트를 안정적으로 처리할 수 있는 훌륭한 방법입니다.  
> 하지만 당시 프로젝트는 초기 단계였고, 메시지 지연이나 복잡한 운영 관리를 감당할 만큼의 트래픽은 아니었습니다.  
> 따라서 인프라 부담 없이 빠르게 적용 가능한 `@Async`를 선택했습니다.
> 
> 단순 비동기 처리가 목적이었고, 작업 실패 시 큰 영향을 주지 않는 로직이었기 때문에  
> Spring의 `@Async`로도 충분히 목적을 달성할 수 있었고, 실제로 성능도 크게 개선되었습니다.
> 
> 다만 추후 사용자 수가 증가하고 작업의 중요도가 높아진다면, **Kafka나 RabbitMQ 기반의 비동기 아키텍처로 전환**할 계획도 염두에 두고 있습니다.

 ✅ 3. `@Async`의 한계점은 무엇이라고 생각하시나요?

**모범 답변 예시:**

> `@Async`는 간단하게 비동기 처리를 구현할 수 있는 장점이 있지만, 몇 가지 한계점도 분명히 존재합니다.
> 
> 1. **장애 처리**: 기본적으로 예외를 별도로 핸들링하지 않으면 로그만 출력되며, 메인 흐름에서 인지할 수 없습니다.  
>     → 저는 `AsyncUncaughtExceptionHandler`를 설정해 로그를 남기고, 슬랙 알림을 보내도록 구성했습니다.
>     
> 2. **작업 보장 없음**: `@Async`는 작업이 실패했을 때 재시도나 보장 처리가 내장돼 있지 않습니다.  
>     반면 Kafka는 메시지 큐에 저장되어 재처리할 수 있어 안정성이 더 높습니다.
>     
> 3. **모니터링 어려움**: 쓰레드 풀이나 큐 상태에 대한 실시간 모니터링이 어렵기 때문에, 추후에는 별도의 대시보드 도입이 필요하다고 생각했습니다.
>
##### 2. Redis를 사용한 이유에 대해 설명해 주세요
Redis는 메모리 기반의 인메모리 데이터 저장소로, 읽기·쓰기 속도가 매우 빠르기 때문에 **짧은 시간 안에 반복적으로 접근되는 데이터 처리**에 적합합니다.

WHOKIE 프로젝트에서는 유저 프로필의 **조회수**를 기록하고 있었는데, 이 데이터는 다음과 같은 특징이 있었습니다:

1. **쓰기 빈도는 높지만, 정합성이 약간 느슨해도 되는 데이터**였고
    
2. DB I/O에 부담을 주지 않으면서 빠르게 업데이트할 수 있어야 했습니다.

이러한 특성을 고려했을 때, RDB에 바로 적재하기보다는 Redis를 활용하여 **조회수를 메모리 상에 캐싱하고, 주기적으로 DB에 반영하는 전략**이 적절하다고 판단했습니다.  
특히 `INCR` 명령어를 활용하여 **Race Condition 없이 Atomic하게 조회수 증가가 가능**했고,  
`Redisson Lock`을 통해 **멀티스레드 환경에서도 정합성을 유지**할 수 있었습니다.

이로 인해 TPS가 약 2배 가까이 향상되는 결과를 얻었습니다.  
Redis는 단순 캐시 외에도 분산락, Pub/Sub, 지연 큐 등 다양한 활용도가 있어 선택의 여지가 넓다고 생각합니다.

✅ 보충 설명 (면접관이 깊이 파고들 경우 대비)

**Q. Redis에 저장된 값이 유실될 수 있는데 괜찮나요?**

> 조회수와 같은 데이터는 약간의 유실이 있어도 서비스 품질에 큰 영향이 없다고 판단했습니다.  
> 필요하다면 RDB로 주기적으로 플러시하거나, RDB에 최종 값을 집계해 반영하는 구조로 보완할 수 있습니다.

**Q. Redis 대신 Memcached와 같은 캐시 솔루션은 왜 고려하지 않았나요?**

> Redis는 단순 키-값 저장을 넘어서 다양한 자료구조(list, set, sorted set 등)를 지원하고,  
> 영속성 옵션(RDB/AOF)과 분산락, Lua 스크립트 실행 등이 가능해 훨씬 유연하다고 판단했습니다.
##### 3. 분산락을 사용한 이유에 대해 설명해 주세요

### 2. 복합인덱스 사용 
##### 1. 전과 후의 차이에 대해 설명해 주세요
##### 2. 복합 인덱스를 사용한 이유
##### 3. 복합 인덱스를 걸때 단점은 어떻게 생각하는지
### 3. 퍼사드 패턴
##### 1. 퍼사드 패턴이 무엇인지 설명해 줘
##### 2. 사용한 이유에 대해 설명해줘
##### 3. 단점에 대해 알려줘
##### 4. 어떤 점이 개선 되었는지 알려줘


### 4. 약 4200만 더미데이터 처리 및 vuser 설정
##### 1. 더미 데이터를 처리하면서 있었던 이슈에 대해 설명해줘


### 5.**@Async를 사용할 때 주의해야 할 점은 무엇이라고 생각하시나요?**
    
    - 예외 처리, 트랜잭션 전파 등
## 협업 및 커뮤니케이션 관련 질문

1. **다른 팀원과 PR을 주고받으며 충돌이 생긴 경험이 있다면, 어떻게 해결하셨나요?**
    
2. **서비스 설계 중 팀원과 의견이 갈린 경험이 있다면, 어떤 식으로 조율했나요?**
    
3. **카카오테크캠퍼스에서 팀 프로젝트를 수행하면서 느낀 가장 큰 성장 포인트는 무엇이었나요?**
    
4. **오픈소스 기반의 기술이나 라이브러리를 도입할 때 팀에 어떻게 공유하고 설득하셨나요?**
    

---

## 프로젝트 경험 기반 질문 (WHOKIE 등)

1. **WHOKIE 프로젝트에서 본인이 맡은 역할과 주요 기여는 무엇인가요?**
    
2. **WHOKIE에서 성능 개선을 위해 어떤 메트릭을 기준으로 개선 여부를 판단했나요?**
    
3. **WHOKIE와 같은 소셜 플랫폼에서 사용자 경험(UX)을 어떻게 고려하며 개발하셨나요?**
    
4. **WHOKIE에서 처리한 더미 데이터가 4200만 건이라고 하셨는데, 이 데이터를 어떻게 생성하고 관리하셨는지 궁금합니다.**
    
---

## ✅ 문제 해결 역량 관련 질문

1. **외래키 제약조건 때문에 성능이 저하된 경험이 있다고 하셨는데, 이를 어떻게 해결하셨나요?**
    
2. **3시간 이상 소요되던 더미 데이터 처리를 20분으로 줄이기 위해 어떤 기술적 결정을 내리셨나요?**
    
3. **TPS 목표치를 만족하지 못했던 상황에서, 어떤 순서로 문제를 진단하고 해결해 나가셨나요?**
    
4. **성능 개선을 위한 ngrinder 테스트 시, 실제 트래픽을 어떻게 시뮬레이션하셨고 어떤 값을 기준으로 개선 여부를 판단하셨나요?**