### 1. 쿠키와 세션의 차이에 대해 설명해 주세요.
##### 설명
쿠키와 세션은 **웹에서 사용자의 상태(로그인 여부, 장바구니 정보 등)를 유지하기 위해 사용하는 기술**입니다. 하지만 동작 방식과 저장 위치가 다릅니다. 정리해 드리겠습니다.

---
 📌 쿠키(Cookie)

- **저장 위치**: 클라이언트(사용자 브라우저)에 저장
    
- **동작 방식**: 서버가 클라이언트에게 키-값 형태의 데이터를 응답 헤더(Set-Cookie)로 전달 → 이후 클라이언트는 요청 시 자동으로 쿠키를 포함해서 서버로 전송
    
- **특징**
    
    - 클라이언트에 저장되므로 서버 부하가 적음
        
    - 보안에 취약할 수 있음 (조작 가능, 탈취 가능 → HTTPS + HttpOnly, Secure 옵션으로 보완)
        
    - 용량 제한(브라우저마다 다르지만 보통 4KB 정도)
        
    - 만료 시간 설정 가능 (세션 쿠키: 브라우저 종료 시 삭제, 지속 쿠키: 설정된 만료 시간까지 유지)
        

---
📌 세션(Session)

- **저장 위치**: 서버에 저장 (일반적으로 메모리, Redis, DB 등)
    
- **동작 방식**:
    
    1. 사용자가 로그인하면 서버에서 세션을 생성하고 고유한 **세션 ID**를 발급
        
    2. 세션 ID는 클라이언트 측 쿠키에 저장됨(JSESSIONID 등)
        
    3. 이후 클라이언트가 요청을 보낼 때 세션 ID를 쿠키로 전달 → 서버가 해당 세션 ID로 사용자 정보를 조회
        
- **특징**
    
    - 중요한 데이터는 서버에만 저장되므로 비교적 안전
        
    - 서버 리소스를 사용하므로 사용자가 많을수록 서버 부담 증가
        
    - 브라우저를 종료하거나 일정 시간이 지나면 세션이 만료됨(타임아웃)
        

---
 📊 쿠키 vs 세션 비교

| 구분    | 쿠키(Cookie)        | 세션(Session)              |
| ----- | ----------------- | ------------------------ |
| 저장 위치 | 클라이언트(브라우저)       | 서버                       |
| 보안    | 상대적으로 취약          | 상대적으로 안전                 |
| 서버 부담 | 없음                | 있음 (메모리/스토리지 사용)         |
| 용량 제한 | 4KB 내외            | 제한 없음(서버 자원 한도 내)        |
| 유지 기간 | 만료 시간에 따라 다름      | 서버 설정된 타임아웃 동안 유지        |
| 활용 예시 | 자동 로그인, 사용자 맞춤 설정 | 로그인 유지, 장바구니, 인증된 사용자 정보 |

---

✅ **정리**
- **쿠키**는 클라이언트 쪽에 간단한 정보를 저장해두고 서버와 주고받는 데 사용.
- **세션**은 중요한 데이터를 서버에 저장하고 클라이언트는 세션 ID만 전달해서 식별.
- 보통은 **세션 기반 로그인 + 쿠키에 세션 ID 저장** 방식이 많이 쓰입니다.

세션 기반 로그인과 JWT 기반 로그인은 현대 웹 서비스에서 가장 많이 비교되는 인증 방식입니다. 차이점을 보안·성능·확장성 관점에서 정리해 드리겠습니다.

---
🔑 세션(Session) 기반 로그인

동작

- 로그인 시 서버가 세션을 생성하고 사용자 정보를 저장.
    
- 클라이언트는 세션 ID만 쿠키에 저장하고, 이후 요청마다 세션 ID를 서버로 전달.
    
- 서버가 세션 저장소에서 ID → 사용자 정보를 조회하여 인증.
    
✅ 장점

- **보안성 높음**: 클라이언트는 세션 ID만 가지고 있으므로 실제 정보 노출 위험이 낮음.
    
- **상태 관리 용이**: 로그인뿐 아니라 장바구니, 임시 데이터 등 다양한 상태 저장 가능.
    
- **세션 무효화 쉬움**: 서버에서 세션 삭제하면 즉시 로그아웃 처리 가능.
    

❌ 단점

- **확장성 문제**: 서버 여러 대 운영 시 세션 동기화 필요 (Sticky Session, Redis 같은 중앙 저장소 필요).
    
- **서버 리소스 부담**: 사용자 수가 많으면 세션 저장소 관리 비용 증가.
    

🪙 JWT(JSON Web Token) 기반 로그인

동작

- 로그인 성공 시 서버가 **JWT(서명된 토큰)**를 발급하여 클라이언트에 전달.
    
- 클라이언트는 JWT를 쿠키나 LocalStorage 등에 저장.
    
- 이후 요청 시 JWT를 함께 전송 → 서버는 토큰 검증(서명 확인)만으로 사용자 인증.
    
✅ 장점

- **무상태(Stateless)**: 서버에 별도 세션 저장 필요 없음 → 확장성이 뛰어남 (서버 증설/로드밸런싱에 유리).
    
- **빠른 인증**: DB/Redis 조회 없이 토큰만 검증하면 됨.
    
- **다중 서비스 연동 용이**: 마이크로서비스 아키텍처(MSA)에서 중앙 인증 서버가 JWT 발급 → 각 서비스가 독립적으로 검증 가능.
    
❌ 단점

- **토큰 크기**: JWT는 서명·페이로드 포함 → 세션 ID보다 큼, 매 요청마다 전송되어 네트워크 부하 발생 가능.
    
- **보안 관리 난이도**:
    
    - 탈취되면 만료 전까지 무조건 유효 → 서버에서 강제로 무효화하기 어려움 (블랙리스트 관리 필요).
        
    - LocalStorage 저장 시 XSS에 취약.
        
- **변경 불가**: 한 번 발급된 JWT는 수정 불가 → 사용자 권한 변경 시 반영 어려움(Refresh Token 전략 필요).
    

---
📊 세션 vs JWT 비교 요약

|구분|세션(Session)|JWT|
|---|---|---|
|저장 위치|서버(세션 저장소)|클라이언트|
|서버 확장성|낮음 (세션 동기화 필요)|높음 (무상태)|
|서버 부하|많음 (세션 관리)|적음 (토큰 검증만)|
|인증 속도|세션 조회 필요|서명 검증만으로 빠름|
|보안성|높음 (서버 관리)|중간 (탈취 시 만료 전까지 위험)|
|무효화 용이성|쉬움 (서버에서 세션 삭제)|어려움 (블랙리스트/만료 관리 필요)|
|토큰 크기|작음 (세션 ID)|큼 (페이로드 포함)|
|활용 예시|전통적인 웹/모놀리식 앱|MSA, 모바일, API 서버 간 인증|

---

✅ **정리**

- **세션 기반**: 보안이 중요하고 서버 규모가 크지 않은 경우 적합 (예: 기업 내부 시스템, 소규모 웹 서비스).
    
- **JWT 기반**: 확장성과 API 간 인증이 중요한 경우 적합 (예: 모바일 앱 + 서버, MSA 환경, 대규모 분산 서비스).
##### 세션 방식의 로그인 과정에 대해 설명해 주세요.
세션(Session) 방식의 로그인은 **서버가 사용자 인증 상태를 직접 관리하는 방식**입니다. 과정별로 단계적으로 정리해 드리겠습니다.

---
 🔑 세션 기반 로그인 과정
 1. 로그인 요청

- 사용자가 로그인 페이지에서 **아이디/비밀번호**를 입력하여 서버로 전송합니다.
    
- 일반적으로 **POST /login** 요청을 통해 전달되며, 이때는 아직 세션이 없습니다.
    

---
2. 인증 처리

- 서버는 DB 등에 저장된 사용자 정보를 확인하여 **아이디/비밀번호 일치 여부**를 검증합니다.
    
- 검증에 성공하면 새로운 **세션(Session 객체)**을 생성하고, 사용자 정보를 세션에 저장합니다.
    
    - 예: `session.setAttribute("userId", 1234)`
        

---
 3. 세션 ID 발급

- 서버는 생성된 세션에 대한 고유한 식별자(**세션 ID**)를 만듭니다.
    
- 이 세션 ID를 응답 헤더의 `Set-Cookie`에 담아 브라우저로 전송합니다.
    
    - 예: `Set-Cookie: JSESSIONID=abc123xyz; HttpOnly; Secure`
        
- 브라우저는 이 쿠키를 저장합니다.
    

---
4. 인증된 요청

- 이후 사용자가 다른 페이지 요청을 보낼 때마다 브라우저는 자동으로 쿠키(JSESSIONID)를 포함해 서버에 요청을 보냅니다.
    
- 서버는 세션 저장소(메모리, Redis, DB 등)에서 **세션 ID → 세션 객체**를 찾아 사용자 정보를 확인합니다.
    
- 이를 통해 서버는 사용자를 식별하고 로그인 상태를 유지할 수 있습니다.
    

---
 5. 로그아웃 / 세션 만료

- 사용자가 로그아웃하면 서버는 세션을 삭제합니다.
    
- 또는 설정된 **세션 타임아웃(예: 30분)**이 지나면 자동으로 세션이 만료됩니다.
    
- 만료되면 쿠키에 세션 ID가 있어도 더 이상 유효하지 않으므로 다시 로그인해야 합니다.
    

---
 📊 요약 (흐름도 형태)

1. 클라이언트 → 서버: 아이디/비밀번호 전송
    
2. 서버: 사용자 검증 → 세션 생성 → 세션 ID 발급
    
3. 서버 → 클라이언트: 세션 ID를 쿠키에 담아 응답
    
4. 클라이언트: 쿠키(JSESSIONID) 저장
    
5. 이후 요청 시 쿠키 자동 전송 → 서버에서 세션 조회로 로그인 상태 유지
    
6. 로그아웃 or 세션 만료 → 세션 삭제
    

---

✅ **핵심 포인트**

- 실제 사용자 정보(아이디, 권한 등)는 **서버 세션 저장소에 저장**
    
- 클라이언트에는 **세션 ID(토큰 역할)**만 쿠키로 저장
    
- 따라서 **보안상 쿠키 조작으로는 서버의 세션 정보를 바꿀 수 없음**
##### HTTP의 특성인 Stateless에 대해 설명해 주세요.
좋은 질문입니다 👍  
HTTP의 핵심적인 특징 중 하나가 바로 **Stateless(무상태성)**입니다. 차근차근 설명드리겠습니다.

---
📌 Stateless란 무엇인가?

- **Stateless**란, **서버가 클라이언트의 이전 요청 상태를 보존하지 않는 특성**을 말합니다.
    
- 즉, HTTP 요청(Request) 하나하나는 독립적으로 처리되며, 서버는 **이전 요청과 현재 요청을 연결해서 기억하지 않습니다.**
    
- 매 요청은 완전히 새로운 요청으로 간주되고, 필요한 모든 정보가 요청에 포함되어야 합니다.
    

---
📌 Stateless의 특징

1. **독립성**
    
    - 각 요청은 독립적으로 처리됨 → 이전 요청의 맥락(Context)을 서버가 기억하지 않음.
        
2. **무상태성**
    
    - 서버는 클라이언트의 로그인 상태, 세션 정보 등을 기본적으로 저장하지 않음.
        
3. **요청에 필요한 정보 포함**
    
    - 클라이언트가 서버에 요청할 때, 인증/파라미터 등 필요한 정보를 항상 함께 보내야 함.
        

---
 📌 장점

- **서버 확장성(Scalability) 향상**:  
    서버가 클라이언트 상태를 기억할 필요가 없으므로, 여러 서버를 두어도 부하 분산이 쉽습니다.
    
- **단순함(Simple)**:  
    서버는 요청만 처리하면 되고, 별도의 상태 관리 로직이 필요 없습니다.
    
- **유연한 서비스**:  
    클라이언트가 어느 서버에 요청하더라도 같은 응답을 받을 수 있습니다. (Load Balancing에 적합)
    

---
📌 단점

- **상태 유지가 필요한 경우 불편**  
    예: 로그인, 장바구니 등 "이전 요청의 맥락"이 필요한 경우, HTTP의 Stateless 특성만으로는 부족합니다.
    
- **추가 메커니즘 필요**  
    → 그래서 등장한 것이 **쿠키, 세션, JWT** 등 상태를 유지하기 위한 기술입니다.
    

---
 📌 예시

- 사용자가 로그인 후 "내 정보 조회" 요청을 보낸다고 가정해 봅시다.
    
- **Stateless 환경**이라면 서버는 이전 로그인 사실을 기억하지 않으므로,  
    매번 요청에 로그인 정보(아이디/비밀번호 or 토큰 등)를 포함해야 합니다.
    

---

✅ **정리**

- **HTTP는 기본적으로 Stateless**: 요청과 응답 간에 상태를 저장하지 않음.
    
- **장점**: 단순성, 확장성, 부하 분산 용이.
    
- **단점**: 로그인/장바구니처럼 상태 유지가 필요한 경우 불편 → 이를 해결하기 위해 쿠키/세션/JWT 같은 보조 기술 사용.
##### Stateless의 의미를 살펴보면, 세션은 적절하지 않은 인증 방법 아닌가요?
HTTP의 **Stateless(무상태성)**와 **세션(Session) 기반 인증**은 얼핏 보면 서로 상충하는 개념처럼 보입니다. 하지만 실제 서비스에서는 **Stateless 특성을 유지하면서도 상태 유지가 필요한 요구사항을 해결하기 위해 세션을 도입**하는 것이죠. 정리해 드리겠습니다.

---
📌 Stateless의 원칙

- HTTP는 본질적으로 **Stateless**: 서버는 클라이언트의 요청 간 상태를 기억하지 않습니다.
    
- 따라서 각 요청은 독립적이며, 서버는 "이전 요청에서 로그인 했는지" 같은 맥락을 알 수 없습니다.
    
- 원칙적으로라면, **클라이언트는 매 요청마다 인증 정보를 모두 포함해야 한다**는 의미입니다. (예: `Authorization` 헤더에 토큰)
    

---
 📌 세션(Session) 기반 인증은 왜 Stateless와 어긋나는가?

- 세션은 서버가 **사용자의 로그인 상태를 서버 저장소에 유지**하는 방식입니다.
    
- 즉, 서버가 클라이언트의 상태(로그인 여부, 사용자 ID 등)를 "기억"하는 것이므로 **Strict한 의미에서 Stateless와는 맞지 않습니다.**
    
- 서버 간 확장 시 세션 동기화 문제(Sticky Session, Redis 공유 등)가 생기는 이유도 바로 상태를 서버가 보관하기 때문입니다.
    

---
📌 그럼에도 세션이 널리 쓰이는 이유

1. **보안성**
    
    - 서버가 직접 상태를 관리하므로 토큰 탈취, 위·변조 위험이 상대적으로 적습니다.
        
2. **구현 용이성**
    
    - 초기 웹 애플리케이션(모놀리식 구조)에서는 서버 메모리에 세션 저장하는 방식이 가장 단순하고 직관적이었음.
        
3. **서비스 요구사항 충족**
    
    - 로그인 유지, 장바구니, 맞춤형 서비스 같은 기능은 **상태(state)** 없이는 구현하기 어렵기 때문입니다.
        

---
📌 대안: JWT와 같은 토큰 기반 인증

- **JWT 기반 인증**은 **Stateless 원칙에 더 부합**합니다.
    
    - 서버는 상태를 저장하지 않고, 클라이언트가 JWT를 매 요청마다 전송.
        
    - 서버는 단순히 토큰의 서명을 검증하는 것만으로 인증을 수행.
        
- 다만, JWT는 무효화가 어렵고 탈취 시 보안 문제가 있으므로, Refresh Token, 블랙리스트 등 보완 장치가 필요합니다.
    

---
📊 정리

- **Stateless 원칙**: 서버는 요청 간 상태를 기억하지 않는다.
    
- **세션 인증**: 서버가 상태(로그인)를 저장하므로 원칙과는 다소 어긋남.
    
- **실무 선택**:
    
    - **소규모/전통 웹**: 세션 기반 → 구현 간단, 보안 용이.
        
    - **대규모/분산 시스템(MSA, 모바일, API 서버)**: JWT 기반 → 확장성, Stateless에 가까움.
        

---

👉 따라서 면접에서 답변할 때는 이렇게 말하면 좋습니다:  
“**세션은 HTTP의 Stateless 특성과는 어긋나는 방식이지만, 보안성과 편의성 때문에 오랫동안 표준적인 로그인 방식으로 사용되었습니다. 반면 JWT 같은 토큰 기반 인증은 Stateless 원칙에 더 충실해 대규모 분산 환경에서 적합합니다.**”
##### 규모가 커져 서버가 여러 개가 된다면, 세션을 어떻게 관리할 수 있을까요?
단일 서버 환경에서는 세션을 서버 메모리에 두면 간단하지만, **규모가 커져 서버가 여러 대(멀티 서버, 분산 환경)**가 되면 문제가 생깁니다.  
왜냐하면, 사용자가 A 서버에서 로그인했더라도, 다음 요청이 B 서버로 가면 세션 정보가 없기 때문입니다.  
이를 해결하기 위해 몇 가지 방법이 있습니다.

---
 📌 세션 관리 방식 (멀티 서버 환경)
1. **Sticky Session (세션 고정화)**

- **로드밸런서**가 클라이언트의 요청을 항상 같은 서버로 전달하도록 함.
    
- 즉, A 서버에서 로그인한 사용자는 이후에도 계속 A 서버로만 요청이 가도록 설정.
    
- **장점**: 구현 간단, 기존 세션 관리 방식 그대로 사용 가능.
    
- **단점**: 특정 서버에 부하 집중, 서버 장애 시 세션 유실 위험.
    

---
 2. **세션 복제(Session Replication)**

- 각 서버가 자신의 세션을 다른 서버와 **동기화(복제)**하여 동일한 세션 정보를 유지.
    
- 사용자가 A 서버에서 로그인해도, B/C 서버에 세션이 자동 반영됨.
    
- **장점**: 장애 대응 가능, 어느 서버로 가도 동일 세션 유지.
    
- **단점**: 서버 간 네트워크 트래픽과 동기화 비용이 크다. (사용자 많아지면 비효율적)
    

---
3. **공유 세션 저장소 사용 (가장 많이 쓰임)**

- 세션을 서버 메모리에 두지 않고, **외부 저장소(공유 DB, Redis, Memcached 등)**에 저장.
    
- 각 서버는 클라이언트의 세션 ID를 받아서 이 저장소에서 사용자 정보를 조회.
    
- **장점**: 확장성 높음, 서버 장애에도 세션 유지.
    
- **단점**: 저장소 장애 시 전체 서비스에 영향 → 보통 Redis 클러스터 같은 고가용성 구조 사용.
    
- **실무 표준**: 대부분 Redis 같은 인메모리 DB를 세션 저장소로 활용.
    

---
4. **세션 대신 JWT 같은 토큰 기반 인증 사용**

- 아예 세션 저장 자체를 없애고, 클라이언트가 인증 정보를 담은 토큰(JWT)을 요청마다 전송.
    
- 서버는 상태를 저장하지 않고, 토큰 검증만으로 인증 처리 → Stateless 보장.
    
- **장점**: 확장성 최강, 서버 간 동기화 필요 없음.
    
- **단점**: 토큰 무효화가 어렵고, 탈취 시 위험 → Refresh Token, 블랙리스트 관리 필요.
    

---
📊 비교 요약

|방법|특징|장점|단점|
|---|---|---|---|
|Sticky Session|특정 서버에 묶음|구현 간단|서버 장애 시 세션 유실, 부하 불균형|
|세션 복제|서버 간 세션 동기화|장애 대응 가능|동기화 비용 큼|
|공유 저장소 (Redis 등)|중앙 저장소에 세션 저장|확장성, 장애 대응|저장소 의존성 ↑|
|JWT|세션 없이 토큰 기반 인증|완전 Stateless, 확장성 최강|무효화 어려움, 탈취 시 위험|

---

✅ **정리**  
규모가 커진다면 보통 **공유 세션 저장소(특히 Redis)**를 두고, 세션을 중앙에서 관리하는 방식이 가장 일반적입니다.  
더 나아가 마이크로서비스 환경에서는 **JWT 같은 토큰 기반 인증**으로 넘어가는 경우가 많습니다.

---

면접에서 이 질문을 받는다면 이렇게 답하면 좋습니다:  
“**멀티 서버 환경에서는 Sticky Session, 세션 복제, 공유 세션 저장소 같은 방식을 고려할 수 있습니다. 특히 실무에서는 Redis 같은 인메모리 저장소를 세션 서버로 두는 방식이 가장 흔하고, 더 큰 규모로 가면 JWT 기반 인증을 도입하여 Stateless를 보장하는 경우도 많습니다.**”
### 2. HTTP 응답코드에 대해 설명해 주세요.
##### 설명
📌 HTTP 응답 코드 분류

1xx : Informational (정보)

- 요청을 잘 받았으며, 계속 진행 중임을 알림.
    
- **예시**
    
    - **100 Continue**: 요청의 일부를 받았으니 계속 전송하라는 의미. (대용량 업로드 시 유용)
        
    - **101 Switching Protocols**: 프로토콜 전환(WebSocket 등).
        

---
2xx : Success (성공)

- 클라이언트의 요청이 성공적으로 처리됨.
    
- **예시**
    
    - **200 OK**: 요청 성공 (가장 일반적).
        
    - **201 Created**: 요청 성공, 새로운 리소스가 생성됨 (POST로 회원가입, 글쓰기 등).
        
    - **204 No Content**: 요청 성공했지만 응답 본문 없음 (예: DELETE 요청).
        

---
 3xx : Redirection (리다이렉션)

- 요청한 리소스가 다른 위치로 이동했음을 알려줌. 클라이언트는 새로운 URL로 재요청 필요.
    
- **예시**
    
    - **301 Moved Permanently**: 리소스가 영구적으로 다른 URL로 이동.
        
    - **302 Found**: 일시적으로 다른 URL 사용.
        
    - **304 Not Modified**: 클라이언트 캐시 사용해도 됨 (조건부 GET 요청 시).
        

---
4xx : Client Error (클라이언트 오류)

- 클라이언트 잘못된 요청. (URI 오류, 권한 부족, 잘못된 데이터 등)
    
- **예시**
    
    - **400 Bad Request**: 잘못된 요청 (파라미터 오류, 형식 오류 등).
        
    - **401 Unauthorized**: 인증 필요 (로그인 안 함, 토큰 없음/잘못됨).
        
    - **403 Forbidden**: 인증했지만 권한 없음 (접근 금지).
        
    - **404 Not Found**: 요청한 리소스 없음.
        
    - **405 Method Not Allowed**: 허용되지 않은 HTTP 메서드 사용.
        

---
5xx : Server Error (서버 오류)

- 서버에서 요청을 처리하는 도중 문제가 발생.
    
- **예시**
    
    - **500 Internal Server Error**: 일반적인 서버 오류.
        
    - **502 Bad Gateway**: 게이트웨이/프록시 서버가 잘못된 응답을 받음.
        
    - **503 Service Unavailable**: 서버 과부하, 점검 중.
        
    - **504 Gateway Timeout**: 게이트웨이/프록시 서버가 응답을 제때 받지 못함.
        

---
📊 요약표

| 구분  | 범위      | 의미       | 대표 코드                                                               |
| --- | ------- | -------- | ------------------------------------------------------------------- |
| 1xx | 100~199 | 정보 전달    | 100 Continue                                                        |
| 2xx | 200~299 | 성공       | 200 OK, 201 Created                                                 |
| 3xx | 300~399 | 리다이렉션    | 301 Moved Permanently, 302 Found                                    |
| 4xx | 400~499 | 클라이언트 오류 | 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found     |
| 5xx | 500~599 | 서버 오류    | 500 Internal Server Error, 502 Bad Gateway, 503 Service Unavailable |

---

✅ **정리**

- 1xx: 진행 중 알림
    
- 2xx: 성공
    
- 3xx: 다른 곳으로 이동
    
- 4xx: 클라이언트 잘못
    
- 5xx: 서버 잘못
##### 401 (Unauthorized) 와 403 (Forbidden)은 의미적으로 어떤 차이가 있나요?
📌 401 Unauthorized

- **의미**: _"인증(Authentication)이 필요하다"_
    
- 서버가 사용자를 **식별할 수 없거나**, 제공한 인증 정보가 유효하지 않은 경우 발생합니다.
    
- 즉, "누군지 모르겠다 → 먼저 로그인부터 해라"에 해당합니다.
    
- **예시 상황**
    
    - 로그인하지 않은 사용자가 인증이 필요한 API 호출.
        
    - 잘못된 토큰/만료된 토큰을 보낸 경우.
        
    - 잘못된 아이디/비밀번호 입력 시.
        

👉 해결 방법: **올바른 인증 정보(로그인, 토큰 등)를 제공**해야 함.

---
 📌 403 Forbidden

- **의미**: _"인증은 되었지만, 권한(Authorization)이 부족하다"_
    
- 서버는 사용자를 알고 있고 인증도 성공했지만, 요청한 자원에 접근할 권한이 없을 때 발생합니다.
    
- 즉, "누군지는 알겠는데, 이 자원은 네 권한 밖이야"에 해당합니다.
    
- **예시 상황**
    
    - 일반 사용자가 관리자(admin) 전용 페이지 접근 시.
        
    - 특정 게시물은 본인만 볼 수 있는데, 다른 사용자가 접근했을 때.
        
    - 권한 레벨이 낮은 사용자가 금지된 API 호출.
        

👉 해결 방법: **권한을 부여하거나 요청 자원 접근 자체를 막아야 함.**

---
📊 요약 비교

| 코드                   | 이름    | 의미              | 상황                 |
| -------------------- | ----- | --------------- | ------------------ |
| **401 Unauthorized** | 인증 실패 | "누군지 몰라"        | 로그인 안 함, 잘못된/만료 토큰 |
| **403 Forbidden**    | 권한 거부 | "누군진 알지만 권한 없음" | 일반 유저가 관리자 기능 접근   |

---

✅ **정리**

- **401 → 인증(Authentication) 문제**: "로그인 필요"
    
- **403 → 인가(Authorization) 문제**: "권한 부족"
    

---

면접 대비 짧게 답한다면 이렇게 말할 수 있습니다:

> **401은 인증이 안 된 상태(로그인 필요), 403은 인증은 되었지만 권한이 없는 상태를 의미합니다.**
##### 200 (ok) 와 201 (created) 의 차이에 대해 설명해 주세요.
📌 200 OK

- **의미**: 요청이 정상적으로 처리되었음을 의미.
    
- 가장 범용적으로 사용되는 응답 코드.
    
- 보통 **조회(READ)**, **수정(UPDATE)**, **삭제(DELETE)** 같은 요청에서 많이 사용됨.
    
- **예시 상황**
    
    - `GET /users/1` → 해당 유저 정보 반환 성공.
        
    - `PUT /users/1` → 수정 성공 후 결과 반환.
        
    - `DELETE /users/1` → 삭제 성공 후 결과 반환.
        

👉 핵심: **리소스의 생성이 일어나지 않고**, 기존 리소스를 정상적으로 조회/수정/삭제했을 때 사용.

---
📌 201 Created

- **의미**: 요청 성공 + **새로운 리소스가 생성되었음**을 의미.
    
- 보통 **생성(CREATE)** 요청 (`POST`)에서 사용됨.
    
- 응답 시에는 보통 **Location 헤더**에 생성된 리소스의 URI를 포함하는 것이 REST Best Practice.
    
- **예시 상황**
    
    - `POST /users` → 새로운 유저가 생성됨 → **201 Created** + `Location: /users/123`
        
    - `POST /articles` → 새 게시글 작성됨 → **201 Created** + 생성된 게시글 내용 반환
        

👉 핵심: **새로운 리소스가 생성되었을 때** 반드시 201을 사용.

---
📊 비교 요약

| 코드              | 의미             | 사용 상황               | 예시                             |
| --------------- | -------------- | ------------------- | ------------------------------ |
| **200 OK**      | 요청 성공          | 조회/수정/삭제 등 일반 요청    | `GET /users/1`, `PUT /users/1` |
| **201 Created** | 요청 성공 + 리소스 생성 | 리소스가 새로 생길 때 (POST) | `POST /users` → 새 유저 생성        |

---

✅ **정리**

- **200 OK** → 요청 성공 (리소스 상태가 변하지 않거나 단순히 갱신된 경우)
    
- **201 Created** → 요청 성공 + 새로운 리소스 생성됨 (생성된 리소스 위치를 알려주는 게 권장됨)
    

---

면접에서 짧게 답변한다면 이렇게 말하면 좋습니다:

> **200은 요청 성공을 의미하고, 201은 성공과 동시에 새로운 리소스가 생성되었음을 의미합니다. 예를 들어 GET/PUT/DELETE는 200, POST는 보통 201을 사용합니다.**
##### 필요하다면 저희가 직접 응답코드를 정의해서 사용할 수 있을까요? 예를 들어 285번 처럼요.
HTTP 응답코드(Status Code)는 **IANA(Internet Assigned Numbers Authority)**에서 표준으로 관리합니다. 그래서 **100~599 범위의 상태 코드는 표준에 정의된 의미를 따라야 하고**, 임의로 정의해서 사용하면 브라우저나 클라이언트 라이브러리에서 오해가 생길 수 있습니다.

---
📌 1. 응답 코드 범위

- **100~599**: HTTP 표준에서 예약된 영역 (이미 정의된 코드들).
    
- **600 이상**: 표준이 아닌 영역. 클라이언트는 보통 알 수 없는 코드로 처리합니다.
    

---
📌 2. 임의 코드 정의 가능 여부

- **기술적으로는 가능**합니다. 서버는 285 같은 코드를 응답으로 내려줄 수 있습니다.
    
- 하지만 클라이언트(브라우저, HTTP 라이브러리)가 이 코드를 인식하지 못하면 **"알 수 없는 상태 코드"**로만 처리하고, 의미를 해석하지 못합니다.
    
- 예: 브라우저는 2xx면 성공, 4xx면 클라이언트 오류, 5xx면 서버 오류로 범주를 구분합니다.
    
    - 따라서 285는 "2xx 범위 → 성공" 정도로만 이해됩니다.
        

---
 📌 3. 실무에서 권장되는 방식

1. **표준 코드 내에서 의미를 맞춰 쓰기**
    
    - 예를 들어 `200 OK`, `202 Accepted`, `422 Unprocessable Entity` 등 이미 존재하는 코드를 상황에 맞게 사용하는 게 최선.
        
    - REST API 설계 가이드에서도 "가급적 표준 코드 사용"을 강하게 권장합니다.
        
2. **표준 코드 + 응답 바디 활용**
    
    - 세부적인 비즈니스 상황은 응답 바디(JSON 등)에 커스텀 에러 코드를 정의해 전달합니다.
        
    - 예:
        
        `{   "errorCode": "USER-285",   "message": "비밀번호 5회 이상 틀림" }`
        
    - 이렇게 하면 클라이언트가 표준 코드(예: 403 Forbidden)로 1차 처리하고, 바디의 커스텀 코드를 통해 세부 상황을 구분할 수 있습니다.
        
3. **헤더 활용**
    
    - 필요하다면 커스텀 헤더(`X-Error-Code`)를 정의해 추가 정보를 제공할 수도 있습니다.
        

---
📊 정리

- 285 같은 응답 코드를 **기술적으로는 정의할 수 있지만**, **표준이 아니므로 권장되지 않습니다.**
    
- 보통은 **표준 HTTP Status Code + 응답 바디의 커스텀 에러 코드** 조합을 사용합니다.
    
- 예: 로그인 실패 시 → `401 Unauthorized` + JSON 바디에 `"errorCode": "AUTH-001"`
    

---

👉 면접에서 답할 때는 이렇게 말하면 좋습니다:

> “HTTP 응답코드는 표준에 따라 해석되므로 285처럼 임의로 정의하는 것은 권장되지 않습니다. 대신 표준 코드를 사용하면서, 추가적인 의미가 필요하다면 응답 바디에 별도의 커스텀 에러 코드를 정의해 전달하는 것이 일반적인 방식입니다.”
맞습니다 🙂  
말씀처럼 **클라이언트와 서버가 미리 약속만 한다면, 285 같은 비표준 상태 코드를 사용하는 것도 기술적으로는 가능합니다.**  
즉, 서버가 `285`를 내리고 클라이언트가 `"아, 이건 우리 서비스에서 비밀번호 5회 이상 틀린 상태구나"`라고 이해할 수 있다면 기능적으로 동작하는 데는 문제가 없습니다.

하지만 여기에는 **표준과 실무적인 관점에서의 리스크**가 존재합니다.

---

📌 클라이언트와 약속하면 충분하지 않은 이유

1. **표준성 저하**
    
    - HTTP는 전 세계적으로 표준화된 프로토콜입니다.
        
    - 상태 코드를 임의로 정의하면, API Gateway, 로드밸런서, 보안 장비, 모니터링 시스템 같은 **중간 장치들이 해석하지 못하는 상태**가 생깁니다.
        
    - 예: `285`는 표준이 아니므로 모니터링 도구에서는 단순히 `"Unknown 2xx code"`로만 기록됩니다.
        
2. **호환성 문제**
    
    - 다른 팀이나 외부 시스템에서 API를 사용할 경우, `285`의 의미를 알지 못하면 혼란이 생깁니다.
        
    - 특히 SDK, 라이브러리(fetch, axios, OkHttp 등)는 2xx 범위를 그냥 `"성공"`으로 처리해 버립니다 → 클라이언트는 의도한 분기 처리를 못할 수 있습니다.
        
3. **장기 유지보수의 어려움**
    
    - 지금은 “우리 클라이언트만 쓰니까 괜찮아”라고 해도, 나중에 API를 공개하거나, 다른 시스템과 연동해야 한다면 문제가 됩니다.
        
    - REST API Best Practice 문서나 Swagger/OpenAPI 문서에서도 비표준 상태코드는 권장하지 않습니다.
        

---
📌 실무에서의 대안 (Best Practice)

👉 그래서 실무에서는 다음과 같은 방식을 씁니다:

- **표준 Status Code 사용**:
    
    - 예: 인증 실패 시 `401 Unauthorized`, 권한 부족 시 `403 Forbidden`
        
- **세부 에러는 바디에서 정의**:
    
    `{   "errorCode": "AUTH-005",   "message": "비밀번호 5회 이상 틀림" }`
    
    - 이렇게 하면 **표준 해석 가능 + 클라이언트와의 상세 약속도 가능**합니다.
        

---
📊 정리

- **클라이언트와 서버가 약속하면 비표준 코드(285 등)도 사용 가능**합니다.
    
- 하지만 **표준 해석 불가, 호환성 문제, 유지보수 문제** 때문에 권장되지 않습니다.
    
- 따라서 **실무에서는 표준 상태코드를 쓰고, 추가 의미는 바디(JSON 등)에서 커스텀 코드로 정의**하는 방식을 선택합니다.
    

---

👉 면접 답변 팁:  
“**285 같은 비표준 코드를 내려도 클라이언트와 약속하면 동작은 합니다. 다만 HTTP는 표준 프로토콜이라 중간 장비나 라이브러리가 알 수 없는 상태가 되어버립니다. 그래서 보통은 표준 Status Code를 지키고, 세부 상황은 응답 바디의 커스텀 코드로 표현하는 것이 가장 실무적입니다.**”

### 3. HTTP Method 에 대해 설명해 주세요.
##### 설명
좋은 질문입니다 🙂  
HTTP Method(메서드)는 **클라이언트가 서버의 리소스에 대해 어떤 동작을 요청하는지 표현하는 방식**입니다.  
즉, 같은 URL(예: `/users`)이라도 메서드에 따라 의미가 달라집니다.

---
📌 주요 HTTP 메서드
 1. **GET**

- 리소스 조회(Read)
    
- 요청 본문(body) 없음, 필요한 데이터는 보통 쿼리 파라미터(`?id=1`)로 전달
    
- 응답에 리소스 데이터가 담김
    
- **특징**:
    
    - 멱등성(Idempotent) 보장 (몇 번 요청해도 결과 동일)
        
    - 캐싱 가능        

---
2. **POST**

- 리소스 생성(Create)
    
- 요청 본문(body)에 데이터 포함하여 서버에 전송
    
- 서버는 새로운 리소스를 만들고 보통 `201 Created` 반환
    
- **특징**:
    
    - 멱등성이 없음 (같은 요청을 여러 번 보내면 데이터가 중복 생성될 수 있음)
---
3. **PUT**

- 리소스 전체 수정(Update)
    
- 요청 본문에 해당 리소스를 **완전히 대체할 데이터**를 담음
    
- 예: `PUT /users/1` → user 1번의 모든 속성을 새 데이터로 교체
    
- **특징**:
    
    - 멱등성 있음 (같은 요청을 여러 번 보내도 결과 동일)
        

---
4. **PATCH**

- 리소스 부분 수정(Partial Update)
    
- 리소스의 일부분만 변경할 때 사용
    
- 예: `PATCH /users/1` → user 1번의 `email`만 수정
    
- **특징**:
    
    - 멱등성을 보장하지 않을 수도 있음 (구현 방식에 따라 다름)
        

---
5. **DELETE**

- 리소스 삭제(Delete)
    
- 예: `DELETE /users/1` → user 1번 삭제
    
- **특징**:
    
    - 멱등성 있음 (같은 요청 여러 번 보내도 결과는 "삭제됨")
        

---
6. **HEAD**

- GET과 동일하지만 응답 본문(body)을 반환하지 않음
    
- 주로 **메타데이터(헤더)만 확인**할 때 사용 (파일 크기 확인, 리소스 존재 여부 체크 등)
    

---
7. **OPTIONS**

- 서버가 해당 리소스에 대해 지원하는 메서드를 알려줌
    
- 예: `OPTIONS /users` → `Allow: GET, POST, PUT, DELETE`
    
- **CORS(교차 출처 요청)** 사전 요청(Preflight Request)에서 사용
    

---
8. **TRACE**

- 요청이 서버까지 도달하는 경로를 따라 그대로 되돌려주는 메서드 (디버깅용)
    
- 보안상의 이유로 거의 사용되지 않음
    

---
📊 정리 (CRUD 매핑)

|Method|동작|CRUD 매핑|특징|
|---|---|---|---|
|GET|조회|READ|멱등성 있음, 캐싱 가능|
|POST|생성|CREATE|멱등성 없음|
|PUT|전체 수정|UPDATE|멱등성 있음|
|PATCH|부분 수정|UPDATE|멱등성 보장 안 될 수도 있음|
|DELETE|삭제|DELETE|멱등성 있음|
|HEAD|헤더만 조회|-|본문 없음|
|OPTIONS|지원 메서드 조회|-|CORS Preflight|
|TRACE|경로 추적|-|보안상 거의 안 씀|

---

✅ **정리**

- HTTP 메서드는 **리소스에 대한 의도(조회, 생성, 수정, 삭제 등)**를 명확히 나타내기 위한 규약입니다.
    
- RESTful API 설계에서는 주로 **GET, POST, PUT, PATCH, DELETE** 5개가 핵심적으로 쓰입니다.
##### HTTP Method의 멱등성에 대해 설명해 주세요.
📌 멱등성(Idempotency) 이란?

- 어떤 연산을 여러 번 반복해도 결과가 동일하게 유지되는 성질을 말합니다.
    
- 즉, 같은 요청을 1번 보내나 100번 보내나 **최종 결과는 동일**해야 합니다.
    

---
📌 HTTP Method와 멱등성
 ✅ 멱등성을 보장하는 메서드

- **GET**:
    
    - 단순 조회 → 몇 번 호출해도 리소스 변화 없음.
        
- **PUT**:
    
    - 전체 리소스를 대체 → 같은 데이터로 여러 번 갱신해도 결과는 동일.
        
    - 예: `PUT /user/1` {name: "Kim"} → 몇 번 호출해도 user 1의 name은 "Kim".
        
- **DELETE**:
    
    - 삭제 요청을 여러 번 보내도 최종 상태는 "삭제됨".
        
- **HEAD**:
    
    - GET과 동일하지만 본문 없이 헤더만 반환 → 조회이므로 멱등성 있음.
        
- **OPTIONS**:
    
    - 단순히 메서드 지원 여부를 반환 → 멱등성 있음.
        

❌ 멱등성을 보장하지 않는 메서드

- **POST**:
    
    - 새로운 리소스 생성 → 같은 요청을 여러 번 보내면 리소스가 계속 늘어남.
        
    - 예: `POST /users` {name: "Kim"} → 호출할 때마다 새로운 유저 생성.
        
- **PATCH**:
    
    - 부분 수정 → 구현 방식에 따라 다름.
        
    - 예: "잔액 +1000" 같은 연산이라면 멱등성이 없음, "잔액을 1000으로 변경"이라면 멱등성이 있음.
        

---
📊 정리 (멱등성 여부)

|Method|멱등성 여부|이유|
|---|---|---|
|GET|✅ 있음|조회만 하므로 상태 변화 없음|
|POST|❌ 없음|호출할 때마다 새로운 리소스 생성 가능|
|PUT|✅ 있음|동일한 리소스로 대체하므로 결과 동일|
|PATCH|⚠️ 경우에 따라 다름|값 덮어쓰기면 있음, 누적 연산이면 없음|
|DELETE|✅ 있음|여러 번 호출해도 최종 상태는 “삭제됨”|
|HEAD|✅ 있음|조회만 하므로 동일|
|OPTIONS|✅ 있음|메서드 정보만 반환|

---
📌 정리

- **멱등성은 "최종 상태"가 동일해야 한다는 개념**입니다.
    
- 멱등성이 있으면 클라이언트나 중간 네트워크 장비(프록시, 로드밸런서 등)가 재시도 로직을 구현할 때 안전합니다.
    
- 따라서 REST API 설계에서는 **POST를 제외한 대부분의 메서드는 멱등성을 지키도록 구현하는 것이 원칙**입니다.

📌 왜 멱등성이 중요한가?

네트워크 환경에서는 요청이 전송 중 끊기거나, 서버가 응답을 주기 전에 클라이언트가 타임아웃을 오해할 수 있습니다.  
이때 클라이언트나 프록시 서버는 **"혹시 실패했나?" 하고 같은 요청을 재전송**할 수 있습니다.

- 만약 그 메서드가 **멱등하다면**, 재시도를 해도 서버의 최종 상태는 동일 → 안전.
    
- 멱등하지 않다면, 같은 요청이 중복 적용되어 원하지 않는 결과가 발생.
    

---
📌 시나리오별 예시

 1. GET (멱등 O)

`GET /users/1`

- 유저 1번 정보 요청.
    
- 1번 보내나 100번 보내나 결과는 동일 → **재시도해도 안전**.
    

---
2. PUT (멱등 O)

`PUT /users/1 { "name": "Kim" }`

- user 1의 name을 "Kim"으로 덮어쓰기.
    
- 네트워크 오류로 요청이 두 번 가도 최종적으로 name은 "Kim" → **안전**.
    

---
3. DELETE (멱등 O)

`DELETE /users/1`

- user 1을 삭제.
    
- 첫 번째 요청에 이미 삭제됨 → 두 번째 요청은 "이미 없음"만 반환.
    
- 최종 상태는 동일 → **안전**.
    

---
4. POST (멱등 ✗)

`POST /orders { "item": "Book" }`

- 주문 생성.
    
- 네트워크 오류로 요청이 두 번 가면 → 같은 주문이 2개 생성됨.
    
- 최종 상태가 달라지므로 멱등하지 않음 → **주의 필요**.
    

---
 5. PATCH (조건부)

`PATCH /users/1 { "point": +1000 }`

- 포인트 1000 증가 요청.
    
- 두 번 가면 최종적으로 +2000 → **멱등하지 않음**.
    

`PATCH /users/1 { "point": 1000 }`

- 포인트를 1000으로 설정.
    
- 몇 번 가도 최종 상태는 동일 → **멱등**.
    

---
 📊 정리

- **멱등성 있는 메서드(GET, PUT, DELETE)** → 네트워크 재시도 상황에서도 안전.
    
- **멱등성 없는 메서드(POST, 일부 PATCH)** → 재시도 시 의도치 않은 중복 결과 가능 → 중복 방지 로직(Idempotency Key 등) 필요.
    

---

✅ 면접 답변용 한 줄 요약:

> "멱등성은 네트워크 장애로 요청이 중복 전송되더라도 최종 상태가 변하지 않는 성질입니다. GET, PUT, DELETE는 안전하지만, POST는 멱등하지 않아 중복 생성 문제가 생길 수 있습니다."

POST는 본질적으로 **“새로운 리소스를 생성”**하는 동작이라 멱등하지 않은데, 실무에서는 **중복 생성 방지**를 위해 여러 방법을 씁니다.

---
📌 1. Idempotency Key (멱등성 키)

- **클라이언트가 요청마다 고유한 키(Idempotency-Key)를 생성해서 함께 전송**
    
- 서버는 이 키를 저장하고, 같은 키가 다시 들어오면 **중복 생성하지 않고 이전 결과를 반환**
    
- 예시 (결제 API에서 자주 사용)
    
    `POST /payments Headers: Idempotency-Key: abc123 Body: { "amount": 10000, "userId": 1 }`
    
    - 첫 요청 → 결제 처리 후 응답 저장
        
    - 두 번째 요청(같은 키) → 새 결제 생성 안 하고, 첫 번째 응답 그대로 반환
        

👉 Stripe, PayPal, Toss 같은 **결제 시스템에서 표준적으로 사용하는 방법**입니다.

---
📌 2. 비즈니스 키 제약 (Unique Constraint)

- 요청에 포함된 비즈니스 로직 상의 고유 값(예: 주문번호, 이메일)을 **DB에서 Unique 제약 조건으로 관리**
    
- 같은 값으로 두 번 `POST`가 들어오면 DB에서 중복 오류 발생 → 서버는 에러 반환
    
- 예시:
    - `POST /users { "email": "test@test.com" }`
    - 같은 이메일로 여러 번 요청 시, 두 번째부터는 `409 Conflict` 반환        
👉 회원가입, 주문번호 같은 “고유성이 보장돼야 하는 리소스”에 적합

---
 📌 3. 서버 단에서 중복 체크 로직

- 서버가 요청 처리 시, **최근 요청 내역을 캐시/DB에 저장**해 두고 같은 요청이 들어오면 무시
    
- Redis 같은 인메모리 DB로 “짧은 시간 동안 동일 요청 차단”을 구현하기도 함
    
- 예:
    
    - 사용자가 버튼을 두 번 연속 클릭했을 때 중복 요청 차단
        

---
 📌 4. 클라이언트 단 방지

- UX 레벨에서 “버튼 1회만 클릭 가능, 이후 비활성화” 같은 방법
    
- 근본적 해결은 아니지만, 불필요한 중복 요청을 줄여줌
    

---
 📊 비교 요약

|방법|특징|사용 사례|
|---|---|---|
|Idempotency Key|클라이언트가 키 발급, 서버에서 응답 재사용|결제 API, 주문 API|
|비즈니스 키 제약|DB Unique 제약으로 중복 방지|회원가입(이메일), 주문번호|
|서버 중복 체크|캐시/DB로 요청 이력 관리|버튼 중복 클릭, 단시간 중복 요청 방지|
|클라이언트 방지|UI 제약으로 중복 클릭 차단|UX 개선 차원|

---

✅ **정리**

- POST는 본질적으로 멱등하지 않지만,
    
- **Idempotency Key**, **비즈니스 키 제약**, **중복 체크 로직** 등을 통해 실무에서는 안전하게 멱등성을 보장합니다.
    
- 특히 **금융·결제 서비스**에서는 Idempotency Key를 거의 필수적으로 사용합니다.
    

---

👉 면접 답변 포인트:  
“**POST는 멱등하지 않지만, 실무에서는 Idempotency Key를 두거나 비즈니스 키 제약을 걸어 멱등성을 보장합니다. 특히 결제 같은 경우는 중복 결제가 치명적이므로 반드시 이런 전략을 사용합니다.**”
##### GET과 POST의 차이는 무엇인가요?
좋은 질문입니다 🙂  
HTTP에서 가장 많이 쓰이는 메서드가 **GET**과 **POST**인데, 둘은 목적과 동작 방식이 확실히 다릅니다.

---
📌 1. 의미적 차이

- **GET**
    
    - 서버의 리소스를 **조회(Read)**하는 요청
        
    - “데이터를 가져온다”
        
- **POST**
    
    - 서버에 데이터를 **전송해서 생성(Create) 또는 처리(Process)**하는 요청
        
    - “데이터를 새로 만든다 / 서버에 뭔가를 맡긴다”
        

---

📌 2. 데이터 전달 방식

- **GET**
    
    - 데이터를 **URL 쿼리 파라미터**에 담아 전달 (`?key=value`)
        
    - 예: `GET /users?id=1`
        
- **POST**
    
    - 데이터를 **HTTP Body**에 담아 전달 (JSON, FormData 등)
        
    - 예: `POST /users` `{ "name": "Kim" }`
        

---
📌 3. 캐싱 가능 여부

- **GET**
    
    - 안전하고 멱등적이므로 캐싱 가능 (브라우저/프록시 캐시 활용)
        
- **POST**
    
    - 멱등하지 않으므로 기본적으로 캐싱하지 않음 (필요 시 별도 설정 필요)
        

---
📌 4. 멱등성 / 안전성

- **GET**
    
    - 안전(Safe) → 서버 상태 변경 없음
        
    - 멱등(Idempotent) → 여러 번 요청해도 같은 결과
        
- **POST**
    
    - 안전하지 않음 → 새로운 리소스 생성 등 서버 상태 변경
        
    - 멱등성 없음 → 같은 요청을 여러 번 보내면 리소스가 중복 생성될 수 있음
        

---
📌 5. 길이 제한

- **GET**
    
    - URL 길이에 제한이 있음 (브라우저/서버에 따라 다르지만 보통 2,048자 내외)
        
- **POST**
    
    - Body에 담으므로 데이터 크기 제한이 훨씬 큼 (실질적으로 서버 설정에 따름)
        

---
📊 요약 비교

|구분|GET|POST|
|---|---|---|
|의미|조회(Read)|생성(Create)/처리|
|데이터 전달|URL 쿼리 파라미터|HTTP Body|
|서버 상태|변경 없음 (Safe)|변경 있음 (Not Safe)|
|멱등성|있음|없음|
|캐싱|가능|불가능(기본)|
|데이터 크기|URL 길이 제한 있음|Body로 대량 전송 가능|
|사용 예시|게시글 목록 조회, 사용자 정보 조회|회원가입, 로그인, 주문 생성|

---

✅ **정리**

- **GET**: 단순 조회, 안전, 캐싱 가능
    
- **POST**: 리소스 생성/변경, 멱등성 없음, 상태 변화 발생
    

---

👉 면접식으로 짧게 말하면:

> “GET은 서버 리소스를 조회할 때 쓰고, POST는 리소스를 생성하거나 처리할 때 씁니다. GET은 멱등적이고 캐싱이 가능하지만, POST는 멱등성이 없고 서버 상태를 바꿉니다.”
##### POST와 PUT, PATCH의 차이는 무엇인가요?
좋은 질문입니다 👍  
POST, PUT, PATCH는 모두 **리소스 생성/수정에 관련된 메서드**인데, 의도가 다릅니다. REST API 설계에서 많이 헷갈리는 부분이라서 확실히 정리해 두시면 좋아요.

---
📌 1. POST

- **의미**: 새로운 리소스 생성(Create), 혹은 서버 측에서 어떤 처리를 위임할 때 사용
    
- **특징**
    
    - 멱등성 ❌ (같은 요청 여러 번 보내면 리소스가 중복 생성될 수 있음)
        
    - 새 리소스를 만들고 보통 `201 Created` 반환
        
- **예시**
    
    `POST /users { "name": "Kim", "email": "kim@test.com" } → 새로운 유저 생성 (id=10)`
    

---
📌 2. PUT

- **의미**: 리소스 전체 교체(Update)
    
- **특징**
    
    - 멱등성 ✅ (같은 요청 여러 번 보내도 최종 결과는 동일)
        
    - 요청에 전달한 JSON 문서가 **리소스 전체를 대체**해야 함
        
    - 없는 리소스에 PUT을 하면 생성하기도 함 (서버 구현 방식에 따라 다름)
        
- **예시**
    
    `PUT /users/10 { "name": "Lee", "email": "lee@test.com" } → user 10의 정보를 통째로 새로운 값으로 교체`
    

---
📌 3. PATCH

- **의미**: 리소스 일부 수정(Partial Update)
    
- **특징**
    
    - 멱등성 ❓ (구현 방식에 따라 다름 → “값을 덮어쓰기”면 멱등, “증가/감소 연산”이면 비멱등)
        
    - 리소스 전체가 아니라 특정 필드만 변경 가능 → 네트워크 비용 절약
        
- **예시**
    
    `PATCH /users/10 { "email": "newmail@test.com" } → user 10의 email만 변경`
    

---
📊 비교 요약

| 구분  | POST              | PUT                     | PATCH                   |
| --- | ----------------- | ----------------------- | ----------------------- |
| 목적  | 새 리소스 생성          | 전체 리소스 교체               | 리소스 일부 수정               |
| 대상  | 컬렉션(/users) 주로 사용 | 단일 리소스(/users/10)       | 단일 리소스(/users/10)       |
| 멱등성 | ❌ 없음              | ✅ 있음                    | ⚠️ 경우에 따라 다름            |
| 응답  | 201 Created       | 200 OK / 204 No Content | 200 OK / 204 No Content |
| 예시  | 회원가입, 주문 생성       | 유저 전체 정보 교체             | 유저 이메일만 수정              |

---
✅ 정리

- **POST**: 새로운 리소스를 “추가”
    
- **PUT**: 리소스를 “통째로 교체”
    
- **PATCH**: 리소스의 “일부만 수정”
    

---

👉 면접식으로 짧게 말하면:

> “POST는 리소스 생성, PUT은 리소스 전체 교체, PATCH는 리소스 일부 수정입니다. POST는 멱등성이 없지만, PUT은 멱등성을 보장합니다. PATCH는 상황에 따라 멱등성을 가질 수도 있고 아닐 수도 있습니다.”
##### HTTP 1.1 이후로, GET에도 Body에 데이터를 실을 수 있게 되었습니다. 그럼에도 불구하고 왜 아직도 이런 방식을 지양하는 것일까요?
말씀하신 것처럼 **HTTP/1.1 명세(RFC 7231)**에서는 GET 요청에도 Body를 담는 것이 **문법적으로 금지된 것은 아닙니다.**  
하지만, 실무에서는 **GET + Body**를 사실상 지양합니다. 이유는 크게 세 가지입니다.

---
📌 1. 명세의 모호성

- RFC 7231에 따르면:
    
    > “A payload within a GET request message has no defined semantics; sending a payload body on a GET request might cause some existing implementations to reject the request.”
    
    - 즉, **GET의 Body는 정의된 의미가 없다.**
        
    - 서버/클라이언트 구현에 따라 다르게 해석될 수 있다는 뜻입니다.
        

---
 📌 2. 실무 호환성 문제

- **많은 클라이언트/프록시/캐시 서버**가 GET 요청은 Body가 없다고 가정하고 구현되어 있습니다.
    
- 따라서 GET Body는 **무시되거나, 아예 오류 처리**될 수 있습니다.
    
- 예: 일부 프록시/로드밸런서는 GET 요청에서 Body를 strip(삭제)해버립니다.
    
---
📌 3. 캐싱 / REST 의미적 혼란

- GET은 본질적으로 **안전(Safe)** 하고 **멱등(Idempotent)** 하며, **캐시 가능**한 메서드입니다.
    
- Body에 의미를 부여하기 시작하면,
    
    - 캐시 키(Cache Key)를 URI가 아닌 Body까지 포함해야 함 → 캐싱 시스템 혼란
        
    - RESTful 설계 원칙에서 “GET = 조회”라는 명확한 의미가 흐려짐
        
- 따라서 대부분의 API 설계 가이드라인(REST Best Practice)에서는 GET에 Body 사용을 금지합니다.
    

---
📌 결론

- HTTP/1.1부터 **GET + Body는 문법적으로 가능하지만, 의미가 표준화되어 있지 않고 호환성 문제가 많기 때문에 지양**합니다.
    
- 따라서 **데이터를 반드시 Body에 담아야 한다면 POST/PUT/PATCH** 같은 메서드를 사용합니다.
    
- GET은 “리소스 식별자(URI + Query String)”로만 요청해야 하는 것이 사실상 업계 표준입니다.
    

---

👉 면접 답변 예시:

> “HTTP/1.1부터 GET에도 Body를 담을 수는 있지만, 명세에서 의미가 정의되지 않았고, 캐시/프록시/클라이언트 구현 호환성이 보장되지 않습니다. 그래서 실무에서는 GET 요청에는 Body를 쓰지 않고, 데이터를 전달해야 한다면 Query String을 쓰거나 POST 등 다른 메서드를 활용하는 것이 일반적입니다.”

###### **GET 요청에 Body를 넣었을 때 실제로 발생할 수 있는 문제 시나리오**
> 그럼 **GET 요청에 Body를 넣었을 때 실제로 발생할 수 있는 문제 시나리오**를 정리해 보겠습니다.

---
📌 1. 캐싱 시스템과의 충돌

- **문제 상황**:
    
    - HTTP 캐시는 보통 **URI + Query Parameter**를 캐시 키(Cache Key)로 사용합니다.
        
    - 그런데 GET Body는 캐시 키에 포함되지 않습니다.
        
- **결과**:
    
    - Body 내용이 달라도 URI가 같으면, 캐시는 같은 요청으로 인식 → **잘못된 데이터 반환** 가능.
        
- **예시**:
    
    `GET /products   Body: { "category": "book" } GET /products   Body: { "category": "electronics" }`
    
    → 캐시 서버는 둘 다 같은 `/products` 요청으로 처리 → book 목록을 요청했는데 electronics 목록이 돌아올 수 있음.
    

---
📌 2. 프록시 / 로드밸런서에서 Body 무시

- **문제 상황**:
    
    - 많은 프록시(nginx, Squid, HAProxy)나 로드밸런서는 **GET에는 Body가 없다고 가정**합니다.
        
    - 따라서 GET Body를 **삭제하거나 무시**해 버립니다.
        
- **결과**:
    
    - 서버는 Body를 못 받고, 클라이언트는 의도한 요청을 전달하지 못함.
        
- **실제 사례**:
    
    - 일부 AWS API Gateway나 Cloudflare 같은 서비스는 GET Body를 자동으로 제거 → “Body 왜 안 와요?” 현상 발생.
        

---
📌 3. 클라이언트 라이브러리 호환성

- **문제 상황**:
    
    - `fetch`, `axios`, `OkHttp`, `Java HttpClient` 같은 라이브러리 중 일부는 **GET Body를 아예 지원하지 않거나 경고 발생**.
        
- **결과**:
    
    - 클라이언트 개발자가 `body` 넣었는데 서버로 전달되지 않음.
        
- **예시**:
    
    `fetch("/api/data", { method: "GET", body: JSON.stringify({ id: 1 }) }) // 일부 브라우저에서는 body가 무시됨`
    

---
 📌 4. RESTful 의미적 혼란

- **문제 상황**:
    
    - REST 설계 원칙에서 GET은 **안전(Safe), 멱등(Idempotent), 캐싱 가능**해야 합니다.
        
    - Body를 통해 조건을 달기 시작하면 사실상 POST처럼 동작.
        
- **결과**:
    
    - API 문서화 / 협업에서 혼란 → “이거 조회용인데 POST로 바꿔야 하는 거 아닌가요?”
        
    - 팀 간 합의가 안 되면 유지보수 악몽 시작 😅
        

---
📊 정리

- GET + Body는 RFC상 허용되지만,
    
    1. **캐시 시스템 무시** (Body 반영 안 됨 → 잘못된 캐시 응답)
        
    2. **프록시/로드밸런서에서 Body 삭제**
        
    3. **클라이언트 라이브러리 미지원**
        
    4. **RESTful 의미적 혼란**
        

→ **표준적 의미가 없고, 생태계 지원도 불안정**하기 때문에 지양합니다.

---

👉 면접용으로 짧게 답하면:

> “GET Body는 RFC상 허용되지만 캐싱 시스템에서 무시되고, 프록시/로드밸런서가 Body를 날려버릴 수 있습니다. 또 라이브러리 호환성 문제도 있어 실무에서는 절대 권장되지 않습니다. 대신 Query String이나 POST를 씁니다.”

### 4. HTTP에 대해 설명해 주세요.
##### 설명
좋습니다 🙂  
**HTTP(HyperText Transfer Protocol)**는 웹에서 가장 기본이 되는 통신 규약(Protocol)입니다. 브라우저와 서버가 **문서, 이미지, 동영상, JSON 데이터** 같은 리소스를 주고받을 때 사용하는 표준 방식이죠.

---
📌 1. HTTP의 정의

- **HyperText Transfer Protocol** → "하이퍼텍스트 전송 규약"
    
- **클라이언트–서버 모델** 기반: 클라이언트(브라우저, 앱)가 요청(Request)을 보내면 서버가 응답(Response)을 반환.
    
- 애플리케이션 계층(Application Layer) 프로토콜 (OSI 7계층 중 7계층).
    

---
📌 2. HTTP의 특징

1. **Stateless (무상태성)**
    
    - 각 요청은 독립적 → 서버는 이전 요청 상태를 기억하지 않음.
        
    - 로그인 유지 등 상태가 필요하면 쿠키/세션/JWT 같은 기술을 추가로 사용.
        
2. **Connectionless (비연결성)**
    
    - 요청-응답 후 연결을 바로 끊음.
        
    - HTTP/1.1에서는 Keep-Alive로 연결 유지 가능, HTTP/2/3는 다중화 지원.
        
3. **Request-Response 구조**
    
    - 클라이언트가 반드시 먼저 요청을 보내고, 서버가 응답.
        
    - 요청과 응답은 **헤더(Header) + 바디(Body)**로 구성.
        

---

## 📌 3. HTTP 메시지 구조

### 요청(Request)

`GET /users/1 HTTP/1.1 Host: example.com User-Agent: Chrome/120 Accept: application/json`

- **메서드(Method)**: GET, POST, PUT, PATCH, DELETE …
    
- **URI**: `/users/1`
    
- **헤더(Header)**: 클라이언트 정보, 인증 정보 등
    
- **바디(Body)**: 주로 POST/PUT/PATCH에서 데이터 포함
    

### 응답(Response)

`HTTP/1.1 200 OK Content-Type: application/json Content-Length: 34  {   "id": 1,   "name": "Kim" }`

- **상태 코드(Status Code)**: 200 OK, 404 Not Found, 500 Internal Server Error …
    
- **헤더(Header)**: 응답 타입, 캐시 정책 등
    
- **바디(Body)**: 실제 데이터(JSON, HTML 등)
    

---

## 📌 4. HTTP 버전별 특징

- **HTTP/1.0 (1996)**
    
    - 요청-응답마다 TCP 연결 새로 맺음 → 비효율적
        
- **HTTP/1.1 (1997)**
    
    - Keep-Alive 도입 → 연결 재사용 가능
        
    - Host 헤더 도입 (가상호스팅 가능)
        
- **HTTP/2 (2015)**
    
    - 바이너리 프로토콜, 요청 다중화(Multiplexing), 헤더 압축
        
    - 성능 대폭 향상
        
- **HTTP/3 (2022, 최신)**
    
    - TCP 대신 **QUIC(UDP 기반)** 사용 → 더 빠른 연결, 지연 줄임
        

---

## 📌 5. HTTP의 주요 활용

- 웹 브라우저 ↔ 서버 간 문서/이미지/동영상 전송
    
- REST API, GraphQL, gRPC (HTTP/2 기반)
    
- 모바일 앱 ↔ 백엔드 서버 데이터 통신
    

---

✅ **정리**

- HTTP는 **웹에서 클라이언트와 서버가 데이터를 주고받는 규약**
    
- 특징: **무상태성, 요청-응답 구조, 버전에 따라 성능 발전**
    
- 상태 유지 필요 시 → **쿠키/세션/JWT** 같은 별도 기술 필요
    
- 최신 서비스들은 **HTTP/2, HTTP/3**를 활용해 성능 최적화
    

---

👉 면접에서 짧게 말하면:

> “HTTP는 클라이언트와 서버가 데이터를 주고받는 애플리케이션 계층 프로토콜입니다. Stateless 특성을 가지며, 요청-응답 구조로 동작합니다. 현재는 HTTP/2, HTTP/3까지 발전해 성능과 안정성이 강화되었습니다.”

##### 공개키와 대칭키에 대해 설명해 주세요.
##### 왜 HTTPS Handshake 과정에서는 인증서를 사용하는 것 일까요?
##### SSL과 TLS의 차이는 무엇인가요?

### 5. 웹소켓과 소켓 통신의 차이에 대해 설명해 주세요.
##### 소켓과 포트의 차이가 무엇인가요?
##### 여러 소켓이 있다고 할 때, 그 소켓의 포트 번호는 모두 다른가요?
##### 사용자의 요청이 무수히 많아지면, 소켓도 무수히 생성되나요?

### 6. HTTP/1.1과 HTTP/2의 차이점은 무엇인가요?
##### HOL Blocking 에 대해 설명해 주세요.
##### HTTP/3.0의 주요 특징에 대해 설명해 주세요.

### 7. TCP와 UDP의 차이에 대해 설명해 주세요.
##### Checksum이 무엇인가요?
##### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
##### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
##### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
##### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
##### 왜 HTTP는 TCP를 사용하나요?
##### 그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
##### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
##### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?

### 8. DHCP가 무엇인지 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#8-dhcp%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EC%A7%80-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 9. IP 주소는 무엇이며, 어떤 기능을 하고 있나요?

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#9-ip-%EC%A3%BC%EC%86%8C%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B4%EB%A9%B0-%EC%96%B4%EB%96%A4-%EA%B8%B0%EB%8A%A5%EC%9D%84-%ED%95%98%EA%B3%A0-%EC%9E%88%EB%82%98%EC%9A%94)

### 10. OSI 7계층에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#10-osi-7%EA%B3%84%EC%B8%B5%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 11. 3-Way Handshake에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#11-3-way-handshake%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 12. 4-Way Handshake에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#12-4-way-handshake%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 13. [www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#13-wwwgithubcom%EC%9D%84-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%97%90-%EC%9E%85%EB%A0%A5%ED%95%98%EA%B3%A0-%EC%97%94%ED%84%B0%EB%A5%BC-%EC%B3%A4%EC%9D%84-%EB%95%8C-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC-%EC%83%81-%EC%96%B4%EB%96%A4-%EC%9D%BC%EC%9D%B4-%EC%9D%BC%EC%96%B4%EB%82%98%EB%8A%94%EC%A7%80-%EC%B5%9C%EB%8C%80%ED%95%9C-%EC%9E%90%EC%84%B8%ED%95%98%EA%B2%8C-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 14. DNS에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#14-dns%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 15. SOP 정책에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#15-sop-%EC%A0%95%EC%B1%85%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 16. Stateless와 Connectionless에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#16-stateless%EC%99%80-connectionless%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#17-%EB%9D%BC%EC%9A%B0%ED%84%B0-%EB%82%B4%EC%9D%98-%ED%8F%AC%EC%9B%8C%EB%94%A9-%EA%B3%BC%EC%A0%95%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 18. 로드밸런서가 무엇인가요?

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#18-%EB%A1%9C%EB%93%9C%EB%B0%B8%EB%9F%B0%EC%84%9C%EA%B0%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94)

### 19. 서브넷 마스크와, 게이트웨이에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#19-%EC%84%9C%EB%B8%8C%EB%84%B7-%EB%A7%88%EC%8A%A4%ED%81%AC%EC%99%80-%EA%B2%8C%EC%9D%B4%ED%8A%B8%EC%9B%A8%EC%9D%B4%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#20-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EA%B3%BC-%EB%94%94%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%89%EC%8B%B1%EC%97%90-%EB%8C%80%ED%95%B4-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

### 21. XSS에 대해서 설명해 주세요.

[](https://github.com/VSFe/Tech-Interview/blob/main/03-NETWORK.md#21-xss%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%84%A4%EB%AA%85%ED%95%B4-%EC%A3%BC%EC%84%B8%EC%9A%94)

