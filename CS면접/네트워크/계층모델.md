#### 7. TCP와 UDP의 차이에 대해 설명해 주세요.
###### 차이
TCP(연결형 서비스로 신뢰성을 보장)
- 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다.
- 연결 지향 방식으로 패킷 교환 방식을 사용한다(가상 회선 방식이 아님).
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어.
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식.
- TCP는 연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜로 예를 들면 파일 전송과 같은 경우에 사용
- Q) TCP는 패킷을 어떻게 추적 및 관리하나요?
	위에서 데이터는 패킷단위로 나누어 같은 목적지(IP계층)으로 전송된다고 설명하였습니다. 예를 들어 한줄로 서야하는 A,B,C라는 사람(패킷)들이 서울(발신지)에서 출발하여 부산(수신지)으로 간다고 합시다. 그런데 A,B,C가 순차적으로 가는 상황에서 B가 길을 잘못 들어서 분실되었다고 합시다. 하지만 목적지에서는 A,B,C가 모두 필요한지 모르고 A,C만 보고 다 왔다고 착각할 수 있습니다. 그렇기 때문에 A,,B,C라는 패킷에 1,2,3이라는 번호를 부여하여 패킷의 분실 확인과 같은 처리를 하여 목적지에서 재조립을 합니다. 이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 받고 조립을 할 수 있습니다.

UDP(데이터를 데이터그램 단위로 처리하는 프로토콜)
- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다
- 신뢰성보다는 연속성이 중요한 서비스 예를 들면 실시간 서비스(streaming)에 자주 사용
-데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형) 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다. 데이터 그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다.
	![[Pasted image 20250403204438.png]]
###### Checksum이 무엇인가요?
- 체크섬
	체크섬(checksum)은 데이터 전송 중에 오류를 감지하기 위해 사용되는 기술이다.
	데이터의 일부를 가지고 계산된 값으로,  데이터가 손상되었는지 여부를 확인하는 데 사용된다.
- 단순 합계 체크섬 (Simple Sum Checksum):  
	    가장 간단한 형태의 체크섬으로, 데이터의 모든 바이트를 더한 후 그 결과를 사용  
	    단순하고 빠르지만, 간단한 오류만 검출

- 오버플로우 회피 (Overflow Avoidance):  
    단순 합계 체크섬에서 발생할 수 있는 오버플로우를 회피하기 위해 추가적인 조치를 취한 것
		
##### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
 - 둘다 사용하는데 검출할 수 있는 오류가 다릅니다. 
 - Go Bank N 기법 : 어느 데이터로부터 오류가 발생했는지 파악하여, 그 부분만 다시 순서대로 보내 제어한다.
-  Selective Repeat 기법 : 에러난 데이터만 재전송하고 그전에 받았던 순서가 잘못된 데이터 버퍼를 재정렬하여 제어한다.
- TCP는 오류 발생 시 재전송을 수행하는 반면, UDP는 그렇지 않습니다.


출처: [https://inpa.tistory.com/entry/NW-🌐-아직도-모호한-TCP-UDP-개념-❓-쉽게-이해하자](https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90) [Inpa Dev 👨‍💻:티스토리]
##### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
- **1. Checksum (체크섬)**
- **오류 탐지용**으로 사용되며, 데이터가 손상되었는지를 확인하는 역할만 합니다.
- 만약 오류가 감지되면 **TCP 같은 프로토콜은 재전송을 요청**하여 손상된 데이터를 다시 받습니다.
- UDP처럼 신뢰성이 없는 프로토콜에서는 오류가 발생하면 데이터를 폐기할 뿐 복구는 하지 않습니다.
- TCP, UDP, IP, ICMP 등 다양한 네트워크 프로토콜에서 사용됩니다.
2. FEC (Forward Error Correction, 전방 오류 정정)**
- 오류를 단순히 탐지하는 것이 아니라, **정정할 수도 있는기법**입니다.
- 데이터를 전송할 때 **오류 정정을 위한 추가적인 정보(패리티, 중복 데이터 등)를 포함**하여 보냅니다.
- 수신 측에서 이 추가 정보를 활용하여 **손상된 데이터를 복구**할 수 있습니다.

##### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
- **연결 지향 방식 (3-Way Handshake)**
- **데이터 무결성 검사 (Checksum)**
- **신뢰성 있는 데이터 전송 (ACK & 재전송)**
- **흐름 제어 (Flow Control)**
- **혼잡 제어 (Congestion Control)**
- **순서 보장 (Sequence Number & Reordering)**

##### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
네트워크에 과부하가 걸리는 것을 방지하기 위해 **TCP는 송신 속도를 조절**합니다.  
이를 위해 **Congestion Window (cwnd)** 를 사용하며, 대표적인 혼잡 제어 알고리즘은 다음과 같습니다.
**TCP 혼잡 제어 과정**

1. **Slow Start**: 초기에는 작은 크기의 패킷을 보내고, ACK를 받으면 송신량을 점진적으로 증가시킴.
    
2. **Congestion Avoidance**: 임계값을 넘어서면 송신 속도를 천천히 증가시켜 네트워크 과부하를 방지.
    
3. **Fast Retransmit**: 패킷이 손실되면 중복된 ACK를 감지하여 빠르게 재전송.
    
4. **Fast Recovery**: 패킷 손실이 발생한 경우, 송신 속도를 급격히 줄이지 않고 적절히 조정하여 회복.

#####  왜 HTTP는 TCP를 사용하나요?
**HTTP는 신뢰성 있는 데이터 전송이 중요하기 때문에 TCP를 사용합니다.**
웹 브라우저가 HTTP 요청을 보내서 HTML 페이지를 받는다고 가정했을 때,  
만약 데이터 일부가 손실된다면 **브라우저가 페이지를 제대로 렌더링하지 못할 수도 있습니다.**  
TCP는 패킷이 손실되면 자동으로 **재전송**하여 데이터가 완전하게 전달되도록 합니다.
웹 페이지를 로드할 때 HTML, CSS, JS 파일이 순서대로 로딩되지 않는다면 페이지가 정상적으로 보이지 않을 것입니다.  
TCP는 이러한 문제를 방지합니다.
사용자가 모바일 네트워크에서 웹사이트를 로드하는 경우, **네트워크 속도가 느려도 TCP가 전송 속도를 조절하여 끊김 없이 데이터를 받을 수 있도록 합니다.**

#####  그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
기존의 HTTP/2(TCP 기반)는 **지연(latency) 문제와 연결 관리의 비효율성**이 있었습니다.  
이를 해결하기 위해 **Google이 개발한 QUIC 프로토콜을 기반으로 HTTP/3가 설계**되었습니다.
UDP는 원래 **비연결형 프로토콜**로 신뢰성이 없지만, QUIC은 **UDP 위에서 TCP의 신뢰성을 직접 구현**하여 문제를 해결했습니다.  
즉, **UDP의 속도 + TCP의 신뢰성**을 결합한 것입니다.
UDP는 원래 패킷 순서를 보장하지 않지만, **QUIC은 자체적으로 시퀀스 번호를 관리하여 순서를 보장**합니다.

- TCP는 패킷이 손실되면 **모든 데이터를 기다려야 하지만**,  
    QUIC은 **독립적인 스트림(Stream) 단위로 데이터 전송**하여 **한 개의 패킷 손실이 전체 요청을 지연시키지 않음**
    
- 이를 통해 **Head-of-Line Blocking 문제를 해결**하고, 패킷 손실이 있어도 나머지 데이터는 정상적으로 수신할 수 있음
-UDP 자체에는 **패킷 손실 시 재전송 기능이 없지만**,  
QUIC은 **자체적으로 패킷을 추적하고 손실된 패킷만 재전송**하는 기능을 구현하였습니다.

- QUIC은 **ACK 확인 메커니즘**을 사용하여, 받은 패킷과 손실된 패킷을 추적
    
- TCP처럼 **모든 패킷이 올 때까지 기다리는 것이 아니라**, **손실된 패킷만 선택적으로 재전송**
    
- 이를 통해 **성능을 유지하면서도 신뢰성 있는 데이터 전송 가능**
##### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
**처음 방문할 때:**

1. 브라우저가 TCP 기반으로 서버에 HTTP 요청을 보냄
    
2. 서버가 응답하면서 **Alt-Svc 헤더를 통해 HTTP/3(UDP) 지원을 알림**
    
3. 브라우저는 **다음 요청부터 UDP(QUIC) 기반으로 HTTP/3 연결을 시도**
    

📌 **두 번째 방문할 때:**

1. 브라우저는 **이전 Alt-Svc 정보를 기억하고 곧바로 UDP 기반 HTTP/3 연결 시도**
    
2. 연결이 실패하면 다시 TCP 기반 HTTP/2로 연결
    

💡 **즉, 브라우저는 먼저 TCP를 사용하고, 서버가 HTTP/3를 지원한다는 정보를 받은 후 UDP(QUIC)로 전환합니다.**
##### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
- UDP를 사용하겠습니다. 기존에 TCP와 UDP는 간단하게 느리지만 신뢰성이 높은 프로토콜과 빠르지만 신뢰성이 낮은 프로토콜로 여겨져왔습니다. 하지만 UDP는 흔히 말하든 흰 도화지같은 프로토콜이기 때문에 개발자의 커스터마이징에 따라 TCP와 비슷한 성능을 낼 수도 있습니다. 개발을 진행할 때, 좋은 기능이 모두 들어간 무거운 라이브러리보다는 필요한 기능만 가지고 있는 가벼운 라이브러리를 선호하는 것과 같이 저 또한 UDP를 선택할 것 같습니다.

#### **10. OSI 7계층에 대해 설명해 주세요.**
##### 설명
1️⃣ **물리 계층 (Physical)** → 하드웨어 장비, 전기 신호  
2️⃣ **데이터 링크 계층 (Data Link)** → MAC 주소 기반 통신 (Ethernet, Wi-Fi)  
3️⃣ **네트워크 계층 (Network)** → IP 주소 기반 통신 (라우팅, 최적 경로)  
4️⃣ **전송 계층 (Transport)** → 신뢰성 있는 TCP vs 빠른 UDP  
5️⃣ **세션 계층 (Session)** → 세션 유지 (로그인, SSH)  
6️⃣ **표현 계층 (Presentation)** → 데이터 암호화/복호화, 압축 (SSL/TLS)  
7️⃣ **응용 계층 (Application)** → HTTP, FTP, DNS 등 사용자 서비스 제공

##### transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
1️⃣ **전송 계층(Transport Layer)** → **프로세스 간 데이터 전송을 담당**
**주요 역할**

- **애플리케이션(프로세스) 간의 데이터 전송을 담당**
    
- 데이터 전송의 **신뢰성을 보장(TCP)하거나 빠른 전송(UDP)** 제공
    
- 송신 측에서는 데이터를 **세그먼트(Segment)** 또는 **데이터그램(Datagram)** 형태로 나누고, 수신 측에서는 이를 다시 조립
    

 **사용하는 주소: 포트 번호 (Port Number)**

- 같은 장치 내에서도 여러 프로그램이 네트워크를 사용할 수 있으므로 **포트 번호를 사용하여 프로세스를 구분**
    
- 예: 웹서버(80번 포트), SSH(22번 포트)
- TCP, UDP를 통해 **신뢰성 있는 전송(TCP) 또는 빠른 전송(UDP) 제공**
- **포트 번호**를 사용하여 프로세스를 구분
    
2️⃣ **네트워크 계층(Network Layer)** → **호스트(장치) 간 패킷을 전달하는 역할
주요 역할**
- **장치(호스트) 간 패킷 전송 및 최적의 경로 설정 (라우팅)**
- 송신 측에서 데이터를 **패킷(Packet)** 단위로 변환하여 전달
- 수신 측에서는 패킷을 받아 상위 계층(전송 계층)으로 전달
    

**사용하는 주소: IP 주소 (IP Address)**
- **장치를 구별하기 위해 IP 주소 사용** (예: 192.168.0.1)
- 목적지 주소를 보고 라우터가 **최적의 경로를 결정**하여 데이터 전달
- IP 주소를 기반으로 **라우팅(경로 설정)** 수행
- **패킷 단위 전송, 신뢰성 보장 없음**
    
💡 **쉽게 말하면, 전송 계층은 "프로그램 간 통신", 네트워크 계층은 "장치 간 통신"을 담당하는 것입니다.** 🚀
- L3 Switch와 Router의 차이에 대해 설명해 주세요.
- 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
- 각각의 Header의 Packing Order에 대해 설명해 주세요.
- ARP에 대해 설명해 주세요.
#### 11. 3-Way Handshake에 대해 설명해 주세요.
##### 설명
1단계 (SYN - Synchronize)**
- 클라이언트가 서버에게 **연결 요청을 보냄**
- 이때, `SYN`(Synchronize) 플래그가 설정된 패킷을 전송
- 패킷에는 **초기 순서 번호(Sequence Number, SEQ=x)** 포함
- → **"연결할 준비가 되었나요?"**
2단계 (SYN + ACK - Acknowledge)
- 서버가 클라이언트의 요청을 수락하고 응답
- `SYN` 플래그와 `ACK`(Acknowledge) 플래그가 설정된 패킷을 전송
- 서버는 자신의 초기 순서 번호(SEQ=y)를 생성
- 클라이언트의 `SEQ=x` 값을 확인한 후 `ACK=x+1`을 설정하여 응답
- → **"연결 요청을 확인했어요. 나도 연결할 준비가 되었어요!"**
**3단계 (ACK - Acknowledge)**
- 클라이언트가 서버의 응답을 확인하고 마지막 응답을 보냄
- `ACK` 플래그가 설정된 패킷을 전송 (`ACK=y+1`)
- → **"연결이 성공적으로 설정되었습니다!"**
- 이후, 클라이언트와 서버 간 데이터 통신이 시작됨
    
3-Way Handshake 요약**
1️⃣ **클라이언트** → 서버: `SYN (SEQ=x)` (연결 요청)  
2️⃣ **서버** → 클라이언트: `SYN (SEQ=y), ACK (ACK=x+1)` (연결 요청 수락)  
3️⃣ **클라이언트** → 서버: `ACK (ACK=y+1)` (연결 확정)  
🔹 **TCP 연결이 성공적으로 수립됨!**

##### ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
TCP에서 `ACK`, `SYN` 같은 정보는 **TCP 헤더의 "플래그(Flags) 필드"**를 사용하여 전달됩니다.  
즉, **TCP 패킷(세그먼트)**의 특정 비트 값을 설정하여 상대방에게 신호를 보내는 방식입니다.
- 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
- 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
- SYN Flooding 에 대해 설명해 주세요.
- 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?

#### 12. 4-Way Handshake에 대해 설명해 주세요.

#### 13. [www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.

#### 14. DNS에 대해 설명해 주세요.

#### 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.