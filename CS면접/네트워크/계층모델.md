#### 7. TCP와 UDP의 차이에 대해 설명해 주세요.
###### 차이
TCP(연결형 서비스로 신뢰성을 보장)
- 발신지와 수신지를 연결하여 패킷을 전송하기 위한 논리적 경로를 배정한다.
- 연결 지향 방식으로 패킷 교환 방식을 사용한다(가상 회선 방식).
- 3-way handshaking과정을 통해 연결을 설정하고 4-way handshaking을 통해 해제한다.
- 흐름 제어 및 혼잡 제어.
- 높은 신뢰성을 보장한다.
- UDP보다 속도가 느리다.
- 전이중(Full-Duplex), 점대점(Point to Point) 방식.
- TCP는 연속성보다 신뢰성있는 전송이 중요할 때에 사용하는 프로토콜로 예를 들면 파일 전송과 같은 경우에 사용
- Q) TCP는 패킷을 어떻게 추적 및 관리하나요?
	위에서 데이터는 패킷단위로 나누어 같은 목적지(IP계층)으로 전송된다고 설명하였습니다. 예를 들어 한줄로 서야하는 A,B,C라는 사람(패킷)들이 서울(발신지)에서 출발하여 부산(수신지)으로 간다고 합시다. 그런데 A,B,C가 순차적으로 가는 상황에서 B가 길을 잘못 들어서 분실되었다고 합시다. 하지만 목적지에서는 A,B,C가 모두 필요한지 모르고 A,C만 보고 다 왔다고 착각할 수 있습니다. 그렇기 때문에 A,,B,C라는 패킷에 1,2,3이라는 번호를 부여하여 패킷의 분실 확인과 같은 처리를 하여 목적지에서 재조립을 합니다. 이런 방식으로 TCP는 패킷을 추적하며, 나누어 보내진 데이터를 받고 조립을 할 수 있습니다.

UDP(데이터를 데이터그램 단위로 처리하는 프로토콜)
- 비연결형 서비스로 데이터그램 방식을 제공한다
- 정보를 주고 받을 때 정보를 보내거나 받는다는 신호절차를 거치지 않는다.
- UDP헤더의 CheckSum 필드를 통해 최소한의 오류만 검출한다.
- 신뢰성이 낮다
- TCP보다 속도가 빠르다
- 신뢰성보다는 연속성이 중요한 서비스 예를 들면 실시간 서비스(streaming)에 자주 사용
-데이터를 전송하기 전에 논리적 연결이 설정되는데, 이를 가상회선이라고 한다.(연결 지향형) 각 패킷에는 가상회선 식별 번호(VCI)가 포함되고, 모든 패킷을 전송하면 가상회선이 해제되고 패킷들은 전송된 순서대로 도착한다. 데이터 그램은 패킷마다 라우터가 경로를 선택하지만, 가상회선 방식은 경로를 설정할 때 한 번만 수행한다.
	![[Pasted image 20250403204438.png]]
###### Checksum이 무엇인가요?
- 체크섬
	체크섬(checksum)은 데이터 전송 중에 오류를 감지하기 위해 사용되는 기술이다.
	데이터의 일부를 가지고 계산된 값으로,  데이터가 손상되었는지 여부를 확인하는 데 사용된다.
- 단순 합계 체크섬 (Simple Sum Checksum):  
	    가장 간단한 형태의 체크섬으로, 데이터의 모든 바이트를 더한 후 그 결과를 사용  
	    단순하고 빠르지만, 간단한 오류만 검출

- 오버플로우 회피 (Overflow Avoidance):  
    단순 합계 체크섬에서 발생할 수 있는 오버플로우를 회피하기 위해 추가적인 조치를 취한 것
		
##### TCP와 UDP 중 어느 프로토콜이 Checksum을 수행할까요?
 - 둘다 사용하는데 검출할 수 있는 오류가 다릅니다. 
 - Go Bank N 기법 : 어느 데이터로부터 오류가 발생했는지 파악하여, 그 부분만 다시 순서대로 보내 제어한다.
-  Selective Repeat 기법 : 에러난 데이터만 재전송하고 그전에 받았던 순서가 잘못된 데이터 버퍼를 재정렬하여 제어한다.
- TCP는 오류 발생 시 재전송을 수행하는 반면, UDP는 그렇지 않습니다.


출처: [https://inpa.tistory.com/entry/NW-🌐-아직도-모호한-TCP-UDP-개념-❓-쉽게-이해하자](https://inpa.tistory.com/entry/NW-%F0%9F%8C%90-%EC%95%84%EC%A7%81%EB%8F%84-%EB%AA%A8%ED%98%B8%ED%95%9C-TCP-UDP-%EA%B0%9C%EB%85%90-%E2%9D%93-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90) [Inpa Dev 👨‍💻:티스토리]
##### 그렇다면, Checksum을 통해 오류를 정정할 수 있나요?
- **1. Checksum (체크섬)**
- **오류 탐지용**으로 사용되며, 데이터가 손상되었는지를 확인하는 역할만 합니다.
- 만약 오류가 감지되면 **TCP 같은 프로토콜은 재전송을 요청**하여 손상된 데이터를 다시 받습니다.
- UDP처럼 신뢰성이 없는 프로토콜에서는 오류가 발생하면 데이터를 폐기할 뿐 복구는 하지 않습니다.
- TCP, UDP, IP, ICMP 등 다양한 네트워크 프로토콜에서 사용됩니다.
2. FEC (Forward Error Correction, 전방 오류 정정)**
- 오류를 단순히 탐지하는 것이 아니라, **정정할 수도 있는기법**입니다.
- 데이터를 전송할 때 **오류 정정을 위한 추가적인 정보(패리티, 중복 데이터 등)를 포함**하여 보냅니다.
- 수신 측에서 이 추가 정보를 활용하여 **손상된 데이터를 복구**할 수 있습니다.
-에러 정정 코드(ECC, Error-Correcting Code)

##### TCP가 신뢰성을 보장하는 방법에 대해 설명해 주세요.
- **연결 지향 방식 (3-Way Handshake)**
- **데이터 무결성 검사 (Checksum)**
- **신뢰성 있는 데이터 전송 (ACK & 재전송)**
- **흐름 제어 (Flow Control)**
- **혼잡 제어 (Congestion Control)**
- **순서 보장 (Sequence Number & Reordering)**
![[Pasted image 20250404225854.png]]
##### TCP의 혼잡 제어 처리 방법에 대해 설명해 주세요.
네트워크에 과부하가 걸리는 것을 방지하기 위해 **TCP는 송신 속도를 조절**합니다.  
이를 위해 **Congestion Window (cwnd)** 를 사용하며, 대표적인 혼잡 제어 알고리즘은 다음과 같습니다.
**TCP 혼잡 제어 과정**
1. **Slow Start**: 초기에는 작은 크기의 패킷을 보내고, ACK를 받으면 송신량을 점진적으로 증가시킴.
2. **Congestion Avoidance**: 임계값을 넘어서면 송신 속도를 천천히 증가시켜 네트워크 과부하를 방지.
3. **Fast Retransmit**: 패킷이 손실되면 중복된 ACK를 감지하여 빠르게 재전송.
4. **Fast Recovery**: 패킷 손실이 발생한 경우, 송신 속도를 급격히 줄이지 않고 적절히 조정하여 회복.
(Receive Window,Congestion Window)
수신자(처리데이터)       네트워크 상태(큐)

#####  왜 HTTP는 TCP를 사용하나요?
**HTTP는 신뢰성 있는 데이터 전송이 중요하기 때문에 TCP를 사용합니다.**
웹 브라우저가 HTTP 요청을 보내서 HTML 페이지를 받는다고 가정했을 때,  
만약 데이터 일부가 손실된다면 **브라우저가 페이지를 제대로 렌더링하지 못할 수도 있습니다.**  
TCP는 패킷이 손실되면 자동으로 **재전송**하여 데이터가 완전하게 전달되도록 합니다.
웹 페이지를 로드할 때 HTML, CSS, JS 파일이 순서대로 로딩되지 않는다면 페이지가 정상적으로 보이지 않을 것입니다.  
TCP는 이러한 문제를 방지합니다.
사용자가 모바일 네트워크에서 웹사이트를 로드하는 경우, **네트워크 속도가 느려도 TCP가 전송 속도를 조절하여 끊김 없이 데이터를 받을 수 있도록 합니다.**

#####  그렇다면, 왜 HTTP/3 에서는 UDP를 사용하나요? 위에서 언급한 UDP의 문제가 해결되었나요?
기존의 HTTP/2(TCP 기반)는 **지연(latency) 문제와 연결 관리의 비효율성**이 있었습니다.  
이를 해결하기 위해 **Google이 개발한 QUIC 프로토콜을 기반으로 HTTP/3가 설계**되었습니다.
UDP는 원래 **비연결형 프로토콜**로 신뢰성이 없지만, QUIC은 **UDP 위에서 TCP의 신뢰성을 직접 구현**하여 문제를 해결했습니다.  
즉, **UDP의 속도 + TCP의 신뢰성**을 결합한 것입니다.
UDP는 원래 패킷 순서를 보장하지 않지만, **QUIC은 자체적으로 시퀀스 번호를 관리하여 순서를 보장**합니다.

- TCP는 패킷이 손실되면 **모든 데이터를 기다려야 하지만**,  
    QUIC은 **독립적인 스트림(Stream) 단위로 데이터 전송**하여 **한 개의 패킷 손실이 전체 요청을 지연시키지 않음**
    
- 이를 통해 **Head-of-Line Blocking 문제를 해결**하고, 패킷 손실이 있어도 나머지 데이터는 정상적으로 수신할 수 있음
-UDP 자체에는 **패킷 손실 시 재전송 기능이 없지만**,  
QUIC은 **자체적으로 패킷을 추적하고 손실된 패킷만 재전송**하는 기능을 구현하였습니다.

- QUIC은 **ACK 확인 메커니즘**을 사용하여, 받은 패킷과 손실된 패킷을 추적
    
- TCP처럼 **모든 패킷이 올 때까지 기다리는 것이 아니라**, **손실된 패킷만 선택적으로 재전송**
    
- 이를 통해 **성능을 유지하면서도 신뢰성 있는 데이터 전송 가능**
##### 그런데, 브라우저는 어떤 서버가 TCP를 쓰는지 UDP를 쓰는지 어떻게 알 수 있나요?
**처음 방문할 때:**
1. 브라우저가 TCP 기반으로 서버에 HTTP 요청을 보냄
2. 서버가 응답하면서 **Alt-Svc 헤더를 통해 HTTP/3(UDP) 지원을 알림**
3. 브라우저는 **다음 요청부터 UDP(QUIC) 기반으로 HTTP/3 연결을 시도**
    
📌 **두 번째 방문할 때:**
4. 브라우저는 **이전 Alt-Svc 정보를 기억하고 곧바로 UDP 기반 HTTP/3 연결 시도**
5. 연결이 실패하면 다시 TCP 기반 HTTP/2로 연결
    
💡 **즉, 브라우저는 먼저 TCP를 사용하고, 서버가 HTTP/3를 지원한다는 정보를 받은 후 UDP(QUIC)로 전환합니다.**
##### 본인이 새로운 통신 프로토콜을 TCP나 UDP를 사용해서 구현한다고 하면, 어떤 기준으로 프로토콜을 선택하시겠어요?
- UDP를 사용하겠습니다. 기존에 TCP와 UDP는 간단하게 느리지만 신뢰성이 높은 프로토콜과 빠르지만 신뢰성이 낮은 프로토콜로 여겨져왔습니다. 하지만 UDP는 흔히 말하든 흰 도화지같은 프로토콜이기 때문에 개발자의 커스터마이징에 따라 TCP와 비슷한 성능을 낼 수도 있습니다. 개발을 진행할 때, 좋은 기능이 모두 들어간 무거운 라이브러리보다는 필요한 기능만 가지고 있는 가벼운 라이브러리를 선호하는 것과 같이 저 또한 UDP를 선택할 것 같습니다.

#### **10. OSI 7계층에 대해 설명해 주세요.**
##### 설명
1️⃣ **물리 계층 (Physical)** → 하드웨어 장비, 전기 신호  
2️⃣ **데이터 링크 계층 (Data Link)** → MAC 주소 기반 통신 (Ethernet, Wi-Fi)  프레임 (Frame)
3️⃣ **네트워크 계층 (Network)** → IP 주소 기반 통신 (라우팅, 최적 경로) 
패킷 (Packet)  
4️⃣ **전송 계층 (Transport)** → 신뢰성 있는 TCP vs 빠른 UDP  세그먼트 (TCP), 데이터그램 (UDP)
5️⃣ **세션 계층 (Session)** → 세션 유지 (로그인, SSH)  
6️⃣ **표현 계층 (Presentation)** → 데이터 암호화/복호화, 압축 (SSL/TLS)  
7️⃣ **응용 계층 (Application)** → HTTP, FTP, DNS 등 사용자 서비스 제공

##### transport Layer와, Network Layer의 차이에 대해 설명해 주세요.
1️⃣ **전송 계층(Transport Layer)** → **프로세스 간 데이터 전송을 담당**
**주요 역할**
- **애플리케이션(프로세스) 간의 데이터 전송을 담당**
- 데이터 전송의 **신뢰성을 보장(TCP)하거나 빠른 전송(UDP)** 제공
- 송신 측에서는 데이터를 **세그먼트(Segment)** 또는 **데이터그램(Datagram)** 형태로 나누고, 수신 측에서는 이를 다시 조립
    
 **사용하는 주소: 포트 번호 (Port Number)**
- 같은 장치 내에서도 여러 프로그램이 네트워크를 사용할 수 있으므로 **포트 번호를 사용하여 프로세스를 구분**
- 예: 웹서버(80번 포트), SSH(22번 포트)
- TCP, UDP를 통해 **신뢰성 있는 전송(TCP) 또는 빠른 전송(UDP) 제공**
- **포트 번호**를 사용하여 프로세스를 구분
    
2️⃣ **네트워크 계층(Network Layer)** → **호스트(장치) 간 패킷을 전달하는 역할
주요 역할**
- **장치(호스트) 간 패킷 전송 및 최적의 경로 설정 (라우팅)**
- 송신 측에서 데이터를 **패킷(Packet)** 단위로 변환하여 전달
- 수신 측에서는 패킷을 받아 상위 계층(전송 계층)으로 전달
    
**사용하는 주소: IP 주소 (IP Address)**
- **장치를 구별하기 위해 IP 주소 사용** (예: 192.168.0.1)
- 목적지 주소를 보고 라우터가 **최적의 경로를 결정**하여 데이터 전달
- IP 주소를 기반으로 **라우팅(경로 설정)** 수행
- **패킷 단위 전송, 신뢰성 보장 없음**
    
💡 **쉽게 말하면, 전송 계층은 "프로그램 간 통신", 네트워크 계층은 "장치 간 통신"을 담당하는 것입니다.** 🚀


##### L3 Switch와 Router의 차이에 대해 설명해 주세요.
L3 스위치와 라우터는 모두 **3계층(IP 계층)**에서 동작하며 **패킷을 목적지까지 전달**하는 역할을 하지만, 기능과 사용 목적에 따라 중요한 차이점이 있습니다.

공통점
- 둘 다 **IP 주소 기반의 라우팅**을 수행합니다.
- **서브넷 간 통신**이 가능하게 해줍니다.
- **라우팅 테이블**을 가지고 있으며, 라우팅 프로토콜을 사용할 수 있습니다.
- 
✅ L3 스위치란?

**L3 스위치**는 기본적으로 **스위칭 장비**입니다. 즉, **MAC 주소를 기반으로 레이어 2에서 빠른 패킷 전송**을 수행합니다. 여기에 **레이어 3(IP 라우팅)** 기능이 추가된 장비로, 주로 **VLAN 간 통신을 위한 내부 라우팅**에 사용됩니다.

L3 스위치는 대부분의 라우팅 처리를 **하드웨어(ASIC) 기반**으로 하기 때문에 매우 빠릅니다. 하지만 **NAT, VPN, 트래픽 제어**와 같은 복잡한 네트워크 기능은 지원하지 않거나 제한적으로만 지원합니다.

 ✅ 라우터란?

**라우터**는 서로 다른 네트워크를 연결하는 장비로, **IP 주소 기반의 라우팅을 전문적으로 처리**합니다. **외부 인터넷과 내부망을 연결하거나, WAN 구간 통신을 위한 용도**로 사용됩니다.

라우터는 **소프트웨어 기반 처리**가 많아 속도는 상대적으로 느릴 수 있지만, 그만큼 **기능이 다양하고 정교한 제어가 가능**합니다. 예를 들어, **NAT, 방화벽, VPN, 트래픽 관리** 등 복잡한 네트워크 정책을 설정할 수 있습니다.
    
- **L3 스위치**: 빠른 속도의 내부 라우팅(VLAN 간 통신), 하드웨어 처리, 단순한 네트워크 구조에 적합
- **라우터**: 복잡한 네트워크 연결과 정책 관리, 다양한 기능 제공, WAN 환경이나 인터넷 연결에 적합
##### 각 Layer는 패킷을 어떻게 명칭하나요? 예를 들어, Transport Layer의 경우 Segment라 부릅니다.
- **Application Layer (응용 계층)**
    - **명칭:** _Data (데이터)_
    - **설명:** 사용자 또는 애플리케이션이 처리하는 실제 정보입니다. 예: 웹 페이지, 이메일 본문 등
        
- **Transport Layer (전송 계층)**
    - **명칭:** _Segment (TCP)_ / _Datagram (UDP)_
    - **설명:** 애플리케이션 데이터를 송수신을 위해 쪼개고, 포트 번호 등을 붙여 보냅니다.  
        TCP는 신뢰성 보장을 위한 **세그먼트**,  
        UDP는 비신뢰성 전송을 위한 **데이터그램**이라 부릅니다.
        
- **Network Layer (네트워크 계층)**
    - **명칭:** _Packet (패킷)_
    - **설명:** 세그먼트에 IP 주소 등 네트워크 정보를 붙인 형태. 라우터는 이 **패킷**을 기반으로 경로를 결정합니다.
        
- **Data Link Layer (데이터 링크 계층)**
    - **명칭:** _Frame (프레임)_
    - **설명:** 패킷에 MAC 주소 등 물리적 네트워크 정보와 에러 검출 코드를 덧붙인 형태입니다. 스위치가 처리하는 단위입니다.
        
- **Physical Layer (물리 계층)**
    - **명칭:** _Bits (비트)_
    - **설명:** 실제 전기 신호, 광 신호, 무선 신호 등으로 변환된 데이터입니다. 1과 0의 비트 스트림으로 전송됩니다.
    
- 각각의 Header의 Packing Order에 대해 설명해 주세요.

4계층 – **전송 계층 (Transport Layer)**
 ▶ TCP Header Packing Order
1. **Source Port (16비트)** – 송신자 포트 번호
2. **Destination Port (16비트)** – 수신자 포트 번호
3. **Sequence Number (32비트)** – 데이터 순서 확인
4. **Acknowledgment Number (32비트)** – 수신 확인용 번호
5. **Data Offset (4비트)** – 헤더 길이
6. **Reserved (3비트)** – 예약 필드
7. **Flags (9비트)** – 제어 플래그(SYN, ACK 등)
8. **Window Size (16비트)** – 수신 윈도우 크기
9. **Checksum (16비트)** – 오류 검출
10. **Urgent Pointer (16비트)** – 긴급 데이터 포인터
11. **Options (가변 길이)** – 선택 사항
12. **Padding (가변 길이)** – 32비트 정렬용

---
 ▶ UDP Header Packing Order
1. **Source Port (16비트)**
2. **Destination Port (16비트)**
3. **Length (16비트)** – 전체 UDP 패킷 길이
4. **Checksum (16비트)** – 오류 검출
---

🟨 3계층 – **네트워크 계층 (Network Layer)**
 ▶ IPv4 Header Packing Order
1. **Version (4비트)** – IP 버전
2. **IHL (4비트)** – 헤더 길이
3. **Type of Service (8비트)** – 서비스 우선순위
4. **Total Length (16비트)** – 전체 패킷 길이
5. **Identification (16비트)** – 패킷 ID (조각화용)
6. **Flags (3비트)** – 조각화 제어
7. **Fragment Offset (13비트)** – 조각 위치
8. **TTL (8비트)** – 생존 시간
9. **Protocol (8비트)** – 상위 계층(TCP/UDP 등) 식별
10. **Header Checksum (16비트)** – IP 헤더 오류 검출
11. **Source IP Address (32비트)**
12. **Destination IP Address (32비트)**
13. **Options (가변)**
14. **Padding (가변)**
    
▶ IPv6 Header Packing Orde
15. **Version (4비트)**
16. **Traffic Class (8비트)**
17. **Flow Label (20비트)**
18. **Payload Length (16비트)**
19. **Next Header (8비트)** – 다음 계층 식별자 (TCP, UDP 등)
20. **Hop Limit (8비트)** – TTL
21. **Source IP Address (128비트)**
22. **Destination IP Address (128비트)**
    
	 
	 🟦 2계층 – **데이터 링크 계층 (Data Link Layer)**

▶ Ethernet II Header Packing Order
1. **Destination MAC Address (48비트)**
2. **Source MAC Address (48비트)**
3. **Type (16비트)** – 상위 프로토콜 (IPv4, ARP 등)
4. **Data (최대 1500바이트)**
5. **Frame Check Sequence (FCS, 32비트)** – 오류 검출용 CRC


##### ARP에 대해 설명해 주세요.
**ARP는 IP 주소에 대응되는 MAC 주소를 알아내기 위한 프로토콜**입니다.  
즉, 같은 네트워크 상에서 **"이 IP 주소를 가진 장치의 MAC 주소가 뭐지?"**를 해결해주는 역할을 합니다.
왜 필요한가요?
- IP 주소는 네트워크 계층(L3)에서 사용하는 주소입니다.
- 하지만 실제 이더넷 네트워크에서 데이터를 전송할 때는 **MAC 주소(물리 주소, L2)** 가 필요합니다.

> 따라서 **IP만 알고 있을 때, 해당 장치의 MAC 주소를 알아내는 방법이 ARP**입니다.

`192.168.0.2` 장치가 `192.168.0.1`에게 데이터를 보내려 함 → MAC 주소 필요
1. **ARP Request (브로드캐스트)**
    - 송신자는 자신의 ARP 캐시에 해당 IP에 대한 MAC 정보가 없을 경우,
    - **"192.168.0.1의 MAC 주소를 아는 사람?"** 이라는 ARP Request를 **브로드캐스트(FF:FF:FF:FF:FF:FF)** 로 전송
    - 이때 패킷에는 송신자의 IP/MAC, 목적지 IP가 포함됨
        
2. **ARP Reply (유니캐스트)**
    - `192.168.0.1`이 요청을 받고, 자신의 IP와 일치한다면
    - **"나는 192.168.0.1이고 내 MAC은 AA:BB:CC:DD:EE:FF야"** 라는 ARP Reply를 **유니캐스트로 응답**
    - 송신자는 이 정보를 받아 ARP 캐시에 저장함
ARP 캐시란?
- ARP로 알아낸 IP-MAC 매핑을 **일정 시간 동안 메모리에 저장**
- 동일한 대상에게 반복적으로 ARP 요청을 하지 않기 위해 사용됨
- 일정 시간 지나면 **자동으로 만료**되며, 필요 시 다시 요청함
#### 11. 3-Way Handshake에 대해 설명해 주세요.
##### 설명
1단계 (SYN - Synchronize)**
- 클라이언트가 서버에게 **연결 요청을 보냄**
- 이때, `SYN`(Synchronize) 플래그가 설정된 패킷을 전송
- 패킷에는 **초기 순서 번호(Sequence Number, SEQ=x)** 포함
- → **"연결할 준비가 되었나요?"**
2단계 (SYN + ACK - Acknowledge)
- 서버가 클라이언트의 요청을 수락하고 응답
- `SYN` 플래그와 `ACK`(Acknowledge) 플래그가 설정된 패킷을 전송
- 서버는 자신의 초기 순서 번호(SEQ=y)를 생성
- 클라이언트의 `SEQ=x` 값을 확인한 후 `ACK=x+1`을 설정하여 응답
- → **"연결 요청을 확인했어요. 나도 연결할 준비가 되었어요!"**
**3단계 (ACK - Acknowledge)**
- 클라이언트가 서버의 응답을 확인하고 마지막 응답을 보냄
- `ACK` 플래그가 설정된 패킷을 전송 (`ACK=y+1`)
- → **"연결이 성공적으로 설정되었습니다!"**
- 이후, 클라이언트와 서버 간 데이터 통신이 시작됨
    
3-Way Handshake 요약**
1️⃣ **클라이언트** → 서버: `SYN (SEQ=x)` (연결 요청)  
2️⃣ **서버** → 클라이언트: `SYN (SEQ=y), ACK (ACK=x+1)` (연결 요청 수락)  
3️⃣ **클라이언트** → 서버: `ACK (ACK=y+1)` (연결 확정)  
🔹 **TCP 연결이 성공적으로 수립됨!**
##### ACK, SYN 같은 정보는 어떻게 전달하는 것 일까요?
TCP에서 `ACK`, `SYN` 같은 정보는 **TCP 헤더의 "플래그(Flags) 필드"**를 사용하여 전달됩니다.  
즉, **TCP 패킷(세그먼트)**의 특정 비트 값을 설정하여 상대방에게 신호를 보내는 방식입니다.
##### 2-Way Handshaking 를 하지않는 이유에 대해 설명해 주세요.
네트워크 지연으로 인한 문제 (Half-Open Connection)**
- 클라이언트가 `SYN`을 보낸 후, **네트워크 지연**으로 인해 응답이 늦게 도착할 수도 있음
- 클라이언트가 이미 연결 요청을 취소했지만, 서버는 `SYN + ACK`을 전송한 상태일 수 있음
 순서 번호(Sequence Number) 동기화 문제**
- TCP는 데이터의 순서를 보장하기 위해 **각 패킷에 순서 번호(Sequence Number, SEQ)를 부여**함.
- 2-Way Handshake에서는 클라이언트와 서버가 **각자의 초기 SEQ 값을 교환할 수 없음.**
    
- **3-Way Handshake에서는 클라이언트와 서버가 서로의 SEQ 값을 확인하고 동기화하기 때문에 데이터 순서를 보장할 수 있음.**
    

 **TCP는 신뢰성을 위해 SEQ 번호를 동기화해야 하므로, 2-Way Handshake로는 불가능!**
    
- **서버는 클라이언트가 연결을 유지한다고 착각하여 불필요한 리소스를 낭비함**
##### 두 호스트가 동시에 연결을 시도하면, 연결이 가능한가요? 가능하다면 어떻게 통신 연결을 수행하나요?
두 호스트가 동시에 서로에게 연결을 시도하는 상황을 **Simultaneous Open** 라고 한다.
Simultaneous Open:각 호스트가 상대방에게 SYN 패킷을 보내 연결을 시도하며, 이 과정에서 각자가 클라이언트와 서버 역할을 동시에 수행한다.

연결 과정
1. **A와 B가 동시에 서로에게 SYN 패킷을 보낸다.**  
    각 호스트의 SYN 패킷에는 자신의 초기 시퀀스 번호(ISN)가 포함되어 있다. 이는 통상적인 연결 요청과 같으나, 양쪽 모두에서 동시에 발생한다.
2. **A는 B로부터 SYN 패킷을 받고, 이에 대한 응답으로 SYN-ACK 패킷을 보냔다.**  
    마찬가지로, B도 A로부터 SYN 패킷을 받고, SYN-ACK 패킷으로 응답한다. 이 단계에서 각 호스트는 상대방의 SYN에 대해 ACK를 보내면서 동시에 자신의 SYN에 대한 ACK도 기대한다.
3. **A와 B 모두, 상대방으로부터 받은 SYN-ACK 패킷에 대해 ACK 패킷으로 응답한다.**  
    이때, 각 ACK 패킷은 상대방의 초기 시퀀스 번호에 1을 더한 값을 포함하여, 상대방의 SYN-ACK를 올바르게 수신했음을 확인한다.

1️⃣ Host A → Host B: SYN (SEQ=100)
2️⃣ Host B → Host A: SYN (SEQ=300)  ← (거의 동시에 발생)
3️⃣ Host A → Host B: SYN+ACK (SEQ=100, ACK=301)
4️⃣ Host B → Host A: SYN+ACK (SEQ=300, ACK=101)
왜 4개의 패킷이 필요한가?**

- **각 호스트가 먼저 SYN을 보내면서 연결을 요청**함.
- 상대방이 보낸 `SYN`을 받고 나서야, **이전 요청과 관계없이 응답(SYN+ACK)을 다시 보내야 함.**
- 즉, **일반적인 3-Way Handshake에서 1개였던 SYN+ACK 패킷이 각각 독립적으로 전송되기 때문에 2개가 필요하게 됨.**
- 마지막 `ACK`이 필요 없는 이유는 **SYN+ACK 패킷을 받으면 서로의 `ACK`을 확인하는 과정이 포함되어 있기 때문**입니다.

##### SYN Flooding 에 대해 설명해 주세요.
**SYN Flooding(신 플러딩) 공격**은 **TCP 3-Way Handshake의 취약점을 이용한 DoS(Denial of Service, 서비스 거부) 공격**입니다.

공격자는 다량의 **SYN 패킷을 보내고, 응답(SYN+ACK)을 받은 후 ACK을 보내지 않음**으로써 서버의 자원을 고갈시켜 정상적인 서비스 제공을 방해합니다.
1️⃣ 공격자 → 서버 : SYN (연결 요청) [엄청나게 많이 보냄]
2️⃣ 서버 → 공격자 : SYN+ACK (연결 수락)
3️⃣ (공격자는 ACK을 보내지 않음 → 서버는 계속 대기)
4️⃣ 일정 시간 동안 서버의 연결 대기 큐가 가득 차면, 정상적인 사용자의 요청을 처리할 수 없게 됨.
공격자는 **ACK을 보내지 않고, 계속해서 SYN 패킷만 전송**하여 서버의 자원을 소비시킵니다.
✔**서버는 SYN+ACK을 보낸 후 클라이언트의 ACK을 기다리는 동안 해당 연결을 유지**해야 합니다.  
✔ 공격자가 이를 악용하여 **엄청나게 많은 SYN 요청을 보내고, ACK을 보내지 않으면 서버는 대기 상태가 되어 자원이 고갈**됩니다.  
✔ 결국, **정상적인 사용자는 서버에 접속할 수 없게 되며, 서비스가 마비되는 DoS 공격이 발생**합니다.
- **공격자가 직접 ACK을 보내지 않으므로 IP 스푸핑(변조)과 함께 사용 가능** → 공격 추적이 어려움.
-SYN Flooding 공격을 방어하는 방법
1️⃣ SYN Cookies 사용** (가장 일반적인 해결책)
- **서버가 SYN 패킷을 받을 때, 클라이언트 정보를 메모리에 저장하는 대신, 이를 암호화하여 SEQ 값에 포함해 응답**하는 방식.
- 클라이언트가 ACK을 보낼 때, 서버는 해당 SEQ 값을 검증하여 유효한 요청인지 확인 가능.
- **메모리에 세션을 저장할 필요가 없어 연결 대기 큐(Backlog Queue)가 차는 문제를 방지할 수 있음.**  
    ✔ 리눅스에서는 `sysctl -w net.ipv4.tcp_syncookies=1` 로 활성화 가능.

2️⃣ Connection Timeout 줄이기**
- 서버가 SYN+ACK을 보낸 후 **ACK을 기다리는 시간(TCP Timeout)을 줄이면, 불필요한 세션을 빨리 제거할 수 있음.**
- 하지만 너무 짧게 설정하면 **일부 정상적인 연결도 끊어질 위험이 있음.**
    

3️⃣ 방화벽(Firewall) 및 IPS(Intrusion Prevention System) 활용**
- 특정 IP에서 **비정상적으로 많은 SYN 요청을 보내는 경우 차단**할 수 있음.
- **IP 스푸핑이 있는 경우 효과가 떨어질 수 있음.**
    
**4️⃣ Rate Limiting (속도 제한)**
- 일정 시간 동안 **특정 IP에서 보낼 수 있는 SYN 패킷의 개수를 제한**하여 과도한 SYN 요청을 차단.
##### 위 질문과 모순될 수 있지만, 3-Way Handshake의 속도 문제 때문에 이동 수를 줄이는 0-RTT 기법을 많이 적용하고 있습니다. 어떤 방식으로 가능한 걸까요?
0-RTT(Zero Round-Trip Time) 기법은 **기존 3-Way Handshake의 왕복 지연(RTT, Round Trip Time)을 줄여서 빠르게 데이터를 전송하는 기술**입니다.  
이 기술은 **TLS 1.3, QUIC(HTTP/3), TCP Fast Open(TFO) 등에서 사용**되며, **이전 연결 정보를 재활용**하여 핸드셰이크 없이 데이터를 전송하는 것이 핵심입니다.
기존 TCP 3-Way Handshake의 문제점
1️⃣ 클라이언트 → 서버 : SYN (연결 요청)
2️⃣ 서버 → 클라이언트 : SYN+ACK (연결 승인)
3️⃣ 클라이언트 → 서버 : ACK (연결 확정)
4️⃣ 이후에야 클라이언트가 데이터를 전송 가능.
✔ **문제점:**

- 이 과정에서 **최소 1 RTT(Round Trip Time)**가 필요하여 **지연(latency)이 발생**함.
    
- 특히 **모바일 환경**이나 **위성 인터넷**처럼 네트워크 지연이 큰 환경에서는 **초기 연결 속도가 매우 느려질 수 있음.**

**0-RTT가 가능한 방식**

0-RTT 기법을 적용하면, **클라이언트가 서버와의 기존 연결 정보를 활용하여 즉시 데이터를 보낼 수 있습니다.**  
주요 방식은 다음과 같습니다.

 **✅ 1. TCP Fast Open(TFO)**

**TCP Fast Open(TFO)**은 **이전 연결의 정보를 캐싱하여 SYN 패킷에서 바로 데이터를 전송하는 방식**입니다.



`1️⃣ 클라이언트 → 서버 : SYN + (TFO Cookie + 데이터) 
2️⃣ 서버 → 클라이언트 : SYN+ACK  
3️⃣ 클라이언트 → 서버 : ACK   ✔ 서버는 SYN을 받자마자 데이터를 처리할 수 있음 → RTT 감소.`

✔ **TFO의 핵심**:

- 서버는 **이전에 접속한 클라이언트에게 "TFO Cookie"를 제공**하고,
    
- 클라이언트는 **다음 접속 시 이 쿠키를 이용해 SYN과 함께 데이터를 전송**하여 핸드셰이크 시간을 줄임.
    

✔ **한계점:**

- **최초 연결에서는 0-RTT가 불가능**하며, **한 번 연결된 서버에 다시 접속할 때만 가능.**
    
- **방화벽 및 일부 네트워크 장비에서 TFO를 차단할 수도 있음.**
    

---

**✅ 2. TLS 1.3의 0-RTT (Early Data)**

TLS 1.3에서는 **기존 TLS 1.2의 핸드셰이크(2-RTT)를 줄이고, 0-RTT 모드를 지원**합니다.  
✔ **기존 TLS 1.2의 문제점**
- 암호화 연결을 위해 최소 **2-RTT가 필요**하여, HTTPS 연결 속도가 느려짐.
✔ **TLS 1.3의 0-RTT 방식**

`1️⃣ 클라이언트 → 서버 : "Hello" 메시지와 함께 이전 세션 키를 포함하여 즉시 데이터 전송   
2️⃣ 서버 → 클라이언트 : 키를 검증한 후, 바로 응답`  
- **이전 세션에서 사용한 암호화 키를 다시 활용**하여, 새로운 핸드셰이크 없이 바로 데이터를 보낼 수 있음.

✔ **한계점:**

- 0-RTT 데이터는 **"Replay Attack(재전송 공격)"**에 취약하므로, **서버는 0-RTT 데이터의 안전성을 검증해야 함.**
    
- **세션 키가 변경되면 0-RTT가 불가능.**
    

---

**✅ 3. QUIC (HTTP/3)**

**QUIC 프로토콜(HTTP/3)**는 **UDP 기반의 전송 프로토콜**로, **3-Way Handshake 없이도 0-RTT 연결을 지원**합니다.

✔ **핵심 개념**

- QUIC은 **UDP 위에서 동작**하며, TCP와 달리 핸드셰이크를 하지 않고 바로 데이터 전송 가능.

- **TLS 1.3과 결합하여 0-RTT로 보안 연결을 설정**할 수 있음.
    
- 기존 TCP의 **Head-of-Line Blocking 문제를 해결**하여, 패킷 손실 시에도 빠른 전송 가능.

✔ **QUIC의 0-RTT 연결 방식**

`1️⃣ 클라이언트 → 서버 : QUIC 연결 요청 + TLS 1.3 0-RTT 데이터 전송   
2️⃣ 서버 → 클라이언트 : 검증 후 응답`  
✔ **장점:**
- **TCP보다 빠른 연결 속도**
- **모바일 네트워크에서 핸드오버(이동 시 연결 유지)에 유리**
- **Head-of-Line Blocking 문제 해결**
    

✔ **한계점:**

- UDP 기반이라 일부 네트워크 환경에서 차단될 가능성이 있음.
    
- TLS 1.3과 결합된 방식이므로 **기본적인 보안 검증이 필요함.**
    

---

**📌 결론**

✔ **3-Way Handshake의 속도 문제를 해결하기 위해 0-RTT 기법이 많이 도입되고 있음.**  
✔ **TCP Fast Open(TFO)**: SYN 패킷에서 바로 데이터를 전송하여 RTT를 줄임.  
✔ **TLS 1.3 0-RTT**: 이전 세션 키를 재사용하여 즉시 암호화된 데이터를 전송.  
✔ **QUIC (HTTP/3)**: UDP 기반으로 TCP Handshake 없이 바로 데이터 전송.

🚀 **결과적으로, 0-RTT 기법을 사용하면 네트워크 지연(Latency)을 줄이고 빠른 응답이 가능해짐.** 🚀

#### 12. 4-Way Handshake에 대해 설명해 주세요.
##### 설명
네트워크를 사용한 통신에서 TCP프로토콜을 이용하여 통신하는 경우 호스트 간 성립(EASTABLISH)된 세션을 종료하기 위한 4단계로 진행되는 과정이다. 서버와 클라이언트 구분없이 연결 종료를 요청하는 호스트가 먼저 FIN 신호를 보내며, TIME-WAIT 상태에 빠지게 된다. 전반적인 흐름을 보면 두번의 요청과 두번의 응답이 있다. 곧바로 연결을 종료하지 않는 이유는 TCP의 신뢰성을 보장하기 위해서이다.

TCP 프로토콜에서 신뢰성 있는 연결을 설정할 땐 3way, 연결을 종료할 땐 4way로 진행된다.
![[Pasted image 20250404171356.png]]
TIME_WAIT 상태가 필요한 이유
1. **ACK가 유실될 경우를 대비**
    - 서버가 FIN을 보내고 클라이언트가 ACK를 보냈을 때, 이 ACK가 손실될 가능성이 있습니다.
    - 서버는 재전송할 수도 있기 때문에, 클라이언트는 **TIME_WAIT 동안 같은 ACK를 다시 보낼 준비**를 합니다.
2. **지연된 패킷 문제 방지**
    - 네트워크에서 늦게 도착한 **이전 연결의 패킷이 새 연결에 영향을 주는 것**을 방지합니다.
    - TIME_WAIT이 끝나면 포트를 완전히 닫아, 이전 패킷이 들어와도 무시됩니다.
##### 패킷이 4-way handshake 목적인지 어떻게 파악할 수 있을까요?
패킷 flag 안에 fin도 있음
##### 빨리 끊어야 할 경우엔, (즉, 4-way Handshake를 할 여유가 없다면) 어떻게 종료할 수 있을까요?
 1. RST(Reset) 패킷을 이용한 강제 종료**
일반적으로 **TCP 4-Way Handshake**는 정상적인 종료 절차지만, 시간이 부족하거나 즉시 연결을 끊어야 하는 경우 **RST(Reset) 플래그를 사용**하면 빠르게 종료할 수 있습니다.
**2. `SO_LINGER` 옵션을 이용한 즉시 종료 (소켓 옵션)**

일반적으로 `close()` 호출 시, 운영체제는 **잔여 데이터 전송을 보장하기 위해** 일정 시간 동안 연결을 유지합니다.  
이를 **즉시 종료**하려면 `SO_LINGER` 옵션을 설정할 수 있습니다.
남아 있는 데이터는 버려질 수 있습니다.
3. `shutdown()` 호출 후 즉시 닫기
소켓을 닫기 전에 `shutdown()` 함수를 사용하면 **절반만 닫고(FIN 전송)**, 그 후 `close()`를 호출하여 빠르게 종료할 수 있습니다.

`shutdown(socket_fd, SHUT_RDWR);  // 읽기/쓰기 모두 차단 close(socket_fd);                // 소켓 즉시 종료`

이 방법을 사용하면 **서버와 클라이언트가 서로 FIN/ACK을 주고받지 않고 종료**할 수 있습니다.

##### 4-Way Handshake 과정에서 중간에 한쪽 네트워크가 강제로 종료된다면, 반대쪽은 이를 어떻게 인식할 수 있을까요?
1. RST(Reset) 패킷을 받는 경우 (즉시 인식)**

네트워크가 정상적으로 동작하지만, 운영체제 또는 애플리케이션이 강제로 종료된 경우,  
해당 호스트의 OS가 자동으로 **RST(Reset) 패킷을 전송**할 수 있습니다.

📌 **RST 패킷이 발생하는 경우**

- 프로그램이 **강제 종료**(`kill -9` 등)되었을 때
    
- `SO_LINGER` 옵션이 설정된 상태에서 `close()`가 호출되었을 때
    
- 네트워크 장비(방화벽 등)가 연결을 강제 종료했을 때
    

📌 **반대쪽이 RST를 수신하면?**

- 즉시 **"Connection reset by peer"** 오류 발생
    
- 연결이 즉시 종료됨 (TIME_WAIT 없이 바로 해제)

**2. Keep-Alive 타이머에 의해 연결 종료 감지 (지연된 인식)**

네트워크가 **완전히 끊어져 RST 패킷도 수신되지 않는 경우**, TCP는 **Keep-Alive** 또는 **타임아웃**을 통해 연결이 끊어졌음을 감지할 수 있습니다.

📌 **Keep-Alive 패킷을 이용한 감지**

- TCP Keep-Alive 옵션이 활성화되어 있으면, **일정 시간 동안 데이터가 없을 때 패킷을 주기적으로 전송**
    
- 응답이 없으면 **연결이 끊겼다고 판단**하고 종료
    

📌 **서버에서 Keep-Alive 활성화 (Linux 예시)**

bash

복사편집

`sysctl -w net.ipv4.tcp_keepalive_time=60   # 60초 후 Keep-Alive 전송 시작 sysctl -w net.ipv4.tcp_keepalive_intvl=10  # 10초마다 재시도 sysctl -w net.ipv4.tcp_keepalive_probes=5  # 5번 재시도 후 연결 종료`

이 설정을 사용하면 **최대 110초(60초 + 10초 × 5번) 내에 연결이 끊어졌는지 확인 가능**합니다.

📌 **반대쪽이 Keep-Alive 응답이 없을 경우**

- `"Connection timed out"` 오류 발생
    
- TCP 연결이 닫힘

3. FIN을 기다리는 상태에서 무한 대기 (TIME_WAIT 또는 CLOSE_WAIT 유지)**

4-Way Handshake 도중 한쪽이 종료되었지만, RST도 없고 Keep-Alive도 사용되지 않는다면,  
반대쪽은 **TIME_WAIT** 또는 **CLOSE_WAIT** 상태에서 일정 시간 동안 대기합니다.

📌 **상황별 반응**  
1️⃣ **FIN_WAIT_1 상태에서 응답이 없음**

- 상대가 응답하지 않으면, 일정 시간 후 연결이 강제 종료됨 (타임아웃 발생)

2️⃣ **FIN_WAIT_2 상태에서 FIN을 받지 못함**
- 상대가 FIN을 보내야 하지만, 네트워크가 끊겨 응답이 없을 경우
- **TIME_WAIT 없이 무한 대기 가능 → 타임아웃 설정 필요**

---

**4. 애플리케이션 레벨에서 직접 감지 (HTTP, WebSocket 등)**

애플리케이션에서 TCP 연결이 끊어졌는지 확인하려면 **주기적으로 데이터를 전송하고 응답을 확인**하는 방식이 있습니다.

📌 **예제: WebSocket에서 Ping/Pong을 사용한 연결 확인**

- **주기적으로 "ping" 전송**
- 응답이 없으면 **연결 끊김 감지** 후 재연결 시도
    
📌 **HTTP Keep-Alive를 이용한 연결 확인**  
HTTP 클라이언트는 **Keep-Alive 헤더**를 사용하여 연결이 유지되는지 확인할 수 있습니다.

하지만 TCP 단에서 연결이 끊어지면, 결국 **응답 없음(Timeout) 상태로 연결이 종료**됩니다.
##### 왜 종료 후에 바로 끝나지 않고, TIME_WAIT 상태로 대기하는 것 일까요?
1. 지연된 패킷 방지:네트워크를 떠돌던 패킷이 다시 도착하는 경우를 방지
2. 마지막 ack 손실 방지:서버가 FIN을 재전송했을 때, 클라이언트가 다시 ACK를 보낼 수 있도록 함
3. 새로운 연결의 안정성 보장:동일한 포트로 새로운 연결을 맺을 때 충돌 방지

지연된 패킷이 네트워크를 떠돌다가 다시 도착하는 경우 방지**

- TCP는 **신뢰성 있는 데이터 전송**을 보장하기 위해 패킷을 재전송할 수 있음
    
- 하지만, 네트워크에서 지연된 패킷이 **이미 닫힌 연결로 다시 도착하면 문제가 발생**할 수 있음
    
- **TIME_WAIT 상태를 유지하면**, 동일한 포트에서 새로운 연결을 열더라도 **잘못된 패킷을 무시할 수 있음**
    

2) 마지막 ACK 손실 시, FIN 재전송을 처리하기 위함**

- 4-Way Handshake에서 마지막 `ACK` 패킷이 네트워크 문제로 손실될 가능성이 있음
    
- 이 경우, 서버는 **FIN을 다시 보내게 됨**
    
- 만약, 클라이언트가 바로 소켓을 닫아버리면 **서버의 FIN을 받을 수 없음**
    
- **TIME_WAIT 상태에서 FIN이 다시 오면, 클라이언트는 정상적으로 ACK를 재전송할 수 있음**
    

📌 **예제 시나리오**

1. 클라이언트가 마지막 `ACK`를 보냄
    
2. 서버가 `ACK`를 정상적으로 받지 못함
    
3. 서버가 `FIN`을 다시 전송
    
4. 클라이언트가 TIME_WAIT 상태에서 `FIN`을 받아 다시 `ACK`를 보냄
#### 13. [www.github.com을](http://www.github.xn--com-of0o/) 브라우저에 입력하고 엔터를 쳤을 때, 네트워크 상 어떤 일이 일어나는지 최대한 자세하게 설명해 주세요.
##### 설명

1. **DNS 조회를 통해 IP 주소 획득**
	1. 브라우저는 `www.github.com`에 해당하는 IP 주소를 알아내야 합니다. 이를 위해 다음 단계를 거칩니다.
	2. **브라우저 캐시 확인**
    - 브라우저는 이전에 `www.github.com`을 방문한 적이 있다면 해당 도메인의 IP 주소를 캐시에서 찾습니다.
	  3.. **운영 체제 (OS) 캐시 확인**
    - 브라우저 캐시에 없다면, OS의 DNS 캐시에서 `www.github.com`의 IP 주소를 조회합니다.
2. **호스트 파일 확인 (`/etc/hosts` 또는 `C:\Windows\System32\drivers\etc\hosts`)**
    - 호스트 파일에 `www.github.com`이 매핑된 IP가 있는지 확인합니다.
3. **DNS 리졸버 (DNS Resolver) 문의**
    - 캐시에 IP가 없다면, 네트워크 인터페이스가 설정한 DNS 서버(예: ISP 제공 DNS, Google Public DNS 8.8.8.8 등)에 질의합니다.
        
    - DNS 서버는 계층적인 조회를 통해 `www.github.com`의 IP를 알아냅니다.
    - 보통 최종적으로 `A` 레코드 (IPv4) 또는 `AAAA` 레코드 (IPv6)를 반환합니다.
    - `www.github.com`의 IP 주소를 받으면 브라우저는 이를 저장하여 요청을 보낼 준비를 합니다.
4. **TCP 3-Way Handshake로 서버와 연결**
5. **TLS Handshake를 통한 보안 연결 수립**
6. **HTTP 요청 전송**
7. **서버의 HTTP 응답 수신**
8. **브라우저가 HTML을 해석하고 렌더링**
9. **추가 리소스 요청 및 페이지 완성**
10. **세션 및 쿠키 관리**

##### DNS 쿼리를 통해 얻어진 IP는 어디를 가리키고 있나요?
-DNS 쿼리를 통해 얻어진 IP 주소는 **www.github.com을 호스팅하는 서버의 실제 위치**를 가리킵니다.
1) 로드 밸런서
2) 실제 웹 서버
3) - 로드 밸런서를 거치지 않는 경우, 해당 IP는 **GitHub의 웹 애플리케이션 서버**를 직접 가리킬 수도 있습니다.
    
- 하지만 대부분의 대형 웹사이트는 **직접 웹 서버 IP를 노출하지 않고** 로드 밸런서를 사용합니다.
 **3) CDN (Content Delivery Network)**
- 일부 웹사이트는 **CDN을 활용하여** 정적 리소스(이미지, CSS, JS 파일)를 캐싱하고 제공합니다.
- `www.github.com`은 직접적인 CDN을 사용하지 않지만, 특정 정적 자원(예: 사용자 프로필 이미지 등)은 CDN을 통해 제공될 수도 있습니다.

##### Web Server와 Web Application Server의 차이에 대해 설명해 주세요.
**2. 웹 서버(Web Server)**
**웹 서버는 클라이언트(브라우저)와 직접 통신하여 정적인 콘텐츠를 제공하는 역할**을 합니다.
**✅ 주요 기능**
- 클라이언트(브라우저)로부터 HTTP 요청을 받아 정적 파일(HTML, CSS, JavaScript, 이미지 등) 제공
- 트래픽 분산을 위한 **로드 밸런서 역할 수행**
- 프록시 서버 기능(리버스 프록시) 제공
- HTTPS를 통한 **보안 통신(SSL/TLS)** 처리
3. 웹 애플리케이션 서버(WAS)**
**WAS는 웹 서버보다 더 복잡한 역할을 수행하며, 동적인 웹 애플리케이션을 실행하는 서버**입니다.  
즉, 클라이언트 요청을 받아 내부 로직을 처리하고, 데이터베이스에서 정보를 가져와 응답을 생성하는 역할을 합니다.

웹 서버에서 동적 리소스 cgi(common gateway interface)
-한계가 있음
1) CGI(Common Gateway Interface)**

- 웹 서버가 외부 프로세스를 실행하여 동적인 응답을 생성
    
- 오래된 방식으로, 현재는 성능 문제로 거의 사용되지 않음
WAS에서 정적 리소스를 제공하는 단점**

✅ **웹 서버보다 성능이 낮음**  
WAS는 기본적으로 동적인 처리를 위해 최적화되어 있으므로, 정적인 리소스를 제공할 때 **성능이 떨어질 수 있음**

- Nginx 같은 웹 서버는 **정적 파일을 캐싱**하고 빠르게 제공 가능
    
- WAS는 **파일을 읽고 서블릿을 통해 응답을 생성**해야 하므로 성능이 떨어짐
    

✅ **트래픽 부담 증가**

- 정적 리소스 요청이 많아지면 WAS에 부하가 걸려 중요한 동적 처리 성능이 저하될 수 있음
    

✅ **보안 문제**

- 정적 리소스를 직접 제공하면, WAS의 경로 구조가 노출될 위험이 있음

**✅ 주요 기능**

- 비즈니스 로직 실행 (예: 로그인, 데이터 처리)
    
- 데이터베이스 연동 및 트랜잭션 관리
    
- 세션 및 인증 관리
    
- JSP, 서블릿, Spring 등의 프레임워크 실행
##### URL, URI, URN은 어떤 차이가 있나요?
**1. URL(Uniform Resource Locator)**

✅ **리소스의 "위치(Location)"를 나타냄**  
URL은 인터넷 상에서 **리소스가 어디에 있는지**를 나타내는 주소입니다.  
즉, **접근 방법(프로토콜) + 위치(도메인, 경로 등)**로 구성됩니다.

**2. URI(Uniform Resource Identifier)**
✅ **리소스를 "식별(Identify)"하는 모든 것**  
URI는 인터넷 상의 **리소스를 식별하는 문자열의 "범용 개념"**입니다.  
즉, **URL과 URN을 포함하는 상위 개념**입니다.

3. URN(Uniform Resource Name)**
✅ **리소스의 "이름(Name)"을 나타냄 (위치는 모름)**  
URN은 리소스의 **고유한 식별자**로, 위치나 접근 방법 없이도 특정 리소스를 식별할 수 있어야 합니다.

**URI는 URL과 URN을 포함하는 상위 개념**  
✔ **URL은 리소스의 "위치"를 나타냄 (ex: 웹 주소)**  
✔ **URN은 리소스의 "고유한 이름"을 나타냄 (ex: ISBN, UUID)**
#### 14. DNS에 대해 설명해 주세요.
**DNS(Domain Name System)**는 **도메인 이름을 IP 주소로 변환하는 시스템**입니다.

##### DNS는 몇 계층 프로토콜인가요?
OSI 7 계층 모델에서 7계층(애플리케이션 계층)에 속함
DNS는 웹 브라우저, 메일 클라이언트 등의 애플리케이션이 사용할 수 있도록 **이름 해석(name resolution)을 제공하는 프로토콜**이므로, **애플리케이션 계층 프로토콜**입니다.

##### UDP와 TCP 중 어떤 것을 사용하나요?
DNS는 **UDP와 TCP를 모두 사용**하지만, 기본적으로는 **UDP 기반**입니다.
**일반적인 DNS 요청**(웹사이트 접속 시 도메인 변환) → **UDP 사용** 
**DNS 응답 크기가 512바이트 초과하거나, 존 전송(AXFR) 시** → **TCP 사용**
DNS는 **빠른 속도와 가벼운 오버헤드**가 중요한 프로토콜이기 때문에, **기본적으로 UDP(User Datagram Protocol)를 사용**합니다.
- DNS는 웹 브라우징 등에서 도메인 해석을 위해 매우 빈번하게 사용되므로, 빠른 응답이 필수
- DNS 요청/응답은 대부분 **512바이트 이하의 작은 데이터**이므로 **신뢰성 있는 TCP가 필요하지 않음**
**✅ TCP로 DNS 요청이 바뀌는 경우** 1️⃣ UDP 응답 손실 또는 실패  
2️⃣ DNS 응답이 너무 커서 UDP 패킷 크기(512바이트)를 초과  
3️⃣ 일부 네트워크 정책이 UDP를 차단하고 TCP만 허용

##### DNS Recursive Query, Iterative Query가 무엇인가요?
1. Recursive Query (재귀 쿼리)**
✅ **"내가 원하는 최종 IP 주소를 찾아서 직접 알려줘!"**  
✅ **DNS 서버가 대신 모든 조회를 수행**하고 최종 응답을 반환
 **📌 동작 과정**
2. 클라이언트(사용자)가 로컬 DNS 서버(Resolver)에게 `www.example.com`의 IP를 요청
3. 로컬 DNS 서버가 직접 **다른 DNS 서버(루트 → TLD → 권한 DNS)에게 질의**
4. 모든 질의가 끝난 후, 로컬 DNS 서버가 최종적인 IP 주소를 클라이언트에게 전달
**📌 예제**

`사용자 → (재귀 요청) → 로컬 DNS 서버          → (재귀적으로 다른 DNS 서버들과 통신하여 최종 응답을 가져옴)   로컬 DNS 서버 → (최종 IP 반환) → 사용자`

**📌 특징**
✅ 클라이언트는 **한 번만 요청**하면 되고, 나머지 과정은 로컬 DNS 서버가 처리  
✅ 클라이언트 입장에서 **쉽고 간단**하지만, 로컬 DNS 서버의 부하 증가

Iterative Query (반복 쿼리)**

✅ **"나는 IP를 모른다. 하지만 어디서 찾을 수 있는지 알려줄게!"**  
✅ **DNS 서버는 직접 답을 주지 않고, 다음 단계의 DNS 서버를 안내**

**📌 동작 과정**
1. 클라이언트가 로컬 DNS 서버(Resolver)에게 `www.example.com`의 IP를 요청
2. 로컬 DNS 서버가 **루트 네임서버에 질의** → "나는 IP를 모르지만, `.com` TLD 서버에 물어봐!"
3. 로컬 DNS 서버가 **TLD 네임서버에 질의** → "나는 IP를 모르지만, `example.com` 네임서버에 물어봐!"
4. 로컬 DNS 서버가 **권한 있는 네임서버에 질의** → "여기 IP 주소가 있다!"
5. 로컬 DNS 서버가 최종 IP 주소를 클라이언트에게 반환

**5. 결론**

✅ **Recursive Query**: DNS 서버가 대신 모든 질의를 수행하여 최종 IP 주소를 반환  
✅ **Iterative Query**: DNS 서버가 직접 답을 주지 않고, 다음 단계의 서버를 안내  
✅ **실제 DNS 동작은 두 방식을 혼합하여 사용**  
✅ **로컬 DNS 서버가 Recursive Query를 받고, 상위 DNS 서버들과 Iterative Query를 수행**

##### DNS 쿼리 과정에서 손실이 발생한다면, 어떻게 처리하나요?
 **재시도(Retry) 및 타임아웃**

DNS 클라이언트(로컬 DNS 서버 포함)는 응답을 일정 시간 동안 기다립니다.  
기본적으로 **UDP는 응답을 기다리지 않지만**, DNS 구현에서는 **타임아웃 후 재시도**를 수행합니다.

✔ **재시도 로직**  
1️⃣ DNS 쿼리를 보낸 후 일정 시간(보통 2~~5초) 응답을 기다림  
2️⃣ 응답이 없으면 동일한 쿼리를 다시 보냄  
3️⃣ 여러 번(일반적으로 3~~5회) 재시도 후에도 응답이 없으면 오류 반환

2) TCP 재시도**

DNS는 기본적으로 **UDP(포트 53)** 를 사용하지만, 응답이 오지 않거나 패킷이 손실될 경우 **TCP로 재시도** 할 수 있습니다.  
✔ 클라이언트는 UDP로 요청 후 응답이 없으면 **TCP(포트 53)로 재시도**하여 신뢰성을 확보합니다.
3)**다른 DNS 서버로 요청 (Failover)**

로컬 DNS 서버는 보통 **여러 개의 상위 DNS 서버**(예: 8.8.8.8, 1.1.1.1)를 설정해둡니다.  
✔ 기본 DNS 서버가 응답하지 않으면 **다른 DNS 서버로 요청을 보냄**  
✔ ISP나 기업 네트워크 환경에서는 **Primary, Secondary DNS 서버를 설정**하여 자동 장애 조치 수행

##### 캐싱된 DNS 쿼리가 잘못 될 수도 있습니다. 이 경우, 어떻게 에러를 보정할 수 있나요?
클라이언트
1) 로컬 DNS 캐시 삭제 (클라이언트 측)
2) 웹 브라우저의 DNS 캐시 삭제
3) 네트워크 장비 (라우터, 모뎀) 
4) 시스템의 DNS 서버 변경
서버
5) DNS 레코드 TTL(Time-To-Live) 조정 (운영 서버 측)

##### DNS 레코드 타입 중 A, CNAME, AAAA의 차이에 대해서 설명해주세요.
**1. A 레코드 (Address Record)**

➡ **"도메인 → IPv4 주소를 매핑"하는 레코드**  
➡ 사용자가 입력한 도메인을 해당 서버의 **IPv4 주소(예: 192.168.1.1)** 로 변환

**📌 특징**
- IPv4(32비트 주소 체계)에서 사용됨
- 한 개의 도메인에 여러 개의 A 레코드를 설정 가능 (로드 밸런싱 가능)

**2. CNAME 레코드 (Canonical Name Record)**

➡ **"도메인 → 다른 도메인으로 매핑"하는 레코드**  
➡ 특정 도메인을 다른 도메인의 **별칭(Alias)으로 설정**
`www.example.com`은 `example.com`을 가리킴  
✔ 사용자가 `www.example.com`을 입력하면, **DNS가 `example.com`의 A 레코드를 조회하여 IP 주소를 반환**
- **IP 주소를 직접 가리키지 않고, 다른 도메인을 가리킴**
- 대상 도메인이 변경되면 CNAME을 수정할 필요 없이 자동으로 반영됨
- **루트 도메인(example.com)에는 CNAME 사용 불가**

3. AAAA 레코드 (IPv6 Address Record)
`example.com` 도메인은 `2606:2800:220:1:248:1893:25c8:1946`라는 IPv6 주소를 가리킴

**📌 특징**
- IPv6 지원을 위해 사용됨
- IPv6 환경에서는 **AAAA 레코드를 먼저 조회**
- A 레코드와 AAAA 레코드를 함께 설정하여 IPv4와 IPv6를 동시에 지원 가능



##### hosts 파일은 어떤 역할을 하나요? DNS와 비교하였을 때 어떤 것이 우선순위가 더 높나요?
**hosts 파일의 역할**
**hosts 파일은 도메인 이름을 특정 IP 주소로 매핑하는 로컬 설정 파일**입니다.  
➡ DNS(Domain Name System)보다 우선순위가 높아, **DNS 조회 없이 직접 매핑된 IP 주소를 사용**할 수 있습니다.
**로컬 개발 및 테스트 환경 설정**

- 개발 중에는 **로컬 서버나 특정 테스트 서버를 사용**해야 할 때가 많습니다.
- 예를 들어, `www.myapp.com`을 로컬 환경(127.0.0.1)로 연결하면 **실제 도메인 대신 로컬 서버를 테스트**할 수 있습니다.
인터넷 연결 없이 특정 도메인 사용**
- **DNS 서버 없이 네트워크를 구성해야 하는 환경**에서도 hosts 파일을 이용하면 도메인과 IP를 직접 매핑 가능
- 예를 들어, 사내 내부망에서 특정 서버(`intranet.local`)를 사용할 때:

dns 보다 우선순위가 높다

#### 20. 멀티플렉싱과 디멀티플렉싱에 대해 설명해 주세요.
##### 설명
**멀티플렉싱(Multiplexing)**과 **디멀티플렉싱(Demultiplexing)**은 네트워크 통신에서 데이터를 효율적으로 전송하고 처리하기 위한 핵심 개념입니다.
- **멀티플렉싱(Multiplexing)**: 하나의 네트워크 연결에서 **여러 개의 애플리케이션(프로세스) 데이터를 동시에 전송**하는 기술
- **디멀티플렉싱(Demultiplexing)**: 받은 데이터를 **올바른 애플리케이션(프로세스)로 전달**하는 과정

➡ 쉽게 말해 **멀티플렉싱은 데이터를 합치는 과정**, **디멀티플렉싱은 데이터를 다시 분리하는 과정**입니다.

**멀티플렉싱(Multiplexing) 과정**
📌 **송신 측에서 실행**
💡 **여러 애플리케이션(프로세스)의 데이터를 하나의 네트워크 연결로 묶어서 전송**

📌 **멀티플렉싱 예시 (클라이언트 → 서버)**

1. **웹 브라우저(Chrome)가 [www.github.com](http://www.github.com) 요청 (포트 443)**
    
2. **파일 전송 프로그램(FTP)이 서버에 연결 (포트 21)**
    
3. **메일 클라이언트(SMTP)가 이메일을 전송 (포트 25)**  
    ➡ 세 개의 애플리케이션이 **같은 네트워크 인터페이스(IP 주소)**를 사용하지만, **다른 포트 번호**를 사용하여 요청을 보냄
    

✅ **즉, 하나의 네트워크 연결에서 여러 애플리케이션 데이터를 구분하여 전송하는 것이 멀티플렉싱!**

디멀티플렉싱(Demultiplexing) 과정**
📌 **수신 측에서 실행**
💡 **받은 데이터를 올바른 애플리케이션(프로세스)로 전달하는 과정**
📌 **디멀티플렉싱 예시 (서버 → 클라이언트)**

1. **서버는 클라이언트의 요청을 받고, 해당 패킷을 확인**
2. **패킷의 목적지 포트 번호를 확인하여 적절한 애플리케이션으로 전달**
    
    - 포트 **443** → `Chrome(HTTPS 요청)`
        
    - 포트 **21** → `FTP 애플리케이션`
        
    - 포트 **25** → `이메일 서버(SMTP)`

##### 디멀티플렉싱 과정
**📌 TCP/UDP 디멀티플렉싱 과정 (단계별 설명)**

**📍 (1) 네트워크 인터페이스에서 패킷 수신**

- 네트워크 카드(NIC, Network Interface Card)가 패킷을 수신함
    

**📍 (2) IP 헤더 분석 → 패킷을 TCP/UDP로 전달**

- IP 패킷의 **프로토콜 필드**를 확인하여 **TCP인지 UDP인지 판단**
    
- **목적지 IP 주소가 현재 장치와 일치하는지 확인**
    
- IP 헤더를 제거하고 **TCP 또는 UDP 계층으로 전달**
    
 **📍 (3) TCP/UDP 헤더 분석 → 포트 번호 확인**

- **목적지 포트 번호를 확인하여, 해당 포트에서 대기 중인 애플리케이션을 찾음**

- TCP 또는 UDP 포트 테이블을 조회하여 **올바른 애플리케이션 소켓으로 전달**
