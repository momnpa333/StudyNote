#### 17. 라우터 내의 포워딩 과정에 대해 설명해 주세요.**
##### 설명
라우터는 네트워크에서 **패킷을 목적지까지 전달하는 역할**을 수행합니다.  
이 과정에서 **포워딩(Forwarding)**이 발생하며, 포워딩은 **도착한 패킷을 적절한 인터페이스로 전송하는 과정**을 의미합니다.
**포워딩 과정의 개요**
✅ **목적지 IP 주소를 확인**하여 **어느 인터페이스(출구)로 보낼지 결정**하고,  
✅ **패킷을 해당 인터페이스로 전송하는 과정**
💡 **즉, "이 패킷을 어디로 보낼 것인가?"를 결정하는 과정**입니다.
**포워딩 과정 요약**
📌 **패킷이 라우터를 통과할 때의 과정**
1. **입력 인터페이스에서 패킷 수신**
2. **목적지 IP 확인 → 라우팅 테이블 조회**
3. **넥스트 홉(Next Hop) 결정**
4. **출력 인터페이스 선택**
5. **MAC 주소 확인 및 재작성**
6. **패킷 전송 (출력 인터페이스로 보냄)**

패킷 수신 (입력 인터페이스)**
- 라우터의 네트워크 인터페이스(포트) 중 하나가 패킷을 수신
- 패킷의 **목적지 IP 주소**를 확인
 **라우팅 테이블 조회**
	라우터는 **라우팅 테이블(Routing Table)을 사용하여 목적지 IP에 대한 경로를 확인**합니다.
**넥스트 홉(Next Hop) 결정**
	라우터는 **라우팅 테이블을 기반으로 패킷을 어디로 보낼지(넥스트 홉) 결정**합니다.
 **출구 인터페이스(출력 인터페이스) 선택**
	 라우터는 넥스트 홉으로 패킷을 보내기 위해 **출력 인터페이스(포트)를 선택**합니다.
**MAC 주소 확인 및 재작성**
	라우터는 **패킷을 이더넷으로 전송하기 위해 MAC 주소를 확인해야 함**  
	➡ ARP(Address Resolution Protocol)를 사용하여 **넥스트 홉의 MAC 주소를 조회**  
	➡ 패킷의 **출발지 MAC 주소를 자신의 MAC으로 변경**  
	➡ 패킷의 **목적지 MAC 주소를 넥스트 홉의 MAC으로 변경**
**패킷 전송 (출력 인터페이스)**
	라우터는 패킷을 **선택된 출력 인터페이스(예: eth2)로 전송**하여, 다음 라우터 또는 최종 목적지로 보냅니다.


#####  라우팅과 포워딩의 차이는 무엇인가요?
**라우팅(Routing)과 포워딩(Forwarding)의 차이**
**💡 한 문장 요약**
- **라우팅(Routing)**: **라우팅 테이블을 구축하는 과정**
- **포워딩(Forwarding)**: **라우팅 테이블을 기반으로 패킷을 전송하는 과정**

🚀 **즉, 라우팅이 "길을 만드는 과정"이라면, 포워딩은 "길을 따라 패킷을 보내는 과정"**입니다.

##### 라우팅 알고리즘에 대해 설명해 주세요.
**정적 라우팅(Static Routing)**: 직접 경로 설정 (작은 네트워크)
- **관리자가 직접 경로를 설정**하여 네트워크를 구성
- 네트워크 변화가 있을 때 **수동으로 변경해야 함**
- 작은 네트워크에서 주로 사용됨
**동적 라우팅(Dynamic Routing)**
- **라우터가 자동으로 최적 경로를 결정하고 변경**
- 라우팅 프로토콜(RIP, OSPF, BGP 등)을 사용
- 네트워크 규모가 크거나 자주 변경되는 경우 사용
✔ **거리 벡터 알고리즘**: 홉 수를 기준으로 경로 설정 (RIP)  
✔ **링크 상태 알고리즘**: 네트워크 전체 구조를 기반으로 최적 경로 설정 (OSPF)

**거리 벡터 알고리즘 (Distance Vector Algorithm)**
**✅ 개념**
- **각 라우터는 이웃 라우터로부터 경로 정보를 받아 업데이트**
- 목적지까지 **"거리(홉 수)"와 "넥스트 홉" 정보만 저장**
- 벨만-포드(Bellman-Ford) 알고리즘 기반
- 예: **RIP 프로토콜** 사용

📌 **작동 방식*
1. 각 라우터는 **이웃 라우터에게 라우팅 테이블을 주기적으로 전송**
2. 라우터는 이웃으로부터 받은 정보를 바탕으로 **자신의 라우팅 테이블을 갱신**
3. 홉 수가 가장 적은 경로를 선택
    

📌 **문제점**  
🚨 **Count to Infinity 문제**
- 특정 경로가 다운되었을 때, **라우팅 테이블이 무한정 증가하는 문제 발생**
💡 **해결 방법**: 스플릿 호라이즌(Split Horizon), 홀드 다운(Hold Down)

**📌 링크 상태 알고리즘 (Link State Algorithm)**
**✅ 개념**
- **네트워크 전체의 링크 정보를 수집하여 최적의 경로를 계산**    
- 다익스트라(Dijkstra) 알고리즘 기반
- 예: **OSPF 프로토콜** 사용
📌 **작동 방식**
1. **각 라우터는 자신과 직접 연결된 링크 정보를 수집**
2. 이 정보를 **모든 라우터와 공유하여 네트워크의 전체 구조를 파악**
3. **다익스트라 알고리즘을 사용하여 최단 경로를 계산**
4. **라우팅 테이블을 업데이트**
    
📌 **특징**  
✔ **정확하고 빠른 라우팅** 가능  
✔ **라우팅 루프 없음**  
🚨 **단점:** 초기 설정 시 오버헤드가 큼
##### 포워딩 테이블의 구조에 대해 설명해 주세요.
*포워딩 테이블(Forwarding Table)**은 **라우터가 패킷을 어디로 전송해야 할지 결정하는 테이블**입니다.  
➡ **라우팅 테이블과 다르며**, 실제 패킷 전송 과정에서 사용됩니다.
🚀 **즉, 패킷이 도착했을 때 "어느 인터페이스로 보낼지"를 빠르게 결정하는 역할을 합니다.**
포워딩 테이블은 일반적으로 **CIDR(Classless Inter-Domain Routing) 형식**으로 저장됩니다.  
➡ 라우팅 테이블보다 단순한 형태이며, 보통 다음과 같은 정보가 포함됩니다.
![[Pasted image 20250405004405.png]]

#### **18. 로드밸런서가 무엇인가요?**
##### 설명:
**로드 밸런서(Load Balancer)**는 **들어오는 트래픽을 여러 서버로 분산하여 부하를 조절하는 역할**을 하는 네트워크 장비 또는 소프트웨어입니다.  
➡ 서버 한 대에 트래픽이 집중되는 것을 방지하고, 시스템 성능을 최적화하며, **가용성(Availability)과 확장성(Scalability)**을 높이는 데 중요한 역할을 합니다.
##### L4 로드밸런서와, L7 로드밸런서의 차이에 대해 설명해 주세요.
로드 밸런서는 **OSI 7 계층 중 어느 계층에서 트래픽을 처리하는지**에 따라 **L4**(전송 계층)와 **L7**(애플리케이션 계층)으로 구분됩니다.

**1. L4 로드 밸런서 (Layer 4 Load Balancer)**

✅ **L4 로드 밸런서는 전송 계층(TCP/UDP)에서 트래픽을 분산**  
➡ **IP 주소와 포트 정보**만을 기반으로 요청을 서버에 분배
**🔹 동작 방식**
1️⃣ 클라이언트가 요청을 보냄  
2️⃣ L4 로드 밸런서가 **IP 주소와 포트(TCP/UDP)만 확인**  
3️⃣ **서버의 상태를 고려하지 않고** 트래픽을 지정된 방식(예: 라운드 로빈)으로 분배  
4️⃣ 응답을 클라이언트에게 반환

 **🔹 특징**
✔ **빠른 속도** → 애플리케이션 계층을 분석하지 않으므로 성능이 뛰어남  
✔ **단순한 부하 분산** → TCP/UDP 연결 정보만 사용하여 간단한 로드 밸런싱  
✔ **세션 유지 불가** → 클라이언트의 요청을 특정 서버에 고정할 수 없음 (일부 해결 가능)
**🔹 예시**
💡 **L4 로드 밸런싱을 사용하는 경우**
- TCP/UDP 기반 서비스 (예: DNS 서버, VoIP, 게임 서버)

**2. L7 로드 밸런서 (Layer 7 Load Balancer)**

✅ **L7 로드 밸런서는 애플리케이션 계층(HTTP/HTTPS)에서 트래픽을 분산**  
➡ **URL, HTTP 헤더, 쿠키, 요청 본문** 등을 분석하여 더 정교한 로드 밸런싱 수행
 **🔹 동작 방식**

1️⃣ 클라이언트가 HTTP/HTTPS 요청을 보냄  
2️⃣ L7 로드 밸런서가 **HTTP 요청 내용을 분석** (예: URL, 쿠키, HTTP 헤더 등)  
3️⃣ 특정 조건(예: URL 패턴(api 엔드포인트), 쿠키 값 등)에 따라 요청을 다른 서버로 분배  
 **🔹 특징**
✔ **정교한 트래픽 분배 가능** → URL, 쿠키, HTTP 헤더 기반 분배  
✔ **세션 유지 가능** → 특정 클라이언트가 항상 같은 서버로 연결 가능 (Sticky Session)  
✔ **SSL 종료 가능** → HTTPS 트래픽을 해독하고 내부 서버에는 HTTP로 전달 가능  
✔ **느릴 수 있음** → 패킷을 깊이 분석해야 하므로 L4보다 성능이 낮을 수 있음

 **🔹 예시**
💡 **L7 로드 밸런싱을 사용하는 경우**
- **URL 기반 분산**: `/api/*` 요청은 A 서버, `/static/*` 요청은 B 서버
- **쿠키/세션 기반 분산**: VIP 고객은 서버 C로, 일반 사용자는 서버 D로
- **SSL 종료**: L7 로드 밸런서에서 HTTPS를 해독하고 내부 서버에 HTTP로 전달

##### 로드밸런서 알고리즘에 대해 설명해 주세요.
1. 라운드 로빈 (Round Robin)

2. 가중치 라운드 로빈

3. **최소 연결 (Least Connections)**
현재 **연결된 세션 수가 가장 적은 서버로 트래픽을 전달**하는 방식입니다.
- 서버 A (현재 연결 3개)
- 서버 B (현재 연결 1개)
- 새로운 요청은 서버 B로 전달
**🔹 장점:**  
✔ 요청 수가 아니라 **실제 부하 상태**를 반영하여 효율적인 분배 가능
**🔹 단점:**  
❌ 연결을 유지하는 요청(예: 웹소켓, 장기 연결)이 많을 경우 비효율적일 수 있음
**💡 사용 예시:**  
➡️ **지속적인 연결을 유지하는 서비스 (예: 데이터베이스, 채팅 서버)**

4. **최소 응답 시간 (Least Response Time)**
5. 해시 기반 (IP Hash, URL Hash)
	클라이언트의 **IP 주소, 쿠키, HTTP 헤더, URL 등 특정 값을 해시(hash) 값으로 변환**하여 특정 서버에 요청을 할당하는 방식입니다.
	**장점:**  
	✔ **세션 유지(Sticky Session)**가 가능하여 로그인 유지가 필요한 서비스에서 유용함
	
	**🔹 단점:**  
	❌ 특정 서버에 부하가 집중될 가능성이 있음

6. 서버 상태 기반 (Dynamic Load Balancing)
	서버의 **CPU, 메모리 사용량, 네트워크 트래픽 등의 상태 정보를 실시간으로 확인**하여 트래픽을 분배하는 방식입니다.
	
	**🔹 동작 방식:**
	
	- CPU 사용률이 낮은 서버를 선택
	    
	- 네트워크 대역폭이 여유로운 서버로 트래픽 전달
	    
	
	**🔹 장점:**  
	✔ 서버의 실시간 상태를 고려한 최적의 부하 분산 가능
	
	**🔹 단점:**  
	❌ 서버 상태를 지속적으로 모니터링해야 하므로, **추가적인 시스템 부하 발생**
	
	**💡 사용 예시:**  
	➡️ **클라우드 환경, 컨테이너 기반 서비스 (예: Kubernetes)**
##### 로드밸런싱 대상이 되는 장치중 일부 장치가 문제가 생겨 접속이 불가능하다고 가정해 봅시다. 이 경우, 로드밸런서가 해당 장비로 요청을 보내지 않도록 하려면 어떻게 해야 할까요?
로드 밸런서가 **장애가 발생한 서버로 트래픽을 보내지 않도록** 하려면, **헬스 체크(Health Check) 기능을 활성화**해야 합니다.

**헬스 체크 방식**

헬스 체크는 보통 **다음과 같은 방법**으로 서버의 상태를 점검합니다.

 **1. HTTP/HTTPS 요청 기반 헬스 체크**
 
로드 밸런서는 **특정 URL에 주기적으로 HTTP 요청을 보내 응답을 확인**합니다.
- 예: `http://example.com/health`
- 서버가 **200 OK** 응답을 반환하면 정상
- 500 오류 또는 응답이 없으면 비정상으로 간주

2.TCP 기반 헬스 체크

**3. 응용 계층(애플리케이션) 기반 헬스 체크**

애플리케이션의 상태를 직접 점검하여 판단하는 방식입니다.  
예를 들어, **메모리 사용률, CPU 부하, 데이터베이스 연결 상태** 등을 확인할 수도 있습니다.
##### 로드밸런서 장치를 사용하지 않고, DNS를 활용해서 유사하게 로드밸런싱을 하는 방법에 대해 설명해 주세요.
로드 밸런서 장치를 사용하지 않고 **DNS를 활용하여 로드 밸런싱**하는 방법은 **DNS 라운드 로빈(Round Robin) 방식**을 사용하는 것입니다.
**GeoDNS (지리 기반 DNS 로드 밸런싱)**
클라이언트의 위치(IP 주소)를 기반으로 **가장 가까운 서버의 IP를 반환**하는 방식입니다.  
예를 들어,
- 미국에서 `www.example.com`을 조회하면 `192.168.1.1` (미국 서버) 반환
- 한국에서 `www.example.com`을 조회하면 `192.168.2.1` (한국 서버) 반환