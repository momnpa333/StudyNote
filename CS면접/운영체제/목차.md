### 1. 시스템 콜이 무엇인지 설명해 주세요.
##### 설명
💡 시스템 콜(System Call)이란?

시스템 콜(System Call)은 사용자 프로그램이 **운영체제 커널의 기능을 요청**하기 위해 사용하는 **인터페이스**입니다.

운영체제는 **사용자 프로그램이 직접 하드웨어나 중요 자원(CPU, 메모리, 디스크 등)에 접근하지 못하게 제한**하고 있습니다. 따라서 파일 입출력, 프로세스 생성, 네트워크 통신 같은 작업을 하려면 **운영체제에 요청**을 해야 하는데, 이때 사용하는 것이 **시스템 콜**입니다.

##### 우리가 사용하는 시스템 콜의 예시를 들어주세요.
✅ 1. **파일 시스템 관련 시스템 콜**

|시스템 콜|설명|
|---|---|
|`open()`|파일을 열고 파일 디스크립터 반환|
|`read()`|파일에서 데이터를 읽음|
|`write()`|파일에 데이터를 씀|
|`close()`|파일을 닫고 자원 반환|
|`lseek()`|파일 포인터 위치를 이동|
 ✅ 2. **프로세스 제어 관련 시스템 콜**

|시스템 콜|설명|
|---|---|
|`fork()`|현재 프로세스를 복제 (자식 프로세스 생성)|
|`exec()`|다른 프로그램 실행|
|`wait()`|자식 프로세스 종료 대기|
|`exit()`|현재 프로세스 종료|
|`getpid()`|현재 프로세스의 PID 반환|
 ✅ 3. **메모리 관리 시스템 콜**

| 시스템 콜              | 설명                 |
| ------------------ | ------------------ |
| `mmap()`           | 파일이나 디바이스를 메모리에 매핑 |
| `brk()` / `sbrk()` | 힙 영역 크기 조절         |
 ✅ 4. **디바이스/입출력 제어**

|시스템 콜|설명|
|---|---|
|`ioctl()`|장치 제어 명령 수행 (예: 터미널 설정)|
 ✅ 5. **네트워크 관련 시스템 콜 (소켓)**

|시스템 콜|설명|
|---|---|
|`socket()`|소켓 생성|
|`bind()`|소켓에 주소 지정|
|`connect()`|서버에 연결|
|`send()`, `recv()`|데이터 송수신|
|`close()`|소켓 닫기|
 ✅ 6. **시간/시스템 정보**

|시스템 콜|설명|
|---|---|
|`gettimeofday()`|현재 시간 가져오기|
|`uname()`|커널 이름, 버전 등 시스템 정보 조회|

🧠 정리

- 시스템 콜은 **운영체제 자원을 요청할 때마다 사용**됨
    
- 우리가 파일을 열거나, 데이터를 읽거나, 프로세스를 생성하거나, 네트워크 통신을 할 때마다 **시스템 콜이 백그라운드에서 수행**
##### 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.
✅ 시스템 콜 실행 과정 (단계별 설명)

1️. **사용자 프로그램에서 시스템 콜 호출**

사용자는 C 언어로 다음과 같이 `read()` 같은 시스템 콜을 호출합니다.

`read(fd, buffer, 100);`

 2️.**소프트웨어 인터럽트(trap) 발생 → 커널 모드 전환**

라이브러리 함수 내부에서는 시스템 콜 번호를 특정 레지스터에 담고, **특별한 CPU 명령어**를 사용하여 커널로 진입합니다.

- x86 (32-bit): `int 0x80`
    
- x86_64: `syscall` 명령어
    
- ARM: `svc` 명령어
    

➡️ 이 명령은 **트랩(trap)**을 발생시켜 현재 실행을 **커널 모드로 전환**합니다.

---
3. 커널 모드로 전환 및 시스템 콜 처리

인터럽트가 발생하면 CPU는 커널 모드로 전환되고, 운영체제는 인터럽트 벡터 테이블을 참조하여 적절한 시스템 콜 핸들러를 호출합니다. 예를 들어, `sys_write()` 함수가 호출되어 파일에 데이터를 씁니다.
    

➡️ 이 과정에서 **직접 하드웨어나 커널 데이터 구조에 접근 가능**

5. **처리 완료 후 결과값 반환**

- 커널은 작업 결과(읽은 바이트 수, 에러 코드 등)를 특정 레지스터에 저장
    
- 트랩 리턴 명령 (`iret`, `sysret` 등)을 통해 **유저 모드로 복귀**
    

6️⃣ **사용자 프로그램은 결과값 확인 후 다음 작업 진행**

사용자 프로그램은 시스템 콜의 반환값을 사용하여 다음 작업을 수행합니다.
`ssize_t bytesRead = read(fd, buffer, 100); if (bytesRead == -1) perror("read failed");`

---

 ✅ 요약 플로우 (한 줄 정리)

> 사용자 코드 → 라이브러리 함수 → 시스템 콜 번호 설정 → trap → 커널 진입 → 핸들러 실행 → 결과 반환 → 유저 모드 복귀

---

🧠 보안과 안정성을 위한 이유

- 사용자 프로그램이 직접 커널 데이터/하드웨어를 다루지 못하게 막기 위해 반드시 **제어된 인터페이스(= 시스템 콜)**를 통해야 함.
    
- 시스템 콜을 거치면 커널이 **검증/제어/로그**를 수행할 수 있어 **안정성과 보안성 확보**
##### 시스템 콜의 유형에 대해 설명해 주세요.
✅ 1. **프로세스 제어(Process Control)**

프로세스 생성, 종료, 실행 중지, 정보 요청 등 **프로세스의 생명주기 관리**에 필요한 시스템 콜입니다.

|시스템 콜|설명|
|---|---|
|`fork()`|현재 프로세스를 복제 (자식 프로세스 생성)|
|`exec()`|새로운 프로그램을 현재 프로세스 공간에 적재|
|`exit()`|프로세스 종료|
|`wait()`|자식 프로세스 종료까지 대기|
|`getpid()`|현재 프로세스의 PID 반환|

---

✅ 2. **파일 시스템 조작(File Manipulation)**

파일 및 디렉터리의 생성, 읽기/쓰기, 삭제 등을 위한 시스템 콜입니다.

|시스템 콜|설명|
|---|---|
|`open()`|파일 열기|
|`read()`|파일 읽기|
|`write()`|파일 쓰기|
|`close()`|파일 닫기|
|`unlink()`|파일 삭제|
|`lseek()`|파일 포인터 이동|

---

✅ 3. **디바이스 제어(Device Manipulation)**

파일 시스템과 유사하지만, **특수한 입출력 장치**와의 상호작용을 위한 시스템 콜입니다.

|시스템 콜|설명|
|---|---|
|`ioctl()`|디바이스 제어 명령 수행|
|`read()`|디바이스로부터 읽기|
|`write()`|디바이스에 쓰기|

---

✅ 4. **정보 유지(Information Maintenance)**

프로세스, 시간, 시스템 설정 등 운영체제에 관련된 정보를 가져오거나 설정하는 시스템 콜입니다.

|시스템 콜|설명|
|---|---|
|`getpid()`|현재 프로세스 ID 가져오기|
|`alarm()`|시간 기반 알림 설정|
|`gettimeofday()`|시스템 시각 조회|
|`uname()`|커널/시스템 정보 가져오기|

---
✅ 5. **통신(Communication)**

프로세스 간 통신(IPC)을 위한 시스템 콜입니다. 주로 **소켓 기반 통신**이나 **파이프, 공유 메모리** 등을 다룹니다.

|시스템 콜|설명|
|---|---|
|`pipe()`|익명 파이프 생성 (단방향)|
|`socket()`|네트워크 소켓 생성|
|`connect()`|서버에 연결|
|`send()`, `recv()`|데이터 송수신|
|`shmget()`|공유 메모리 생성|

##### 운영체제의 Dual Mode 에 대해 설명해 주세요.
✅ 운영체제의 Dual Mode란?

**Dual Mode**는 컴퓨터 시스템이 **두 가지 실행 모드**—  
👉 **User Mode(사용자 모드)**와  
👉 **Kernel Mode(커널 모드)**를 갖는 구조를 말합니다.

이는 **보안과 안정성**을 위해 운영체제가 **실행 권한을 구분**하는 중요한 메커니즘입니다.

---
🔍 각 모드의 특징

| 구분    | 사용자 모드 (User Mode)          | 커널 모드 (Kernel Mode)              |
| ----- | --------------------------- | -------------------------------- |
| 실행 주체 | 일반 사용자 프로그램                 | 운영체제 커널                          |
| 접근 권한 | 제한됨 (I/O, 메모리 등 직접 접근 불가)   | 시스템 자원 전체 접근 가능 (하드웨어, 메모리 등)    |
| 위험도   | 낮음 (잘못된 명령은 운영체제가 감지/차단 가능) | 높음 (커널 오류는 시스템 전체 다운으로 이어질 수 있음) |
| 전환 방법 | 시스템 콜, 인터럽트 등을 통해 커널 진입     | 작업 완료 후 사용자 모드로 복귀               |
|       |                             |                                  |

---
##### 왜 유저모드와 커널모드를 구분해야 하나요?
왜 Dual Mode가 필요한가?

1. **보안(Security)**
    
    - 사용자 프로그램이 **디스크, 네트워크, 메모리** 같은 자원을 **마음대로 건드리지 못하게** 막습니다.
        
2. **안정성(Stability)**
    
    - 사용자 코드의 오류나 악의적인 행동이 시스템 전체에 영향을 주지 않도록 격리합니다.
        
3. **운영체제 통제 유지**
    - 운영체제는 시스템 자원의 **공정한 분배, 보호, 관리**를 책임집니다.
	- 이를 위해 사용자 프로그램은 반드시 **운영체제를 통해 자원을 요청**하게 설계되어야 하며, 그 통로가 **시스템 콜**입니다.
        
---
##### 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
- 시스템 콜을 구분하는 기준은 **시스템 콜 번호**
- 운영체제는 **시스템 콜 벡터 테이블**을 통해 번호 → 함수 매핑
- 이 구조 덕분에 운영체제가 **안전하게 수많은 시스템 콜을 빠르게 구분**할 수 있음
### 2. 인터럽트가 무엇인지 설명해 주세요.
##### 설명
✅ 인터럽트란?

**인터럽트(Interrupt)**는 **현재 실행 중인 작업을 잠시 멈추고**,  
운영체제가 **긴급하거나 중요한 작업을 먼저 처리할 수 있도록 제어 흐름을 전환하는 메커니즘**입니다.

즉, **CPU의 흐름을 외부/내부 이벤트가 "가로채는" 것**입니다.

✅ 왜 필요한가?

- CPU는 기본적으로 **순차적으로 명령어를 처리**합니다.
    
- 하지만 주변 장치나 프로그램이 언제 어떤 요청을 보낼지 예측할 수 없습니다.
    
- 따라서 CPU가 **일일이 기다리지 않고**, 이벤트가 발생하면 **즉시 응답**할 수 있도록 **인터럽트가 필요**합니다.
    
✅ 인터럽트의 종류

| 유형                 | 설명                                               | 예시                 |
| ------------------ | ------------------------------------------------ | ------------------ |
| **하드웨어(외부) 인터럽트**  | 외부 장치가 CPU에게 이벤트 발생을 알리는 경우                      | 키보드 입력, 디스크 입출력 완료 |
| **소프트웨어(내부) 인터럽트** | 프로그램이 의도적으로 커널 기능을 요청하기 위해 발생시키는 인터럽트 (**Trap**) | 시스템 콜, 예외 처리       |
| **예외(Exception)**  | 프로그램 실행 중 오류가 발생한 경우                             | 0으로 나누기, 페이지 폴트    |

---

##### 인터럽트는 어떻게 처리하나요?
🔁 인터럽트 처리 과정 (6단계 요약)

1️⃣ 인터럽트 발생

- **외부 장치**(예: 키보드, 디스크)가 요청하거나
    
- **CPU 내부에서 예외나 시스템 콜**이 발생하면 인터럽트가 발생합니다.
    
 2️⃣ 현재 작업 상태 저장

- CPU는 현재 실행 중인 프로그램의 **Program Counter(PC), 레지스터** 등의 정보를 **스택에 저장**합니다.
    
- 이는 나중에 **원래 작업으로 복귀하기 위해 필수적인 단계**입니다.
    

3️⃣ 커널 모드로 전환

- 인터럽트가 발생하면 **하드웨어가 자동으로 CPU를 커널 모드로 전환**합니다.
    
- 유저 모드에서는 시스템 자원에 접근할 수 없기 때문에, **인터럽트 처리는 반드시 커널 모드에서 이루어집니다.**
    
 4️⃣ 인터럽트 벡터 테이블 참조

- CPU는 **인터럽트 번호(ID)**를 기반으로  
    **인터럽트 벡터 테이블**에서 해당 **인터럽트 핸들러 함수의 주소**를 조회합니다.
    
5️⃣ 인터럽트 핸들러 실행

- 해당 핸들러 함수가 실행되어, 요청된 작업(I/O 완료 처리, 데이터 수신 등)을 수행합니다.
    
6️⃣ 저장된 상태 복원 후 복귀

- 인터럽트 처리가 끝나면, **스택에 저장해둔 상태를 복원**하고  
    **중단된 작업으로 복귀**하여 프로그램 실행을 이어갑니다.
    

📌 예시: 키보드 인터럽트

1. 사용자가 키보드를 누름
    
2. **키보드 컨트롤러가 인터럽트(IRQ1)**를 발생시킴
    
3. CPU는 해당 인터럽트의 핸들러(0x21)를 호출
    
4. 키보드 입력을 OS 버퍼에 저장
    
5. 사용자 프로그램으로 복귀
    ✅ 정리

|단계|설명|
|---|---|
|1. 인터럽트 발생|외부 장치나 내부 예외 발생|
|2. 상태 저장|현재 CPU 상태 저장 (문맥 보존)|
|3. 모드 전환|유저 모드 → 커널 모드|
|4. 핸들러 조회|인터럽트 벡터 테이블에서 함수 찾기|
|5. 핸들러 실행|이벤트 처리|
|6. 복귀|저장된 상태 복원 후 사용자 프로그램 계속 실행|

---

##### Polling 방식에 대해 설명해 주세요.
Polling 방식이란?

**Polling(폴링)**은 **CPU가 주기적으로 장치 상태를 직접 확인(poll)**하여  
작업이 가능한지를 판단하는 **능동적 감시 방식**입니다.

> 즉, "지금 됐나?", "이제 됐나?" 하고 **계속 물어보는 방식**입니다.

---
 ✅ Polling의 동작 방식

1. CPU는 장치 레지스터나 상태 비트를 **반복적으로 읽음**
    
2. 장치가 작업을 완료하거나 준비되었는지를 확인
    
3. 준비가 되었으면 필요한 작업을 수행 (ex: 데이터 읽기)
    
4. 아니면 일정 시간 대기하거나 다시 확인
    

## ✅ Polling vs Interrupt

|항목|Polling 방식|인터럽트 방식|
|---|---|---|
|감지 방법|CPU가 직접 상태를 반복 확인|장치가 이벤트 발생 시 CPU에 알림|
|자원 효율성|비효율적 (CPU가 바쁘게 기다림)|효율적 (CPU는 다른 일 하다가 필요할 때만 반응)|
|반응 속도|빠를 수 있음 (항상 감시 중)|약간 지연 가능 (인터럽트 발생 후 처리)|
|구현 복잡도|간단함|복잡함 (인터럽트 핸들러, 문맥 전환 등 필요)|
|용도 예시|마우스, 디스플레이 등 **지속적 감시가 필요한 경우**|네트워크 수신, 키보드 입력 등 **비정기적 이벤트**|

---

## ✅ Polling의 장점과 단점

### 장점

- 구현이 단순함
    
- 예측 가능한 처리 시점 (실시간성이 필요한 경우 사용 가능)
    

### 단점

- **CPU 낭비**: 응답이 올 때까지 계속 확인해야 함
    
- **다른 작업을 병행하기 어려움**
    

---

## ✅ 언제 Polling을 사용하는가?

- **하드 리얼타임 시스템** (항상 일정 주기로 상태 점검이 필요한 경우)
    
- **간단한 임베디드 시스템** (인터럽트 컨트롤러가 없는 경우)
    
- **I/O가 아주 빠르거나 빈번한 경우**
    

---

## ✅ 요약

|핵심 정리|
|---|
|Polling은 CPU가 주기적으로 장치 상태를 직접 확인하는 방식|
|구현은 간단하지만, CPU 자원을 비효율적으로 사용함|
|인터럽트 방식과는 자원 활용 방식에서 뚜렷한 차이가 있음|
##### HW / SW 인터럽트에 대해 설명해 주세요.
##### 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?

### 3. 프로세스가 무엇인가요?
- 프로그램과 프로세스, 스레드의 차이에 대해 설명해 주세요.
- PCB가 무엇인가요?
- 그렇다면, 스레드는 PCB를 갖고 있을까요?
- 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까요?
- 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?
- 리눅스에서, 데몬프로세스에 대해 설명해 주세요.
- 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

### 4. 프로세스 주소공간에 대해 설명해 주세요.
- 초기화 하지 않은 변수들은 어디에 저장될까요?
- 일반적인 주소공간 그림처럼, Stack과 Heap의 크기는 매우 크다고 할 수 있을까요? 그렇지 않다면, 그 크기는 언제 결정될까요?
- Stack과 Heap 공간에 대해, 접근 속도가 더 빠른 공간은 어디일까요?
- 다음과 같이 공간을 분할하는 이유가 있을까요?
- 스레드의 주소공간은 어떻게 구성되어 있을까요?
- "스택"영역과 "힙"영역은 정말 자료구조의 스택/힙과 연관이 있는 걸까요? 만약 그렇다면, 각 주소공간의 동작과정과 연계해서 설명해 주세요.
- IPC의 Shared Memory 기법은 프로세스 주소공간의 어디에 들어가나요? 그런 이유가 있을까요?
- 스택과 힙영역의 크기는 언제 결정되나요? 프로그램 개발자가 아닌, 사용자가 이 공간의 크기를 수정할 수 있나요?

### 5. 단기, 중기, 장기 스케쥴러에 대해 설명해 주세요.
- 현대 OS에는 단기, 중기, 장기 스케쥴러를 모두 사용하고 있나요?
- 프로세스의 스케쥴링 상태에 대해 설명해 주세요.
- preemptive/non-preemptive 에서 존재할 수 없는 상태가 있을까요?
- Memory가 부족할 경우, Process는 어떠한 상태로 변화할까요?

### 6. 컨텍스트 스위칭 시에는 어떤 일들이 일어나나요?
- 프로세스와 스레드는 컨텍스트 스위칭이 발생했을 때 어떤 차이가 있을까요?
- 컨텍스트 스위칭이 발생할 때, 기존의 프로세스 정보는 커널스택에 어떠한 형식으로 저장되나요?
- 컨텍스트 스위칭은 언제 일어날까요?

### 7. 프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?
- RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.
- 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?
- 동시성과 병렬성의 차이에 대해 설명해 주세요.
- 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?
- FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?
- 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?
- 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

### 8. 뮤텍스와 세마포어의 차이점은 무엇인가요?
- 이진 세마포어와 뮤텍스의 차이에 대해 설명해 주세요.
- Lock을 얻기 위해 대기하는 프로세스들은 Spin Lock 기법을 사용할 수 있습니다. 이 방법의 장단점은 무엇인가요? 단점을 해결할 방법은 없을까요?
- 뮤텍스와 세마포어 모두 커널이 관리하기 때문에, Lock을 얻고 방출하는 과정에서 시스템 콜을 호출해야 합니다. 이 방법의 장단점이 있을까요? 단점을 해결할 수 있는 방법은 없을까요?

### 9. Deadlock 에 대해 설명해 주세요.
- Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.
- 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?
- 어떤 방식으로 예방할 수 있을까요?
- 왜 현대 OS는 Deadlock을 처리하지 않을까요?
- Wait Free와 Lock Free를 비교해 주세요.

### 10. 프로그램이 컴파일 되어, 실행되는 과정을 간략하게 설명해 주세요.
- 링커와, 로더의 차이에 대해 설명해 주세요.
- 컴파일 언어와 인터프리터 언어의 차이에 대해 설명해 주세요.
- JIT에 대해 설명해 주세요.
- 본인이 사용하는 언어는, 어떤식으로 컴파일 및 실행되는지 설명해 주세요.
- Python 같은 언어는 CPython, Jython, PyPy등의 다양한 구현체가 있습니다. 각각은 어떤 차이가 있을까요? 또한, 실행되는 과정 또한 다를까요?
- 우리는 흔히 fork(), exec() 시스템 콜을 사용하여 프로세스를 적재할 수 있다고 배웠습니다. 로더의 역할은 이 시스템 콜과 상관있는 걸까요? 아니면 다른 방식으로 프로세스를 적재할 수 있는 건가요?

### 11. IPC가 무엇이고, 어떤 종류가 있는지 설명해 주세요.
- Shared Memory가 무엇이며, 사용할 때 유의해야 할 점에 대해 설명해 주세요.
- 메시지 큐는 단방향이라고 할 수 있나요?

### 12. Thread Safe 하다는 것은 어떤 의미인가요?
- Thread Safe 를 보장하기 위해 어떤 방법을 사용할 수 있나요?
- Peterson's Algorithm 이 무엇이며, 한계점에 대해 설명해 주세요.
- Race Condition 이 무엇인가요?
- Thread Safe를 구현하기 위해 반드시 락을 사용해야 할까요? 그렇지 않다면, 어떤 다른 방법이 있을까요?

### 13. Thread Pool, Monitor, Fork-Join에 대해 설명해 주세요.

### 14. 캐시 메모리 및 메모리 계층성에 대해 설명해 주세요.

### 15.메모리의 연속할당 방식 세 가지를 설명해주세요. (first-fit, best-fit, worst-fit)

### 16. Thrashing 이란 무엇인가요?


### 17. 가상 메모리란 무엇인가요?


### 18. 세그멘테이션과 페이징의 차이점은 무엇인가요?

### 19. TLB는 무엇인가요?

### 20. 동기화를 구현하기 위한 하드웨어적인 해결 방법에 대해 설명해 주세요.


### 21. 페이지 교체 알고리즘에 대해 설명해 주세요.

### 22. File Descriptor와, File System에 에 대해 설명해 주세요.
### 23. 동기와 비동기, 블로킹과 논블로킹의 차이에 대해 설명해 주세요.
