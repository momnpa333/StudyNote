### 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.
##### 설명
데이터베이스에서 **Key(키)**는 테이블 내의 **튜플(레코드)을 유일하게 식별**하기 위해 사용되는 중요한 개념입니다.

🔑 1. **Super Key (슈퍼키)**
- 한 릴레이션(테이블)에서 **튜플을 유일하게 식별할 수 있는 속성 또는 속성들의 집합**.
- 하나 이상의 속성으로 구성될 수 있으며, **유일성은 보장되지만 최소성은 보장되지 않음**.

`학생 테이블 (학번, 이름, 이메일) -> 슈퍼키 예시: {학번}, {이메일}, {학번, 이름}, {학번, 이메일}`

---

🔑 2. **Candidate Key (후보키)**
- 슈퍼키 중에서 **속성의 수가 가장 적은, 즉 최소성을 만족하는 키**.
- 하나의 테이블에 여러 개의 후보키가 존재할 수 있으며, 이 중 하나를 **기본키(Primary Key)**로 선택함.

`학생 테이블에서 {학번}, {이메일}이 각각 유일하다면 둘 다 후보키가 될 수 있음.`

---

🔑 3. **Primary Key (기본키)**
- 후보키 중에서 **주 식별자로 선택된 키**.
- **NULL을 가질 수 없고**, **중복도 허용되지 않음**.
- 하나의 테이블에는 반드시 하나의 기본키만 존재.
---
🔑 4. **Alternate Key (대체키)**
- 후보키들 중에서 **기본키로 선택되지 않은 나머지 키들**.
- 기본키 외에 유일한 값을 가지는 키로 사용할 수 있음.
---
 🔑 5. **Foreign Key (외래키)**
- **다른 테이블의 기본키를 참조하는 키**.
- 테이블 간의 관계를 표현할 때 사용.
- 외래키는 참조하는 기본키의 값만 가질 수 있으며, 데이터 무결성을 유지하는 데 중요함.
---
🔑 6. **Composite Key (복합키)**
- **두 개 이상의 속성으로 구성된 키**로, 이 속성들의 조합이 유일성을 만족해야 함.
- 보통 단일 속성만으로 유일하지 않을 때 사용.
---
🔑 7. **Unique Key**
- **중복을 허용하지 않는 키**.
- 기본키처럼 유일성을 가지지만, **NULL을 허용**할 수 있음.
- 하나의 테이블에 여러 개 존재할 수 있음.
##### 기본키는 수정이 가능한가요?
1. **기술적으로는 수정 가능**
하지만 아래와 같은 문제가 발생할 수 있습니다.
2. **기본키를 수정하는 것이 바람직하지 않은 이유**
 ✅ **1) 참조 무결성 제약 위반 가능**
- 다른 테이블에서 **외래키(Foreign Key)**로 해당 기본키를 참조하고 있다면, 기본키를 수정할 경우 **참조 관계가 깨지거나 에러가 발생**할 수 있습니다.
 ✅ **2) 논리적으로 변경되면 안 되는 값일 가능성**
- 기본키는 해당 레코드를 유일하게 식별하는 값입니다.
- 보통 **학번, 사번, 주민등록번호, UUID** 등 **변경되지 않는 값**을 사용하는 것이 일반적입니다.
 ✅ **3) 시스템 전체에 영향**
- 기본키는 다양한 곳에서 사용될 수 있습니다.
    - 예: 조인, 조회, 외래키, 로그 테이블 등
- 기본키 값이 변경되면 **관련된 모든 테이블과 쿼리에서 함께 변경해주어야 하므로 유지보수 비용이 큼**.
 ✅ 클러스터링 인덱스(Clustered Index)
 🔹 개념
- **인덱스와 실제 데이터가 같은 B+Tree 구조 안에 저장됨**
- 즉, **인덱스의 순서 = 실제 레코드의 저장 순서**
- MySQL(InnoDB)에서는 **기본키가 클러스터링 인덱스**
 🔹 물리적 저장 방식
- 디스크에 있는 **데이터 페이지 자체가 인덱스 구조에 포함됨**
- 따라서 **인덱스를 따라가면 곧바로 실제 레코드에 도달**함 → **추가 조회 없이 바로 사용 가능**
    
 🔹 장점
- **범위 검색, 정렬** 성능 우수 (인덱스가 곧 정렬된 데이터)
- **I/O 효율**이 높음
🔹 단점
- **기본키 변경/삽입 시 물리적 정렬 필요 → 성능 저하 가능**
- **하나의 테이블에 하나만 존재 가능**
##### 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?
MySQL에서는 기본키를 명시하지 않아도 테이블을 생성할 수 있습니다. 이는 SQL 표준에서도 기본키를 **필수로 요구하지 않기 때문**이며, MySQL의 스토리지 엔진인 **InnoDB의 내부 동작 방식**과 관련이 있습니다.

InnoDB는 **클러스터형 인덱스**를 사용하는 구조입니다. 클러스터형 인덱스란, **테이블의 실제 데이터가 특정 인덱스를 기준으로 정렬되고 저장되는 방식**을 의미합니다.
InnoDB는 클러스터 인덱스를 반드시 가져야 하므로, 다음과 같은 우선순위로 이를 결정합니다:
1. **명시된 기본키가 있다면** → 해당 키를 클러스터 인덱스로 사용
2. **기본키가 없고, NOT NULL + UNIQUE 제약을 가진 컬럼이 있다면** → 그 컬럼을 클러스터 인덱스로 사용
3. **그마저도 없다면** → InnoDB가 **6바이트의 내부 Row ID**를 자동 생성하여 클러스터 인덱스로 사용합니다
    
즉, 기본키가 없어도 InnoDB는 내부적으로 **레코드를 유일하게 식별할 수 있는 방법을 항상 갖고 있기 때문에 테이블 생성이 가능한 것**입니다.

##### 외래키 값은 NULL이 들어올 수 있나요?
✅ **외래키(Foreign Key) 컬럼에는 `NULL` 값이 들어올 수 있습니다.**

🔍 이유 설명

외래키는 **다른 테이블의 기본키 또는 유니크 키를 참조**하는 제약 조건입니다.  
하지만 SQL 표준과 대부분의 데이터베이스 시스템(MySQL 포함)에서는

> 외래키 컬럼에 `NULL`이 들어가는 것은 **제약 조건을 위반하는 것이 아니다**  
> 라고 명시하고 있습니다.

 🔥 NULL이 지니는 의미
`FK`에 NULL값이 들어 갈 수 있는지 알아보기 이전에, 먼저 NULL이 지니는 의미에 대해 먼저 알아보겠습니다.

`NULL`이 의미하는 바는 다음과 같습니다.
1️⃣ 값이 존재하지 않는다
2️⃣ 값이 존재하지만, 아직 그 값이 무엇인지 알지 못한다
3️⃣ 해당 사항과 관련이 없다

FK는 관계를 맺고자하는 테이블의 PK 값을 참조합니다.  반대로 생각해보면 관계를 맺고자하는 테이블의 PK 값이 이미 존재해야 합니다.

이러한 상황에 관계를 맺고자하는 테이블의 레코드가 아직 생성되지 않았다면?
값이 존재하지만(언젠가 값이 추가될 것이지만), 아직 그 값을 알 수 없다는 의미가 됩니다. 따라서 FK에는 NULL이 들어갈 수 있습니다.

 이유는?
- 외래키 제약은 "값이 있는 경우"에만 **참조 무결성**을 검사합니다.
- **`NULL`은 ‘값이 없다’는 의미**이기 때문에 참조할 필요가 없는 것으로 간주됩니다.
##### 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?
- MySQL에서는 `UNIQUE` 제약이 설정된 컬럼에 대해 **자동으로 인덱스를 생성**합니다.
- 이 인덱스는 해당 컬럼에 대해 **검색, 정렬, 조인 등에서 성능 향상**에 기여합니다.
 - `UNIQUE` 제약은 인덱스 성능 향상 외에도 **중복을 막는 제약 조건**이므로 **데이터 삽입 시 추가적인 체크 비용**이 존재합니다.    
-  즉, `INSERT`나 `UPDATE`에서 성능 오버헤드가 조금 있을 수 있습니다.    
- 인덱스는 성능을 향상시키지만, **남용하면 오히려 쓰기 성능에 악영향**을 줄 수 있습니다.
### 2. RDB와 NoSQL의 차이에 대해 설명해 주세요.
##### 설명
RDB는 테이블 기반의 정형 데이터를 저장하며, 스키마가 고정되어 있고 트랜잭션과 정합성이 강한 것이 특징입니다. 반면 NoSQL은 문서, 키-값, 그래프 등 다양한 형태로 데이터를 저장하며, 유연한 스키마와 수평 확장성에 강점을 가집니다. 따라서 정합성이 중요한 금융 시스템엔 RDB가, 유연성과 확장성이 필요한 SNS나 로그 시스템엔 NoSQL이 적합합니다.

##### NoSQL의 강점과, 약점이 무엇인가요?
✅ NoSQL의 **강점(장점)**
1. 📦 **스키마 유연성**
	- **스키마 정의 없이 자유롭게 필드 추가/변경** 가능
	- 구조가 자주 바뀌는 데이터, 빠른 개발에 유리
	- 👉 예: JSON 형태로 자유롭게 저장되는 MongoDB
2. 🌐 **수평 확장성(Scale-out) 용이**
	- 여러 대의 서버에 쉽게 데이터를 분산 저장 가능
	- 대량의 데이터를 처리하거나, 트래픽이 높은 환경에 적합
	- 👉 예: Cassandra, MongoDB는 분산 저장을 기본 전제로 설계
 3. ⚡ **빠른 읽기/쓰기 성능 (특정 조건 하)**
	- RDB보다 복잡한 JOIN, 트랜잭션 처리를 피하기 때문에 빠름
	- 캐시, 로그 저장, 실시간 피드 등에서 성능 우수
	- 👉 예: Redis는 메모리 기반 키-값 저장소로 빠른 응답 제공
 4. 🧩 **다양한 데이터 모델 지원**
	- 문서형, 키-값형, 그래프형, 컬럼형 등 데이터 특성에 따라 선택 가능
	- 👉 예: Neo4j는 복잡한 관계 데이터를 그래프로 표현
---
 ❌ NoSQL의 **약점(단점)**
 1. 🔄 **JOIN, 정교한 쿼리의 제한**
	- 일반적으로 JOIN, 복잡한 관계 연산을 지원하지 않거나 성능이 떨어짐
	- 👉 관계가 복잡한 데이터에는 부적합
 2. 🔒 **ACID 트랜잭션의 제한**
	- 대부분의 NoSQL은 **트랜잭션을 완벽하게 보장하지 않음**
	- **BASE 모델**: 일관성보다 가용성과 확장성을 우선
	- 👉 은행, 회계 시스템 등 강한 정합성 요구 시스템에 부적합
 3. ⚠️ **데이터 중복, 정규화 부족**
	- JOIN이 없기 때문에 데이터를 중복 저장하는 경우 많음
	- 유지보수 시 일관성 관리가 어려울 수 있음
 4. 🧑‍💻 **표준화 부족 및 학습 곡선**
	- 제품별 기능 차이가 커서 사용법이 상이하고, 표준 SQL처럼 통일된 언어가 없음
	- 운영 및 마이그레이션이 어려울 수 있음

NoSQL은 분산 시스템을 전제로 설계되어, 데이터 샤딩, 복제, 라우팅 등을 자동으로 처리할 수 있는 구조를 갖고 있습니다. 반면 MySQL은 전통적인 중앙 집중형 구조로, 수평 확장을 위해 복잡한 샤딩 로직이나 복제를 별도로 구현해야 합니다. 또한 NoSQL은 JOIN이나 강력한 트랜잭션을 포기한 대신, 노드 간 동기화 부담이 적어 수평 확장에 매우 유리한 구조입니다.

##### RDB의 어떠한 특징 때문에 NoSQL에 비해 부하가 많이 걸릴 "수" 있을까요? (주의: 무조건 NoSQL이 RDB 보다 빠르다라고 생각하면 큰일 납니다!)
1. 🔄 **JOIN 연산과 정규화 구조**
- RDB는 **데이터 중복을 줄이기 위해 정규화를 적용**합니다.
- 이로 인해 실무에서는 **많은 테이블을 JOIN하여 데이터를 조합**하는 쿼리가 많습니다.
- 테이블이 커질수록 JOIN 연산 비용이 기하급수적으로 커지며,
- **디스크 I/O, CPU 부하 증가**로 이어질 수 있습니다.

 1. 🔒 **강한 일관성을 위한 트랜잭션 처리 (ACID)**
- RDB는 트랜잭션에서 **원자성, 일관성, 고립성, 지속성**을 보장하기 위해 
    → **락(Lock)**, **MVCC**, **로그 기록** 등 다양한 내부 처리를 수행합니다.

- 위와 같은 트랜잭션은 내부적으로 **락을 걸어 동시성 제어**를 하고,
- 이는 다중 사용자가 동시에 접근할 때 **성능 저하**나 **대기 시간 증가**로 이어질 수 있습니다.
    
1. 🔧 **스키마 고정 및 구조 변경 비용**
- RDB는 스키마가 고정되어 있어서 `ALTER TABLE` 같은 **구조 변경 시 전체 테이블 재작성**이 필요할 수 있음
- 데이터량이 많을 경우 이러한 작업은 **운영 환경에 큰 부하**를 유발할 수 있음

 1. 📏 **수직 확장에 의존**
- RDB는 전통적으로 **수직 확장(Scale-up)** 중심
- 하드웨어 성능의 한계에 도달하면 병목이 발생하고, 확장 비용도 매우 큼
- - 만약 데이터를 여러 서버에 분산해버리면 JOIN은 **서버 간 통신 비용이 발생**하고 **비효율적**이 됩니다.
- 그래서 **단일 서버에서 모든 데이터를 처리**하는 수직 확장 구조에 의존하게 됩니다.

##### NoSQL을 활용한 경험이 있나요? 있다면, 왜 RDB를 선택하지 않고 해당 DB를 선택했는지 설명해 주세요.

> 네, Redis를 사용한 경험이 있습니다.  
> 이전 프로젝트에서 **게시물의 하루 조회수와 총 조회수를 저장하고 조회하는 기능**을 구현할 때 Redis를 활용했습니다.

> Redis는 **인메모리 기반의 키-값 저장소**로 읽기/쓰기 속도가 매우 빠르기 때문
> 
✅ RDB 대신 Redis를 선택한 이유 

> Redis를 선택한 이유 중 하나는 바로 `INCR` 명령어 덕분이었습니다.  
> 하루 조회수나 총 조회수를 증가시킬 때, **Redis에서는 `INCR` 하나로 원자적(atomic)이고 빠르게 처리**할 수 있기 때문에,  
> 매 요청마다 조회수를 처리해도 병목 없이 동작했습니다.

> 반면 RDB를 사용할 경우에는 다음과 같은 처리 흐름이 필요합니다:
> 
> 1. 현재 값을 `SELECT`
>     
> 2. 값을 증가시켜 `UPDATE`  
>     이 과정에서 동시 요청이 많을 경우에는 **락(Lock) 처리**, 또는 **트랜잭션 처리**가 필요하게 되어 **부하가 발생**할 수 있습니다.

> Redis는 `INCR` 명령어 자체가 원자적으로 동작하기 때문에  
> **추가적인 동기화 코드 없이도 안전하게 동시성 처리가 가능했고**,  
> 이는 성능뿐만 아니라 **개발 생산성 측면에서도 유리**했습니다.

> **"빠른 처리 속도 + 원자적 연산 지원(INCR) + 동시성 안전성 확보"**  
> 이 세 가지가 RDB 대신 Redis를 선택한 이유입니다.

> 이 경험을 통해 Redis가 단순한 캐시 외에도 **실시간 수치 집계나 임시 저장소로도 매우 유용**하다는 것을 체감했고,  
> 시스템 특성과 성능 요구에 따라 적절한 기술을 선택하는 것이 중요하다는 점을 배웠습니다.

### 3. 트랜잭션이 무엇이고, ACID 원칙에 대해 설명해 주세요.
##### 설명
1. 트랜잭션(Transaction)이란?
> **하나의 작업 단위를 의미하며, 데이터베이스에서 반드시 모두 성공하거나 모두 실패해야 하는 작업 집합입니다.**
- 예를 들어, **송금** 같은 작업은 다음과 같은 단계를 거칩니다:
    1. A 계좌에서 1만 원 차감
    2. B 계좌에 1만 원 추가
- 이 두 작업은 **한 번에 처리되어야 하며**, 한 쪽만 실행되면 안 됩니다.  
    → 이처럼 **여러 데이터 변경을 하나의 논리적 단위로 묶는 것**이 트랜잭션입니다.
---
✅ 2. ACID 원칙이란?
트랜잭션이 제대로 작동하기 위해 데이터베이스는 **ACID 원칙**을 지켜야 합니다.  
ACID는 다음 네 가지 속성의 약자입니다.

 🔹 A — Atomicity (원자성)
- 트랜잭션의 작업은 **모두 성공하거나, 모두 실패해야 함**
- 중간에 오류가 나면 전체 작업이 롤백(Rollback)됨
    
🔹 C — Consistency (일관성)
- 트랜잭션 수행 전과 수행 후의 **데이터 상태는 항상 일관되어야 함**
- 데이터 제약조건, 규칙 등이 항상 유지되어야 함
- 계좌 금액이 마이너스가 되지 않는 조건, 외래키가 존재하는 경우만 insert 등

🔹 I — Isolation (고립성)
- 동시에 여러 트랜잭션이 실행되더라도, **서로 간섭받지 않아야 함**
- A 트랜잭션이 주문 테이블을 수정 중일 때,  
- B 트랜잭션이 **중간 상태의 데이터를 조회해서는 안 됨**
💡 격리 수준(Isolation Level)과 관련
- 고립성을 구현하는 수준에는 단계가 있음 (트레이드오프 있음)
    - READ UNCOMMITTED
    - READ COMMITTED
    - REPEATABLE READ (MySQL InnoDB 기본)
    - SERIALIZABLE
> 고립성이 높을수록 정합성은 좋지만 **성능 저하** 발생
    
 🔹 D — Durability (지속성)
- 트랜잭션이 성공적으로 완료되면, 그 결과는 **영구적으로 저장됨**
- 시스템이 꺼져도 데이터는 보존됨
-  DBMS는 트랜잭션을 커밋할 때, **데이터를 디스크에 반영하고 로그로 기록**함
    
- 일반적으로 **redo log** 또는 **write-ahead logging (WAL)** 사용

##### ACID 원칙 중, Durability를 DBMS는 어떻게 보장하나요?

 💾 **디스크 기록이 핵심이다**
RAM은 전원이 꺼지면 내용이 사라지므로  
→ 커밋된 데이터는 반드시 **디스크에 기록**되어야 안전합니다.  

그래서 DBMS는 트랜잭션 커밋 시 다음 순서를 따릅니다:
1. **트랜잭션 변경 내용을 로그(redo log, WAL)에 기록**
2. 로그가 디스크에 **성공적으로 flush 됐는지 확인**
3. 이후에만 **커밋을 완료**
    

> 즉, 트랜잭션 커밋이 성공했다는 것은  
> 그 변경사항이 **디스크에 안전하게 기록됐다는 뜻**
2. 📝 **Write-Ahead Logging (WAL)**
- 대부분의 DBMS(MySQL InnoDB, PostgreSQL 등)는  
    **WAL 또는 Redo log 방식**을 사용합니다.
- WAL의 핵심 원칙:
    > **"데이터를 디스크에 반영하기 전에, 변경 로그를 먼저 디스크에 기록하라"**
- 로그만 살아 있으면, 시스템이 꺼져도 **다시 복구할 수 있음**

2. 🔁 장애 발생 시 복구 방식
- 시스템 장애 후 재시작 시,  
    DBMS는 디스크에 남은 로그를 읽어들여
    - 아직 반영되지 않은 로그 → 다시 적용 (Redo)
    - 실패한 트랜잭션 → 무시 (Rollback)
> InnoDB는 트랜잭션의 지속성을 보장하기 위해 **Redo Log(After Image)**를 사용하고,  
> 트랜잭션 중 오류 발생 시 롤백을 위해 **Undo Log(Before Image)**도 함께 유지합니다.  
> Write-Ahead Logging 원칙에 따라, **변경 내용을 실제 데이터에 쓰기 전에 Redo Log를 디스크에 먼저 기록**하고,  
> COMMIT은 로그가 디스크에 안전하게 flush된 뒤에 완료됩니다.  
> 이를 통해 장애가 발생해도 **커밋된 트랜잭션은 Redo Log로 복구**,  
> 미커밋 트랜잭션은 Undo Log로 롤백이 가능하게 됩니다.

✅ 흐름 요약

1. 트랜잭션이 데이터 변경 요청
2. **Undo Log**에 이전 값 저장 (롤백 대비)
3. 변경 내용을 **Redo Log에 기록 (After Image)**
4. COMMIT 시 **Redo Log가 디스크에 flush됨**
5. 실제 데이터는 나중에 반영되더라도 OK
6. 장애 시 → Redo Log를 이용해 **복구(Replay)**, Undo Log로 **롤백**


##### 트랜잭션을 사용해 본 경험이 있나요? 어떤 경우에 사용할 수 있나요?
> 네, 트랜잭션을 사용한 경험이 있습니다.  
> 이전에 제가 개발한 서비스에서 **"유저가 질문에 대답하면 포인트를 얻는 기능"**을 구현한 적이 있는데,  
> 이 과정에서 **여러 작업을 하나의 트랜잭션으로 묶어 처리**했습니다.

- **질문에 대한 유저의 답변을 저장**
- **해당 유저의 포인트를 증가**
만약 답변은 저장됐지만 포인트는 지급되지 않는다면, 사용자 경험에 혼란을 줄 수 있고  
반대로 포인트만 올라가고 답변이 저장되지 않는다면 시스템적으로 오류가 발생합니다.

✅ 트랜잭션 도입 이유

> 이런 이유로 이 세 작업을 하나의 트랜잭션으로 묶어서 처리했고,  
> **도중에 하나라도 실패하면 전체 작업을 롤백(Rollback)** 하도록 구현했습니다.


##### 읽기에는 트랜잭션을 걸지 않아도 될까요?

🔹 InnoDB는 MVCC를 사용합니다 (멀티 버전 동시성 제어)
- 트랜잭션이 없어도, **SELECT는 커밋된 최신 버전의 데이터를 읽음**
- 기본 격리 수준인 **REPEATABLE READ**에서는 트랜잭션 내에서는  
    → 항상 **트랜잭션 시작 시점의 스냅샷을 기준으로 읽음**

📌 즉, **트랜잭션을 시작해야만 "일관된 스냅샷"을 보장**받을 수 있음

✅ 트랜잭션 없이 SELECT 할 경우

`SELECT * FROM posts WHERE id = 1;`

- 기본적으로 **가장 최근에 커밋된 값**을 읽음
- 읽는 도중 다른 트랜잭션이 값을 변경하거나 커밋하면 → 다음 SELECT에선 다른 값이 보일 수 있음
---

✅ 트랜잭션 안에서 SELECT 할 경우

`START TRANSACTION; SELECT * FROM posts WHERE id = 1; -- 이후 이 행이 수정되거나 커밋돼도 내 트랜잭션에서는 변하지 않음 SELECT * FROM posts WHERE id = 1; COMMIT;`

- 같은 트랜잭션 안에서는 **반복해서 읽어도 값이 동일** → "Repeatable Read"
- 트랜잭션이 끝나기 전까지는 **스냅샷이 고정**
-
✅ 그래서 언제 SELECT에 트랜잭션이 필요할까?

| 상황                         | 트랜잭션 필요 여부 | 설명               |
| -------------------------- | ---------- | ---------------- |
| 단순 조회 (read only)          | ❌ 불필요      | 최신 데이터 조회면 충분    |
| 반복 조회 시 결과 동일해야 함          | ✅ 필요       | 트랜잭션 내 스냅샷 필요    |
| 읽고 나서 조건에 따라 UPDATE/INSERT | ✅ 필요       | 동시성 문제 방지        |
| 집계 쿼리, 보고서 생성              | ✅ 필요       | 중간에 데이터가 바뀌면 안 됨 |

---


### 4. 트랜잭션 격리 레벨에 대해 설명해 주세요.
- 모든 DBMS가 4개의 레벨을 모두 구현하고 있나요? 그렇지 않다면 그 이유는 무엇일까요?
- 만약 MySQL을 사용하고 있다면, (InnoDB 기준) Undo 영역과 Redo 영역에 대해 설명해 주세요.
- 그런데, 스토리지 엔진이 정확히 무엇을 하는 건가요?

### 5. 인덱스가 무엇이고, 언제 사용하는지 설명해 주세요.
- 일반적으로 인덱스는 수정이 잦은 테이블에선 사용하지 않기를 권합니다. 왜 그럴까요?
- 앞 꼬리질문에 대해, 그렇다면 인덱스에서 사용하지 않겠다고 선택한 값은 위 정책을 그대로 따라가나요?
- ORDER BY/GROUP BY 연산의 동작 과정을 인덱스의 존재여부와 연관지어서 설명해 주세요.
- 기본키는 인덱스라고 할 수 있을까요? 그렇지 않다면, 인덱스와 기본키는 어떤 차이가 있나요?
- 그렇다면 외래키는요?
- 인덱스가 데이터의 물리적 저장에도 영향을 미치나요? 그렇지 않다면, 데이터는 어떤 순서로 물리적으로 저장되나요?
- 우리가 아는 RDB가 아닌 NoSQL (ex. Redis, MongoDB 등)는 인덱스를 갖고 있나요? 만약 있다면, RDB의 인덱스와는 어떤 차이가 있을까요?
- (A, B) 와 같은 방식으로 인덱스를 설정한 테이블에서, A 조건 없이 B 조건만 사용하여 쿼리를 요청했습니다. 해당 쿼리는 인덱스를 탈까요?


### 6. RDBMS, NoSQL에서의 클러스터링/레플리케이션 방식에 대해 설명해 주세요.
- 이러한 분산 환경에선, 트랜잭션을 어떻게 관리할 수 있을까요?
- 마스터, 슬레이브 데이터 동기화 전 까지의 데이터 정합성을 지키는 방법은 무엇이 있을까요?
- 다중 트랜잭션 상황에서의 Deadlock 상황과, 이를 해결하기 위한 방법에 대해 설명해 주세요.
- 샤딩 방식은 무엇인가요? 만약 본인이 DB를 분산해서 관리해야 한다면, 레플리케이션 방식과 샤딩 방식 중 어떤 것을 사용할 것 같나요?

### 7. 정규화가 무엇인가요?
- 정규화를 하지 않을 경우, 발생할 수 있는 이상현상에 대해 설명해 주세요.
- 각 정규화에 대해, 그 정규화가 진행되기 전/후의 테이블의 변화에 대해 설명해 주세요.
- 정규화가 무조건 좋은가요? 그렇지 않다면, 어떤 상황에서 역정규화를 하는게 좋은지 설명해 주세요.

### 8. View가 무엇이고, 언제 사용할 수 있나요?
- 그렇다면, View의 값을 수정해도 실제 테이블에는 반영되지 않나요?




### 9. DB Join이 무엇인지 설명하고, 각각의 종류에 대해 설명해 주세요.

### 10. B-Tree와 B+Tree에 대해 설명해 주세요.
### 11. DB Locking에 대해 설명해 주세요.
### 12. 트래픽이 높아질 때, DB는 어떻게 관리를 할 수 있을까요?
### 13. Schema가 무엇인가요?
### 14. DB의 Connection Pool에 대해 설명해 주세요.
### 15. Table Full Scan, Index Range Scan에 대해 설명해 주세요.
### 16. SQL Injection에 대해 설명해 주세요.

