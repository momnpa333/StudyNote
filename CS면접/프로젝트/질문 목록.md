
#### 1. 자기소개
##### 자기소개
안녕하십니까, 토스 페이먼츠에 지원한 권다운입니다.  

저는 안정적으로 서비스를 제공할 수 있도록 시스템 아키텍처와 성능 최적화에 꾸준히 관심을 가져왔습니다.  
특히, Redis 기반의 분산 락을 도입하여 데이터 일관성을 보장하거나, 조회수가 몰리는 API에서 병목 현상을 해결한 경험이 있습니다.  
이처럼 실제 문제를 분석하고 해결하며 사용자 경험을 개선하는 과정에 보람을 느끼고 있습니다.

저는 주어진 문제에 논리적으로 접근하고, 꾸준히 개선하며 더 나은 서비스를 만들어가는 데에 노력하였고, 이를 통해 YBM넷의 기술적 성장과 서비스 고도화에 기여하고 싶습니다.
#### 2. 레디스를 활용한 이유
##### 1. 관계형 데이터베이스를 활용했을 때
관계형 데이터베이스만 사용했을 때의 한계

1. **쓰기 부하에 약함**

- 유저 프로필 조회는 매우 자주 발생하는 이벤트이며, 조회할 때마다 **조회수 증가를 위해 쓰기 연산이 발생**합니다.
    
- 관계형 데이터베이스는 일반적으로 **쓰기 연산(INSERT/UPDATE)**에 대해 **트랜잭션 처리, WAL, 인덱스 관리 등 부가 작업이 많아**, I/O 부하가 큽니다.
    
- 특히 **인기 유저에게 트래픽이 몰리는 경우, 특정 row에 대해 집중적인 업데이트**가 발생하고, 이는 **락 경합과 디스크 병목**으로 이어져 전체 성능 저하를 유발합니다.
    

2. **락 경합**

- RDB는 row-level lock이나 shared/exclusive lock을 통해 정합성을 보장하지만, 이로 인해 **다중 트랜잭션 간 충돌**이 발생할 수 있습니다.
    
- 실제로도 Redisson 락을 도입한 이후 락 범위가 커졌을 때 병목이 발생했으며, 이는 RDB 환경에서도 **락을 통한 동시성 제어가 성능 병목이 될 수 있음**을 의미합니다.
    

 3. **실시간 응답 지연**

- 유저가 프로필을 클릭할 때마다 DB에 접근해 조회수를 UPDATE하면, **읽기와 쓰기 모두에서 지연**이 발생합니다.
    
- TPS가 중요한 실시간 서비스에서는 수 밀리초의 차이도 UX에 영향을 줄 수 있으며, DB 접근 없이 Redis만으로 처리하는 쪽이 **현저히 빠른 응답 속도**를 보장합니다.
    

---

✅ Redis를 함께 사용한 이유

|항목|관계형 DB|Redis|
|---|---|---|
|쓰기 처리 속도|느림 (디스크 기반, 락 존재)|빠름 (메모리 기반, 비동기 또는 atomic 연산)|
|동시성 제어|트랜잭션 기반, 경합 가능성 있음|분산 락 또는 atomic 연산으로 제어|
|실시간 처리|지연 발생 가능|낮은 지연 (ms 단위)|
|조회수 증가 같은 카운터 연산|락 필요, 경합 심함|`INCR` 한 줄로 원자적 처리 가능|

---

💡 정리

> 조회수 증가처럼 **읽기와 쓰기 모두가 빈번하게 발생하는 실시간 로직**은, RDB만으로 처리할 경우 **성능 저하, 락 경합, 응답 지연** 등의 문제가 발생할 수 있습니다.
> 
> 반면, **Redis는 메모리 기반의 빠른 처리와 원자적 연산 기능**을 제공하며, **RDB의 단점을 보완**할 수 있어 함께 사용하는 것이 적절합니다.
##### 2. 관계형 데이터베이스도 메모리 버퍼를 통해 io접근을 최소화 할수 있는데 굳이 redis가 필요했나요?
관계형 데이터베이스도 버퍼 캐시를 사용해 자주 조회되는 데이터를 메모리에 올려두고 디스크 I/O를 줄이지만, 기본적으로 디스크 기반 구조이기 때문에 트랜잭션 처리, 인덱스 관리, WAL 등의 부가 작업이 항상 수반됩니다. 특히, 쓰기 연산이 빈번할 경우에는 락 경합이나 디스크 병목으로 인해 성능 저하가 발생할 수 있습니다.

반면 Redis는 처음부터 끝까지 메모리에서 동작하고, 조회수 증가 같은 단순한 연산은 `INCR` 하나로 원자적으로 처리할 수 있어서 **락 없이도 빠르고 정확한 처리**가 가능합니다.

실제로 기존에는 Redis에서 값을 읽고 +1 후 다시 저장하는 방식이었는데, Redisson 분산락으로 인한 병목이 생겼고, INCR로 바꾸면서 TPS가 580 → 1117로 거의 두 배 가까이 향상됐습니다.

이런 경험을 통해 실시간성이 중요한 기능에서는 Redis가 단순 캐시 그 이상으로 중요한 역할을 한다는 것을 체감했습니다.
##### 관계형 DB도 버퍼 캐시로 I/O 줄이는데, Redis가 근본적으로 어떤 점에서 더 유리하다고 보시나요?
> 관계형 DB는 일부 데이터만 메모리 버퍼에 유지하고, 나머지는 디스크에 존재하므로, 캐시 적중이 안 되는 경우엔 디스크 I/O가 불가피합니다. 또한 트랜잭션 처리, 인덱스 업데이트, 로그 기록 등 부가 작업도 함께 동반되어 처리 경로가 길어집니다.
> 
> 반면 Redis는 모든 데이터를 메모리에 상주시켜 처리하므로 **디스크 I/O 자체가 거의 없고**, 모든 연산이 **O(1) 수준의 빠른 응답 속도**를 가집니다. 또한 별도의 인덱스나 SQL 실행 계획이 없기 때문에 단순 연산에 훨씬 유리합니다.
> 
> 특히 실시간 트래픽이 집중되는 상황에서는 Redis가 훨씬 예측 가능한 성능을 보여줬고, 락 최소화와 비동기 처리를 함께 활용해 응답 시간을 안정적으로 유지할 수 있었습니다.
##### 트랜잭션 처리, 인덱스 업데이트, 로그 기록은 왜 시간이 오래걸리나요 메모리내에서 처리가 불가한가요

✅ 왜 메모리 내에서만 처리할 수 없는가?

1. **지속성(내구성, Durability)을 보장해야 하므로 디스크 I/O가 필요함**

- RDB는 **ACID의 Durability**(트랜잭션 완료된 데이터는 반드시 저장돼야 함)를 보장해야 합니다.
    
- 그래서 쓰기 연산 시, 단순히 메모리에 올리는 것이 아니라 **디스크에 기록**하여 장애 발생 시에도 복구 가능해야 합니다.
    
- 대표적인 방식이 **WAL (Write-Ahead Logging)**으로, 데이터를 변경하기 전에 **변경 로그를 디스크에 먼저 기록**합니다.

2. **인덱스 구조 업데이트는 메모리와 디스크 모두 영향을 받음**

- RDB 인덱스(B+Tree 등)는 보통 **디스크 기반 구조**로 구성되어 있습니다.
    
- INSERT/UPDATE 시 인덱스를 재정렬하거나 노드를 분할해야 할 수 있으며, 이는 디스크 페이지 단위로 접근 및 수정이 필요합니다.
    
- 일부 핫 데이터를 메모리에서 유지하더라도, 결국 변경된 인덱스는 디스크에 반영해야 하므로 **디스크 I/O가 발생**합니다.
    

3. **트랜잭션은 격리성과 정합성을 위해 다양한 부가 작업이 필요**

- 트랜잭션은 단순한 데이터 변경이 아니라, **락 설정**, **MVCC용 undo/redo 로그 관리**, **트랜잭션 ID 추적** 등의 복잡한 메타 작업이 포함됩니다.
    
- 이런 부가 작업은 내부적으로 메모리뿐 아니라 디스크와의 연동 없이 구현하기 어렵습니다.
    
- 예: 다른 트랜잭션이 읽기 전에 변경 사항을 로그로 저장하거나, 롤백 시 복구할 데이터를 남겨야 함.
    

---

❗️즉, 메모리만 써서 빠르게 처리할 수 없는 이유는?

- RDB는 **데이터 정합성과 내구성**을 무엇보다 중요하게 생각하며,
    
- **장애 복구, 트랜잭션 롤백, 인덱스 정합성 보장**을 위해 반드시 디스크 기반 작업을 포함해야 합니다.
    
- 반면 Redis는 **“장애 시 데이터 유실을 허용하더라도 빠른 응답이 더 중요”**한 시스템에 적합하므로, 디스크 작업을 생략하거나 비동기로 처리합니다.
    

---
💡 요약:

> RDB의 트랜잭션 처리, 인덱스 업데이트, 로그 기록은 단순 메모리 연산이 아니라, **지속성과 정합성을 위한 디스크 기록이 필수**입니다.  
> 이 때문에 Redis와 달리 디스크 I/O가 성능 병목이 될 수 있고, 이는 RDB가 안정성과 정확성을 우선시하는 설계 철학에 기반합니다.

---

면접에서는 이 내용을 바탕으로 이렇게 요약하면 좋습니다:

✅ 면접 답변 예시:

> RDB는 단순히 메모리에서 데이터를 처리하는 게 아니라, 장애 복구와 정합성을 보장하기 위해 WAL 기록, 인덱스 업데이트, 트랜잭션 메타데이터 관리 등 **디스크 기반 작업이 필수적**입니다.  
> 반면 Redis는 실시간성이 더 중요한 경우에 메모리 기반으로 동작하면서 이런 부하를 피할 수 있어, 조회수 증가 같은 단순 고빈도 연산에 훨씬 적합했습니다.
#### 3. 레디스 구조

#### 4. 레디스 활용 방법
#### 5. 비동기로 처리한 이유
#### 6. pub-sub 구조의 장단점
#### 7. 다른 방안
#### 8.  프로젝트 아키텍처 설명
#### 9. ELB를 사용한 이유
#### 10. 복합 인덱스를 사용한 이유
#### 11. 퍼사드 패턴을 활용한 이유
#### 12. 데드락이 발생한 이유와 연관관계를 제거한 이유
#### 13. 더미데이터를 설정한 이유 및 vuser 설정 이유
#### 14. 테스트 자동화
