
#### 1. 자기소개
##### 자기소개
안녕하십니까, 토스 페이먼츠에 지원한 권다운입니다.  

저는 안정적으로 서비스를 제공할 수 있도록 시스템 아키텍처와 성능 최적화에 꾸준히 관심을 가져왔습니다.  
특히, Redis 기반의 분산 락을 도입하여 데이터 일관성을 보장하거나, 조회수가 몰리는 API에서 병목 현상을 해결한 경험이 있습니다.  
이처럼 실제 문제를 분석하고 해결하며 사용자 경험을 개선하는 과정에 보람을 느끼고 있습니다.

저는 주어진 문제에 논리적으로 접근하고, 꾸준히 개선하며 더 나은 서비스를 만들어가는 데에 노력하였고, 이를 통해 YBM넷의 기술적 성장과 서비스 고도화에 기여하고 싶습니다.
#### 2. 레디스를 활용한 이유
##### 1. 관계형 데이터베이스를 활용했을 때
관계형 데이터베이스만 사용했을 때의 한계

1. **쓰기 부하에 약함**

- 유저 프로필 조회는 매우 자주 발생하는 이벤트이며, 조회할 때마다 **조회수 증가를 위해 쓰기 연산이 발생**합니다.
    
- 관계형 데이터베이스는 일반적으로 **쓰기 연산(INSERT/UPDATE)**에 대해 **트랜잭션 처리, WAL, 인덱스 관리 등 부가 작업이 많아**, I/O 부하가 큽니다.
    
- 특히 **인기 유저에게 트래픽이 몰리는 경우, 특정 row에 대해 집중적인 업데이트**가 발생하고, 이는 **락 경합과 디스크 병목**으로 이어져 전체 성능 저하를 유발합니다.
    

2. **락 경합**

- RDB는 row-level lock이나 shared/exclusive lock을 통해 정합성을 보장하지만, 이로 인해 **다중 트랜잭션 간 충돌**이 발생할 수 있습니다.
    
- 실제로도 Redisson 락을 도입한 이후 락 범위가 커졌을 때 병목이 발생했으며, 이는 RDB 환경에서도 **락을 통한 동시성 제어가 성능 병목이 될 수 있음**을 의미합니다.
    

 3. **실시간 응답 지연**

- 유저가 프로필을 클릭할 때마다 DB에 접근해 조회수를 UPDATE하면, **읽기와 쓰기 모두에서 지연**이 발생합니다.
    
- TPS가 중요한 실시간 서비스에서는 수 밀리초의 차이도 UX에 영향을 줄 수 있으며, DB 접근 없이 Redis만으로 처리하는 쪽이 **현저히 빠른 응답 속도**를 보장합니다.
    

---

✅ Redis를 함께 사용한 이유

|항목|관계형 DB|Redis|
|---|---|---|
|쓰기 처리 속도|느림 (디스크 기반, 락 존재)|빠름 (메모리 기반, 비동기 또는 atomic 연산)|
|동시성 제어|트랜잭션 기반, 경합 가능성 있음|분산 락 또는 atomic 연산으로 제어|
|실시간 처리|지연 발생 가능|낮은 지연 (ms 단위)|
|조회수 증가 같은 카운터 연산|락 필요, 경합 심함|`INCR` 한 줄로 원자적 처리 가능|

---

💡 정리

> 조회수 증가처럼 **읽기와 쓰기 모두가 빈번하게 발생하는 실시간 로직**은, RDB만으로 처리할 경우 **성능 저하, 락 경합, 응답 지연** 등의 문제가 발생할 수 있습니다.
> 
> 반면, **Redis는 메모리 기반의 빠른 처리와 원자적 연산 기능**을 제공하며, **RDB의 단점을 보완**할 수 있어 함께 사용하는 것이 적절합니다.
##### 2. 관계형 데이터베이스도 메모리 버퍼를 통해 io접근을 최소화 할수 있는데 굳이 redis가 필요했나요?
관계형 데이터베이스도 버퍼 캐시를 사용해 자주 조회되는 데이터를 메모리에 올려두고 디스크 I/O를 줄이지만, 기본적으로 디스크 기반 구조이기 때문에 트랜잭션 처리, 인덱스 관리, WAL 등의 부가 작업이 항상 수반됩니다. 특히, 쓰기 연산이 빈번할 경우에는 락 경합이나 디스크 병목으로 인해 성능 저하가 발생할 수 있습니다.

반면 Redis는 처음부터 끝까지 메모리에서 동작하고, 조회수 증가 같은 단순한 연산은 `INCR` 하나로 원자적으로 처리할 수 있어서 **락 없이도 빠르고 정확한 처리**가 가능합니다.

실제로 기존에는 Redis에서 값을 읽고 +1 후 다시 저장하는 방식이었는데, Redisson 분산락으로 인한 병목이 생겼고, INCR로 바꾸면서 TPS가 580 → 1117로 거의 두 배 가까이 향상됐습니다.

이런 경험을 통해 실시간성이 중요한 기능에서는 Redis가 단순 캐시 그 이상으로 중요한 역할을 한다는 것을 체감했습니다.
##### 관계형 DB도 버퍼 캐시로 I/O 줄이는데, Redis가 근본적으로 어떤 점에서 더 유리하다고 보시나요?
> 관계형 DB는 일부 데이터만 메모리 버퍼에 유지하고, 나머지는 디스크에 존재하므로, 캐시 적중이 안 되는 경우엔 디스크 I/O가 불가피합니다. 또한 트랜잭션 처리, 인덱스 업데이트, 로그 기록 등 부가 작업도 함께 동반되어 처리 경로가 길어집니다.
> 
> 반면 Redis는 모든 데이터를 메모리에 상주시켜 처리하므로 **디스크 I/O 자체가 거의 없고**, 모든 연산이 **O(1) 수준의 빠른 응답 속도**를 가집니다. 또한 별도의 인덱스나 SQL 실행 계획이 없기 때문에 단순 연산에 훨씬 유리합니다.
> 
> 특히 실시간 트래픽이 집중되는 상황에서는 Redis가 훨씬 예측 가능한 성능을 보여줬고, 락 최소화와 비동기 처리를 함께 활용해 응답 시간을 안정적으로 유지할 수 있었습니다.
##### 트랜잭션 처리, 인덱스 업데이트, 로그 기록은 왜 시간이 오래걸리나요 메모리내에서 처리가 불가한가요

✅ 왜 메모리 내에서만 처리할 수 없는가?

1. **지속성(내구성, Durability)을 보장해야 하므로 디스크 I/O가 필요함**

- RDB는 **ACID의 Durability**(트랜잭션 완료된 데이터는 반드시 저장돼야 함)를 보장해야 합니다.
    
- 그래서 쓰기 연산 시, 단순히 메모리에 올리는 것이 아니라 **디스크에 기록**하여 장애 발생 시에도 복구 가능해야 합니다.
    
- 대표적인 방식이 **WAL (Write-Ahead Logging)**으로, 데이터를 변경하기 전에 **변경 로그를 디스크에 먼저 기록**합니다.

2. **인덱스 구조 업데이트는 메모리와 디스크 모두 영향을 받음**

- RDB 인덱스(B+Tree 등)는 보통 **디스크 기반 구조**로 구성되어 있습니다.
    
- INSERT/UPDATE 시 인덱스를 재정렬하거나 노드를 분할해야 할 수 있으며, 이는 디스크 페이지 단위로 접근 및 수정이 필요합니다.
    
- 일부 핫 데이터를 메모리에서 유지하더라도, 결국 변경된 인덱스는 디스크에 반영해야 하므로 **디스크 I/O가 발생**합니다.
    

3. **트랜잭션은 격리성과 정합성을 위해 다양한 부가 작업이 필요**

- 트랜잭션은 단순한 데이터 변경이 아니라, **락 설정**, **MVCC용 undo/redo 로그 관리**, **트랜잭션 ID 추적** 등의 복잡한 메타 작업이 포함됩니다.
    
- 이런 부가 작업은 내부적으로 메모리뿐 아니라 디스크와의 연동 없이 구현하기 어렵습니다.
    
- 예: 다른 트랜잭션이 읽기 전에 변경 사항을 로그로 저장하거나, 롤백 시 복구할 데이터를 남겨야 함.
    

---

❗️즉, 메모리만 써서 빠르게 처리할 수 없는 이유는?

- RDB는 **데이터 정합성과 내구성**을 무엇보다 중요하게 생각하며,
    
- **장애 복구, 트랜잭션 롤백, 인덱스 정합성 보장**을 위해 반드시 디스크 기반 작업을 포함해야 합니다.
    
- 반면 Redis는 **“장애 시 데이터 유실을 허용하더라도 빠른 응답이 더 중요”**한 시스템에 적합하므로, 디스크 작업을 생략하거나 비동기로 처리합니다.
    

---
💡 요약:

> RDB의 트랜잭션 처리, 인덱스 업데이트, 로그 기록은 단순 메모리 연산이 아니라, **지속성과 정합성을 위한 디스크 기록이 필수**입니다.  
> 이 때문에 Redis와 달리 디스크 I/O가 성능 병목이 될 수 있고, 이는 RDB가 안정성과 정확성을 우선시하는 설계 철학에 기반합니다.

---

면접에서는 이 내용을 바탕으로 이렇게 요약하면 좋습니다:

✅ 면접 답변 예시:

> RDB는 단순히 메모리에서 데이터를 처리하는 게 아니라, 장애 복구와 정합성을 보장하기 위해 WAL 기록, 인덱스 업데이트, 트랜잭션 메타데이터 관리 등 **디스크 기반 작업이 필수적**입니다.  
> 반면 Redis는 실시간성이 더 중요한 경우에 메모리 기반으로 동작하면서 이런 부하를 피할 수 있어, 조회수 증가 같은 단순 고빈도 연산에 훨씬 적합했습니다.
#### 3. 레디스 구조
✅ 1. **Redis의 기본 구조: In-Memory Key-Value Store**

- Redis는 **메모리 기반의 Key-Value 저장소**입니다.
    
- 모든 데이터는 **메모리(RAM)**에 저장되며, 선택적으로 디스크에 **백업(AOF, RDB)**을 할 수 있습니다.
    
- 데이터는 Key-Value 쌍으로 저장되며, 다양한 **데이터 타입**을 지원합니다 (단순 문자열뿐만 아니라, 리스트, 집합, 정렬된 집합 등).
    

 ✅ 2. **Redis의 자료구조 (Value 타입)**

|자료형|설명|사용 예시|
|---|---|---|
|**String**|가장 기본적인 자료형. 숫자, 텍스트, JSON 등 모두 저장 가능|`INCR`, `GET`, `SET` 등|
|**List**|순서가 있는 문자열 목록. 양방향 삽입 가능|메시지 큐, 로그|
|**Set**|중복 없는 원소들의 집합|유니크 방문자 목록|
|**Sorted Set (ZSet)**|점수(score)로 정렬되는 집합|랭킹, 우선순위 큐|
|**Hash**|하나의 Key에 여러 필드와 값을 저장|사용자 프로필, 객체 저장|
|**Bitmap / HyperLogLog / Stream**|비트 연산, 근사 카운팅, 로그 수집 등 특수 목적용 자료형|고급 용도|
 ✅ 3. **Persistence (지속성) 구조: AOF & RDB**

- Redis는 메모리 기반이지만, 장애 복구를 위해 데이터를 디스크에 저장할 수 있습니다.
    

|방식|설명|특징|
|---|---|---|
|**RDB (Snapshot)**|일정 시간 간격으로 전체 데이터를 디스크에 저장|빠름, 간단하지만 일부 유실 가능|
|**AOF (Append Only File)**|모든 쓰기 명령을 순차적으로 파일에 기록|장애 복구 시 유리하지만 파일이 큼|
|둘 다 사용 가능|안정성과 성능을 모두 확보할 수 있음||

> Redis는 `fsync()`를 통한 flush 정책도 설정할 수 있어, **쓰기 성능 vs 내구성**을 조절할 수 있습니다.

---
✅ 4. **싱글 스레드 이벤트 루프 기반 구조**

- Redis는 **단일 스레드**로 동작하며, 내부적으로는 **이벤트 루프** 기반으로 동작합니다.
    
- 하나의 클라이언트 요청을 **빠르게 처리한 후 다음 요청으로 이동**합니다 → context switching 없음 → **속도 빠름**
    
- 하지만 하나의 요청이 너무 오래 걸리면 전체 지연이 발생할 수 있으므로, 보통 **짧고 빠른 연산**에 적합합니다.
    
✅ 면접 답변용 요약

> Redis는 메모리 기반의 Key-Value 저장소로, 다양한 자료구조(String, Hash, Set 등)를 지원합니다.  
> 단일 스레드 이벤트 루프 기반 구조로 빠른 응답이 가능하며, `INCR`, `SET`, `GET` 같은 연산이 대부분 O(1) 시간 내에 처리됩니다.  
> 지속성을 위해 RDB 스냅샷이나 AOF 로그를 통해 디스크에 데이터를 저장할 수 있고, 요구사항에 따라 적절한 방식으로 설정 가능합니다.  
> 이런 구조 덕분에 Redis는 캐시, 세션 저장, 실시간 통계, 분산락 등 다양한 목적으로 널리 사용됩니다.

#### 4. 레디스 활용 방법
##### 방법
✅ RedisVisitCount – 조회수 집계용 엔티티
 📦 구조 요약

```java
@RedisHash("VisitCount")
public class RedisVisitCount {    
	@Id 
	private Long hostId;     
	private int dailyVisited;    
	private int totalVisited; 
}
```
✅ 역할

- 특정 유저(`hostId`) 프로필의 **총 조회수**와 **일일 조회수**를 Redis에 저장
    
- 매번 DB에 접근하지 않고도, 조회 요청마다 이 객체의 `visit()` 메서드를 통해 두 카운트를 Redis 상에서 즉시 증가
    
- 주기적 배치 작업 등을 통해 `updateVisited()`를 호출하여 DB에 총 조회수를 반영하고, 일일 조회수를 리셋
    
 ⚙️ 사용 목적 및 장점

- **빠른 카운팅 처리(INCR 대체)**: 객체 필드 기반으로 Redis에서 처리하여 API 응답 지연 최소화
    
- **DB 쓰기 부하 감소**: 조회마다 DB를 UPDATE하지 않고, 일정 주기로만 동기화
    
- **일별 통계와 누적 통계를 동시에 관리** 가능
    
✅ RedisVisitor – 방문자 중복 체크용 엔티티

📦 구조 요약

```java
@RedisHash("Visitor") 
public class RedisVisitor {
	@Id 
	private String id; // "{hostId}:{visitorIp}"    
	private Long hostId;   
	private String visitorIp;     
	private LocalDateTime visitTime; 
}
```
✅ 역할
- 방문자 정보를 Redis에 저장하여 **같은 IP가 동일 host를 짧은 시간 내 반복 조회하는 것을 방지**
    
- TTL을 설정하면, 예를 들어 하루가 지나면 자동으로 만료되어 다음날 방문으로 인정 가능
   
⚙️ 사용 목적 및 장점

- **중복 방문 방지**: `SETNX` 개념처럼 Redis에 키가 없을 때만 조회수 증가 허용
    
- **TTL 기반 자동 만료**: 방문기록은 일정 시간이 지나면 만료되어 재방문 허용
    
- **추후 분석(방문 시간, 지역 등)**을 위한 기록 저장도 가능
    

---
🧠 면접 답변 예시

> 유저 프로필 조회 기능에서 Redis를 활용해 조회수를 관리했습니다.  
> `RedisVisitCount`는 hostId를 기준으로 총 조회수와 일일 조회수를 Redis 객체로 저장하고, 매 요청마다 메모리 내에서 증가시켜 빠르게 처리합니다.  
> 주기적으로 DB와 동기화하여 totalVisited를 반영하며, 일일 조회수는 리셋됩니다.
> 
> 중복 조회 방지를 위해 `RedisVisitor`를 설계했고, hostId와 IP를 조합한 키로 Redis에 저장합니다.  
> 일정 시간 동안 중복 방문이 감지되면 조회수 증가를 막고, TTL 설정을 통해 자동 만료되도록 했습니다.
> 
> 이 구조는 조회수 증가와 중복 방문 처리라는 서로 다른 목적에 맞춰 각각 최적화된 키와 값 설계를 적용한 예입니다.

🚀 성능상의 이점 요약

- 조회 시 DB 접근 없음 → **응답 지연 최소화**
    
- 조회수 증가 및 중복 처리 모두 Redis에서 수행 → **트래픽 분산**
    
- TTL 활용 및 RedisHash 구조 → **유지보수 용이**
##### 왜 Redis는 조회수 증가와 같은 고빈도 쓰기 작업에 적합하다고 판단하셨나요?

    
##### 2. **왜 INCR 명령을 사용할 때 락이 필요 없다고 할 수 있나요? 내부적으로 어떤 보장 구조가 있나요?**
    
3. **왜 Redis에 저장한 데이터를 RDB 대신 Redis에 둬야 했나요? 무조건 캐시가 아닌 저장소로도 활용한 이유는 무엇인가요?**
    
4. **왜 Redisson 분산락을 사용했나요? 애플리케이션 내부 락(synchronized 등)으로는 안 되었던 이유는 무엇인가요?**
    
5. **왜 Redis의 키 설계에서 날짜, IP, userId 등을 분리해서 포함하셨나요? 단일 키로는 안 되었나요?**
    
6. **왜 Redis의 Hash 구조를 사용하셨나요? 단순 String으로 저장하는 방식과 비교해서 어떤 이점이 있었나요?**
    
7. **왜 TTL을 설정했나요? TTL 없이 직접 만료 처리하면 안 되는 이유는 무엇인가요?**
    
8. **왜 Redis는 싱글 스레드인데도 멀티 코어 DB보다 빠른 경우가 있나요?**
    
9. **왜 Redis의 AOF와 RDB를 동시에 사용하는 경우가 많을까요? 한 쪽만 쓰면 안 되는 이유는 무엇인가요?**
    
10. **왜 Redis는 데이터 유실 가능성이 있음에도 불구하고 실시간 시스템에서 널리 사용되나요?**
#### 5. 비동기로 처리한 이유
#### 6. pub-sub 구조의 장단점
#### 7. 다른 방안
#### 8.  프로젝트 아키텍처 설명
#### 9. ELB를 사용한 이유
#### 10. 복합 인덱스를 사용한 이유
#### 11. 퍼사드 패턴을 활용한 이유
#### 12. 데드락이 발생한 이유와 연관관계를 제거한 이유
#### 13. 더미데이터를 설정한 이유 및 vuser 설정 이유
#### 14. 테스트 자동화
#### 15. 필터가 아닌 인터셉트를 이용해서 로그인을 구현한 이유
#### 16. 토스페이 안붙힌 이유

